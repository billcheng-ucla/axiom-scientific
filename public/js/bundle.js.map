{"version":3,"sources":["node_modules/browser-pack/_prelude.js","app/actions/LoginActions.js","app/actions/NavbarActions.js","app/actions/SignUpActions.js","app/alt.js","app/components/AxiomSci.js","app/components/Footer.js","app/components/Home.js","app/components/Login.js","app/components/Navbar.js","app/components/SignUp.js","app/main.js","app/routes.js","app/stores/LoginStore.js","app/stores/NavbarStore.js","app/stores/SignUpStore.js","node_modules/deep-equal/index.js","node_modules/deep-equal/lib/is_arguments.js","node_modules/deep-equal/lib/keys.js","node_modules/history/lib/Actions.js","node_modules/history/lib/AsyncUtils.js","node_modules/history/lib/DOMStateStorage.js","node_modules/history/lib/DOMUtils.js","node_modules/history/lib/ExecutionEnvironment.js","node_modules/history/lib/createBrowserHistory.js","node_modules/history/lib/createDOMHistory.js","node_modules/history/lib/createHistory.js","node_modules/history/lib/createLocation.js","node_modules/history/lib/deprecate.js","node_modules/history/lib/extractPath.js","node_modules/history/lib/parsePath.js","node_modules/history/lib/runTransitionHook.js","node_modules/invariant/browser.js","node_modules/lodash/lodash.js","node_modules/process/browser.js","node_modules/warning/browser.js"],"names":[],"mappings":"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AAf;AACA,OAAK,IAAL,GAAY,EAAZ;AACA,OAAK,EAAL,GAAU,EAAV;AACA,OAAK,GAAL,GAAW,EAAX;AACA,OAAK,KAAL,GAAa,EAAb;AACA;;;;+BAEY,C,EACb;AACC,QAAK,EAAE,MAAF,CAAS,IAAd,IAAsB,EAAE,MAAF,CAAS,KAA/B;AACA;;;;;;kBAGa,cAAI,WAAJ,CAAgB,WAAhB,C;;;AC1Bf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/EA;AACA;AACA;AACA;AACA;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACjLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AClqIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACxLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"bundle.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","import React from 'react'\nimport alt from '../alt'\nclass LoginActions\n{\n\tconstructor()\n\t{\n\t\tthis.generateActions(\n\t\t\t'updateUser'\n\t\t)\n\t}\n\n\tloginUser(user)\n\t{\n\t\t$.ajax(\n\t\t{\n\t\t\ttype: 'POST',\n\t\t\turl: '/login',\n\t\t\tdata: user,\n\t\t\tsuccess: loginSuccess\n\t\t})\n\t}\n}\n\nvar loginSuccess = function(data)\n{\n\tconsole.log(data)\n\tlocalStorage.setItem(\"user\", JSON.stringify(data))\n\tconsole.log(data.email)\n\tconsole.log(JSON.parse(localStorage.user).email)\n\tlocation.href = '/'\n}\n\nexport default alt.createActions(LoginActions)","import alt from '../alt'\nimport {assign} from 'lodash'\n\nclass NavbarActions\n{\n\tconstructor()\n\t{\n\t\tthis.generateActions(\n\t\t\t'updateShoppingCart',\n\t\t\t'updateSeachQuery',\n\t\t)\n\t}\n}\n\nexport default alt.createActions(NavbarActions)","import React from 'react'\nimport alt from '../alt'\nclass SignUpActions\n{\n\tconstructor()\n\t{\n\t\tthis.generateActions(\n\t\t\t'updateUser'\n\t\t)\n\t}\n\n\tcreateUser(user)\n\t{\n\t\t$.ajax(\n\t\t{\n\t\t\ttype: 'POST',\n\t\t\turl: '/api/users',\n\t\t\tdata: user\n\t\t})\n\t}\n}\n\nexport default alt.createActions(SignUpActions)","import Alt from 'alt'\n\nvar alt = new Alt()\n\nexport default alt","import React from 'react'\nimport Navbar from './Navbar'\nimport Footer from './Footer'\n\nclass AxiomSci extends React.Component\n{\n\trender()\n\t{\n\t\treturn(\n\t\t\t<div>\n\t\t\t\t<Navbar history={this.props.history}/>\n\t\t\t\t{this.props.children}\n\t\t\t\t<Footer />\n\t\t\t</div>\n\t\t)\n\t}\n}\n\nexport default AxiomSci","import React from 'react'\nimport {Link} from 'react-router'\nimport FooterStore from '../stores/NavbarStore'\nimport FooterActions from '../actions/NavbarActions'\n\nclass Footer extends React.Component\n{\n\tconstructor(props)\n\t{\n\t\tsuper(props)\n\t\tthis.state = FooterStore.getState()\n\t\tthis.onChange = this.onChange.bind(this)\n\t}\n\n\tcomponentDidMount() \n\t{\n\t    FooterStore.listen(this.onChange);\n    }\n\n    componentWillUnmount() \n    {\n    \tFooterStore.unlisten(this.onChange);\n  \t}\n\n  \tonChange(state)\n  \t{\n  \t\tthis.setState(state)\n  \t}\n\n  \trender()\n  \t{\n  \t\tvar links = [\"About Us\", \"Privacy Policy\", \"Terms of Use\", \"Careers\", \"Contact\", \"Help\"].map((link) => {\n  \t\t\treturn (\n  \t\t\t\t<div className='col-lg-2' key={link}>\n  \t\t\t\t\t<Link to='#'>\n  \t\t\t\t\t\t{link}\n  \t\t\t\t\t</Link>\n  \t\t\t\t</div>\n  \t\t\t)\n  \t\t})\n\n  \t\treturn (\n  \t\t\t<footer>\n  \t\t\t\t<div className=\"container-fluid grey\">\n  \t\t\t\t\t<div className=\"row\">\n  \t\t\t\t\t\t{links}\n  \t\t\t\t\t</div>\n  \t\t\t\t\t<div className=\"row\">\n  \t\t\t\t\t\tAxiom-Scientific. All rights reserved.\n  \t\t\t\t\t</div>\n  \t\t\t\t</div>\n  \t\t\t</footer>\n  \t\t)\n  \t}\n}\n\nexport default Footer","import React from 'react'\n\nclass Home extends React.Component \n{\n  render() \n  {\n    return (\n      <div className='alert alert-info'>\n        Hello from Home Component\n      </div>\n    )\n  }\n}\n\nexport default Home","import React from 'react'\nimport {Link} from 'react-router'\nimport LoginStore from '../stores/LoginStore'\nimport LoginActions from '../actions/LoginActions'\n\nclass Login extends React.Component\n{\n\tconstructor(props)\n\t{\n\t\tsuper(props)\n\t\tthis.state = LoginStore.getState()\n\t\tthis.onChange = this.onChange.bind(this)\n\t}\n\n\tcomponentDidMount()\n\t{\n\t\tLoginStore.listen(this.onChange)\n\t}\n\n\tcomponentWillUnmount()\n\t{\n\t\tLoginStore.unlisten(this.onChange)\n\t}\n\n\tonChange(state)\n\t{\n\t\tthis.setState(state)\n\t}\n\n\thandleSubmit(e)\n\t{\n\t\te.preventDefault()\n\t\tvar user = {\n\t\t\t\"email\": this.state.email,\n\t\t\t\"password\": this.state.password\n\t\t}\n\t\tLoginActions.loginUser(user)\n\t}\n\n\trender()\n\t{\n\t\treturn (\n\t\t\t<form onSubmit={this.handleSubmit.bind(this)}>\n\t\t\t\t<input type='email' className='form-control' name='email' onChange={LoginActions.updateUser} value={this.state.email} placeholder='Email' required/>\n\t\t\t\t<input type='password' className='form-control' name='password' onChange={LoginActions.updateUser} value={this.state.password} placeholder='Password' required/>\n\t\t\t\t<button type='submit' className='btn btn-primary'>Login</button>\n\t\t\t\t<div>Dont have an account?</div>\n\t\t\t\t<Link to='/signup'>Sign Up Here</Link>\n\t\t\t</form>\n\t\t)\n\t}\n}\n\nexport default Login","import React from 'react'\nimport {Link} from 'react-router'\nimport NavbarStore from '../stores/NavbarStore'\nimport NavbarActions from '../actions/NavbarActions'\n\nclass Navbar extends React.Component\n{\n\tconstructor(props)\n\t{\n\t\tsuper(props)\n\t\tthis.state = NavbarStore.getState()\n\t\tthis.onChange = this.onChange.bind(this)\n\t}\n\n\tcomponentDidMount()\n\t{\n\t\tNavbarStore.listen(this.onChange)\n\t\t// NavbarActions.getCharacterCount()\n\t\t// let socket = io.connect()\n\t}\n\n\tcomponentWillUnmount()\n\t{\n\t\tNavbarStore.unlisten(this.onChange)\n\t}\n\n\tonChange(state)\n\t{\n\t\tthis.setState(state)\n\t}\n\n\thandleSearch()\n\t{\n\t\tconsole.log(\"Searching...\")\n\t}\n\n\trender()\n\t{\n\t\treturn (\n\t\t\t<nav className='navbar navbar-default navbar-static-top'>\n\t\t\t\t<div className='container-fluid'>\n\t\t\t\t\t<div className='row blue'>\n\t\t\t\t\t\t<div>Axiom-Scientific</div>\n\t\t\t\t\t\t<Link to='/login' className='btn btn-default'>Login</Link>\n\t\t\t\t\t\t<Link to='/signup' className='btn btn-default'>Sign Up</Link>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div className='row'>\n\t\t\t\t\t\t<form ref='searchForm' className='navbar-form navbar-left animated' onSubmit={this.handleSearch.bind(this)}>\n\t\t\t\t            <div className='input-group'>\n\t\t\t\t              <input type='text' className='form-control' placeholder={\"Type Item # or keyword\"} value={this.state.searchQuery} onChange={NavbarActions.updateSearchQuery} />\n\t\t\t\t              <span className='input-group-btn'>\n\t\t\t\t                <button className='btn btn-default' onClick={this.handleSearch.bind(this)}><span className='glyphicon glyphicon-search'></span></button>\n\t\t\t\t              </span>\n\t\t\t\t            </div>\n\t\t\t\t\t\t</form>\n\t\t\t\t\t\t<div>My Cart</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</nav>\n\t\t)\n\t}\n}\n\nexport default Navbar","import React from 'react'\nimport {Link} from 'react-router'\nimport SignUpStore from '../stores/SignUpStore'\nimport SignUpActions from '../actions/SignUpActions'\n// import TextField from 'material-ui/TextField'\nclass SignUp extends React.Component\n{\n\tconstructor(props)\n\t{\n\t\tsuper(props)\n\t\tthis.state = SignUpStore.getState()\n\t\tthis.onChange = this.onChange.bind(this)\n\t}\n\n\tcomponentDidMount()\n\t{\n\t\tSignUpStore.listen(this.onChange)\n\t}\n\n\tcomponentWillUnmount()\n\t{\n\t\tSignUpStore.unlisten(this.onChange)\n\t}\n\n\tonChange(state)\n\t{\n\t\tthis.setState(state)\n\t}\n\n\thandleSubmit(e)\n\t{\n\t\te.preventDefault()\n\t\tvar user = {\n\t\t\t\"fname\": this.state.fname,\n\t\t\t\"lname\": this.state.lname,\n\t\t\t\"email\": this.state.email,\n\t\t\t\"password\": this.state.password,\n\t\t\t\"address\": this.state.address,\n\t\t\t\"city\": this.state.city,\n\t\t\t\"st\": this.state.st,\n\t\t\t\"zip\": this.state.zip,\n\t\t\t\"phone\": this.state.phone\n\t\t}\n\t\tconsole.log(user)\n\t\tSignUpActions.createUser(user)\n\t}\n\n\trender() // In the future, inputs probably can b components\n\t{\n\t\treturn (\n\t\t\t<form onSubmit={this.handleSubmit.bind(this)}>\n\t\t\t\t<input type='text' className='form-control' name='fname' onChange={SignUpActions.updateUser} value={this.state.fname} placeholder='First Name' required/>\n\t\t\t\t<input type='text' className='form-control' name='lname' onChange={SignUpActions.updateUser} value={this.state.lname} placeholder='Last Name' />\n\t\t\t\t<input type='email' className='form-control' name='email' onChange={SignUpActions.updateUser} value={this.state.email} placeholder='Email' required/>\n\t\t\t\t<input type='password' className='form-control' name='password' onChange={SignUpActions.updateUser} value={this.state.password} placeholder='Password' required/>\n\t\t\t\t<input type='text' className='form-control' name='address' onChange={SignUpActions.updateUser} value={this.state.address} placeholder='Address' required/>\n\t\t\t\t<input type='text' className='form-control' name='city' onChange={SignUpActions.updateUser} value={this.state.city} placeholder='City' required/>\n\t\t\t\t<select name='st' className='form-control' onChange={SignUpActions.updateUser}>\n\t\t\t\t\t<option value=''>Please Select a State</option>\n\t\t\t\t\t<option value=\"AL\">Alabama</option>\n\t\t\t\t\t<option value=\"AK\">Alaska</option>\n\t\t\t\t\t<option value=\"AZ\">Arizona</option>\n\t\t\t\t\t<option value=\"AR\">Arkansas</option>\n\t\t\t\t\t<option value=\"CA\">California</option>\n\t\t\t\t\t<option value=\"CO\">Colorado</option>\n\t\t\t\t\t<option value=\"CT\">Connecticut</option>\n\t\t\t\t\t<option value=\"DE\">Delaware</option>\n\t\t\t\t\t<option value=\"DC\">District Of Columbia</option>\n\t\t\t\t\t<option value=\"FL\">Florida</option>\n\t\t\t\t\t<option value=\"GA\">Georgia</option>\n\t\t\t\t\t<option value=\"HI\">Hawaii</option>\n\t\t\t\t\t<option value=\"ID\">Idaho</option>\n\t\t\t\t\t<option value=\"IL\">Illinois</option>\n\t\t\t\t\t<option value=\"IN\">Indiana</option>\n\t\t\t\t\t<option value=\"IA\">Iowa</option>\n\t\t\t\t\t<option value=\"KS\">Kansas</option>\n\t\t\t\t\t<option value=\"KY\">Kentucky</option>\n\t\t\t\t\t<option value=\"LA\">Louisiana</option>\n\t\t\t\t\t<option value=\"ME\">Maine</option>\n\t\t\t\t\t<option value=\"MD\">Maryland</option>\n\t\t\t\t\t<option value=\"MA\">Massachusetts</option>\n\t\t\t\t\t<option value=\"MI\">Michigan</option>\n\t\t\t\t\t<option value=\"MN\">Minnesota</option>\n\t\t\t\t\t<option value=\"MS\">Mississippi</option>\n\t\t\t\t\t<option value=\"MO\">Missouri</option>\n\t\t\t\t\t<option value=\"MT\">Montana</option>\n\t\t\t\t\t<option value=\"NE\">Nebraska</option>\n\t\t\t\t\t<option value=\"NV\">Nevada</option>\n\t\t\t\t\t<option value=\"NH\">New Hampshire</option>\n\t\t\t\t\t<option value=\"NJ\">New Jersey</option>\n\t\t\t\t\t<option value=\"NM\">New Mexico</option>\n\t\t\t\t\t<option value=\"NY\">New York</option>\n\t\t\t\t\t<option value=\"NC\">North Carolina</option>\n\t\t\t\t\t<option value=\"ND\">North Dakota</option>\n\t\t\t\t\t<option value=\"OH\">Ohio</option>\n\t\t\t\t\t<option value=\"OK\">Oklahoma</option>\n\t\t\t\t\t<option value=\"OR\">Oregon</option>\n\t\t\t\t\t<option value=\"PA\">Pennsylvania</option>\n\t\t\t\t\t<option value=\"RI\">Rhode Island</option>\n\t\t\t\t\t<option value=\"SC\">South Carolina</option>\n\t\t\t\t\t<option value=\"SD\">South Dakota</option>\n\t\t\t\t\t<option value=\"TN\">Tennessee</option>\n\t\t\t\t\t<option value=\"TX\">Texas</option>\n\t\t\t\t\t<option value=\"UT\">Utah</option>\n\t\t\t\t\t<option value=\"VT\">Vermont</option>\n\t\t\t\t\t<option value=\"VA\">Virginia</option>\n\t\t\t\t\t<option value=\"WA\">Washington</option>\n\t\t\t\t\t<option value=\"WV\">West Virginia</option>\n\t\t\t\t\t<option value=\"WI\">Wisconsin</option>\n\t\t\t\t\t<option value=\"WY\">Wyoming</option>\n\t\t\t\t</select>\n\t\t\t\t<input type='text' className='form-control' name='zip' onChange={SignUpActions.updateUser} value={this.state.zip} placeholder='Zip Code' required/>\n\t\t\t\t<input type='tel' className='form-control' name='phone' onChange={SignUpActions.updateUser} value={this.state.phone} placeholder='Phone Number' required/>\n\t\t\t\t<button type='submit' className='btn btn-primary'>Create Account</button>\n\t\t\t</form>\n\t\t)\n\t}\n}\n\nexport default SignUp","import React from 'react'\nimport Router from 'react-router'\nimport ReactDOM from 'react-dom'\nimport routes from './routes'\nimport createBrowserHistory from 'history/lib/createBrowserHistory'\n\nlet history = createBrowserHistory()\n\nReactDOM.render(<Router history={history}>{routes}</Router>, document.getElementById('app'))","import React from 'react'\nimport {Route} from 'react-router'\nimport AxiomSci from './components/AxiomSci'\nimport Home from './components/Home'\nimport SignUp from './components/SignUp'\nimport Login from './components/Login'\n\nexport default (\n\t<Route component={AxiomSci}>\n\t\t<Route path='/' component={Home} />\n\t\t<Route path='/signup' component={SignUp} />\n\t\t<Route path='/login' component={Login} />\n\t</Route>\n)","import React from 'react'\nimport LoginActions from '../actions/LoginActions'\nimport alt from '../alt'\n\nclass LoginStore\n{\n\tconstructor()\n\t{\n\t\tthis.bindActions(LoginActions)\n\t\tthis.email = ''\n\t\tthis.password = ''\n\t}\n\n\tonUpdateUser(e)\n\t{\n\t\tthis[e.target.name] = e.target.value\n\t}\n}\n\nexport default alt.createStore(LoginStore)","import alt from '../alt'\nimport NavbarActions from '../actions/NavbarActions'\n\nclass NavbarStore\n{\n\tconstructor()\n\t{\n\t\tthis.bindActions(NavbarActions)\n\t}\n}\n\nexport default alt.createStore(NavbarStore)","import React from 'react'\nimport SignUpActions from '../actions/SignUpActions'\nimport alt from '../alt'\n\nclass SignUpStore\n{\n\tconstructor()\n\t{\n\t\tthis.bindActions(SignUpActions)\n\t\tthis.email = ''\n\t\tthis.fname = ''\n\t\tthis.lname = ''\n\t\tthis.password = ''\n\t\tthis.address = ''\n\t\tthis.city = ''\n\t\tthis.st = ''\n\t\tthis.zip = ''\n\t\tthis.phone = ''\n\t}\n\n\tonUpdateUser(e)\n\t{\n\t\tthis[e.target.name] = e.target.value\n\t}\n}\n\nexport default alt.createStore(SignUpStore)","var pSlice = Array.prototype.slice;\nvar objectKeys = require('./lib/keys.js');\nvar isArguments = require('./lib/is_arguments.js');\n\nvar deepEqual = module.exports = function (actual, expected, opts) {\n  if (!opts) opts = {};\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {\n    return opts.strict ? actual === expected : actual == expected;\n\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected, opts);\n  }\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isBuffer (x) {\n  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;\n  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {\n    return false;\n  }\n  if (x.length > 0 && typeof x[0] !== 'number') return false;\n  return true;\n}\n\nfunction objEquiv(a, b, opts) {\n  var i, key;\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I've managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return deepEqual(a, b, opts);\n  }\n  if (isBuffer(a)) {\n    if (!isBuffer(b)) {\n      return false;\n    }\n    if (a.length !== b.length) return false;\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n  try {\n    var ka = objectKeys(a),\n        kb = objectKeys(b);\n  } catch (e) {//happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!deepEqual(a[key], b[key], opts)) return false;\n  }\n  return typeof a === typeof b;\n}\n","var supportsArgumentsClass = (function(){\n  return Object.prototype.toString.call(arguments)\n})() == '[object Arguments]';\n\nexports = module.exports = supportsArgumentsClass ? supported : unsupported;\n\nexports.supported = supported;\nfunction supported(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n};\n\nexports.unsupported = unsupported;\nfunction unsupported(object){\n  return object &&\n    typeof object == 'object' &&\n    typeof object.length == 'number' &&\n    Object.prototype.hasOwnProperty.call(object, 'callee') &&\n    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||\n    false;\n};\n","exports = module.exports = typeof Object.keys === 'function'\n  ? Object.keys : shim;\n\nexports.shim = shim;\nfunction shim (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n}\n","/**\n * Indicates that navigation was caused by a call to history.push.\n */\n'use strict';\n\nexports.__esModule = true;\nvar PUSH = 'PUSH';\n\nexports.PUSH = PUSH;\n/**\n * Indicates that navigation was caused by a call to history.replace.\n */\nvar REPLACE = 'REPLACE';\n\nexports.REPLACE = REPLACE;\n/**\n * Indicates that navigation was caused by some other action such\n * as using a browser's back/forward buttons and/or manually manipulating\n * the URL in a browser's location bar. This is the default.\n *\n * See https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onpopstate\n * for more information.\n */\nvar POP = 'POP';\n\nexports.POP = POP;\nexports['default'] = {\n  PUSH: PUSH,\n  REPLACE: REPLACE,\n  POP: POP\n};","\"use strict\";\n\nexports.__esModule = true;\nexports.loopAsync = loopAsync;\n\nfunction loopAsync(turns, work, callback) {\n  var currentTurn = 0;\n  var isDone = false;\n\n  function done() {\n    isDone = true;\n    callback.apply(this, arguments);\n  }\n\n  function next() {\n    if (isDone) return;\n\n    if (currentTurn < turns) {\n      work.call(this, currentTurn++, next, done);\n    } else {\n      done.apply(this, arguments);\n    }\n  }\n\n  next();\n}","/*eslint-disable no-empty */\n'use strict';\n\nexports.__esModule = true;\nexports.saveState = saveState;\nexports.readState = readState;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _warning = require('warning');\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nvar KeyPrefix = '@@History/';\nvar QuotaExceededError = 'QuotaExceededError';\nvar SecurityError = 'SecurityError';\n\nfunction createKey(key) {\n  return KeyPrefix + key;\n}\n\nfunction saveState(key, state) {\n  try {\n    window.sessionStorage.setItem(createKey(key), JSON.stringify(state));\n  } catch (error) {\n    if (error.name === SecurityError) {\n      // Blocking cookies in Chrome/Firefox/Safari throws SecurityError on any\n      // attempt to access window.sessionStorage.\n      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] Unable to save state; sessionStorage is not available due to security settings') : undefined;\n\n      return;\n    }\n\n    if (error.name === QuotaExceededError && window.sessionStorage.length === 0) {\n      // Safari \"private mode\" throws QuotaExceededError.\n      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] Unable to save state; sessionStorage is not available in Safari private mode') : undefined;\n\n      return;\n    }\n\n    throw error;\n  }\n}\n\nfunction readState(key) {\n  var json = undefined;\n  try {\n    json = window.sessionStorage.getItem(createKey(key));\n  } catch (error) {\n    if (error.name === SecurityError) {\n      // Blocking cookies in Chrome/Firefox/Safari throws SecurityError on any\n      // attempt to access window.sessionStorage.\n      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] Unable to read state; sessionStorage is not available due to security settings') : undefined;\n\n      return null;\n    }\n  }\n\n  if (json) {\n    try {\n      return JSON.parse(json);\n    } catch (error) {\n      // Ignore invalid JSON.\n    }\n  }\n\n  return null;\n}","'use strict';\n\nexports.__esModule = true;\nexports.addEventListener = addEventListener;\nexports.removeEventListener = removeEventListener;\nexports.getHashPath = getHashPath;\nexports.replaceHashPath = replaceHashPath;\nexports.getWindowPath = getWindowPath;\nexports.go = go;\nexports.getUserConfirmation = getUserConfirmation;\nexports.supportsHistory = supportsHistory;\nexports.supportsGoWithoutReloadUsingHash = supportsGoWithoutReloadUsingHash;\n\nfunction addEventListener(node, event, listener) {\n  if (node.addEventListener) {\n    node.addEventListener(event, listener, false);\n  } else {\n    node.attachEvent('on' + event, listener);\n  }\n}\n\nfunction removeEventListener(node, event, listener) {\n  if (node.removeEventListener) {\n    node.removeEventListener(event, listener, false);\n  } else {\n    node.detachEvent('on' + event, listener);\n  }\n}\n\nfunction getHashPath() {\n  // We can't use window.location.hash here because it's not\n  // consistent across browsers - Firefox will pre-decode it!\n  return window.location.href.split('#')[1] || '';\n}\n\nfunction replaceHashPath(path) {\n  window.location.replace(window.location.pathname + window.location.search + '#' + path);\n}\n\nfunction getWindowPath() {\n  return window.location.pathname + window.location.search + window.location.hash;\n}\n\nfunction go(n) {\n  if (n) window.history.go(n);\n}\n\nfunction getUserConfirmation(message, callback) {\n  callback(window.confirm(message));\n}\n\n/**\n * Returns true if the HTML5 history API is supported. Taken from Modernizr.\n *\n * https://github.com/Modernizr/Modernizr/blob/master/LICENSE\n * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js\n * changed to avoid false negatives for Windows Phones: https://github.com/rackt/react-router/issues/586\n */\n\nfunction supportsHistory() {\n  var ua = navigator.userAgent;\n  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) {\n    return false;\n  }\n  // FIXME: Work around our browser history not working correctly on Chrome\n  // iOS: https://github.com/rackt/react-router/issues/2565\n  if (ua.indexOf('CriOS') !== -1) {\n    return false;\n  }\n  return window.history && 'pushState' in window.history;\n}\n\n/**\n * Returns false if using go(n) with hash history causes a full page reload.\n */\n\nfunction supportsGoWithoutReloadUsingHash() {\n  var ua = navigator.userAgent;\n  return ua.indexOf('Firefox') === -1;\n}","'use strict';\n\nexports.__esModule = true;\nvar canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\nexports.canUseDOM = canUseDOM;","'use strict';\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _invariant = require('invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nvar _Actions = require('./Actions');\n\nvar _ExecutionEnvironment = require('./ExecutionEnvironment');\n\nvar _DOMUtils = require('./DOMUtils');\n\nvar _DOMStateStorage = require('./DOMStateStorage');\n\nvar _createDOMHistory = require('./createDOMHistory');\n\nvar _createDOMHistory2 = _interopRequireDefault(_createDOMHistory);\n\nvar _parsePath = require('./parsePath');\n\nvar _parsePath2 = _interopRequireDefault(_parsePath);\n\n/**\n * Creates and returns a history object that uses HTML5's history API\n * (pushState, replaceState, and the popstate event) to manage history.\n * This is the recommended method of managing history in browsers because\n * it provides the cleanest URLs.\n *\n * Note: In browsers that do not support the HTML5 history API full\n * page reloads will be used to preserve URLs.\n */\nfunction createBrowserHistory() {\n  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n  !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Browser history needs a DOM') : _invariant2['default'](false) : undefined;\n\n  var forceRefresh = options.forceRefresh;\n\n  var isSupported = _DOMUtils.supportsHistory();\n  var useRefresh = !isSupported || forceRefresh;\n\n  function getCurrentLocation(historyState) {\n    historyState = historyState || window.history.state || {};\n\n    var path = _DOMUtils.getWindowPath();\n    var _historyState = historyState;\n    var key = _historyState.key;\n\n    var state = undefined;\n    if (key) {\n      state = _DOMStateStorage.readState(key);\n    } else {\n      state = null;\n      key = history.createKey();\n\n      if (isSupported) window.history.replaceState(_extends({}, historyState, { key: key }), null, path);\n    }\n\n    var location = _parsePath2['default'](path);\n\n    return history.createLocation(_extends({}, location, { state: state }), undefined, key);\n  }\n\n  function startPopStateListener(_ref) {\n    var transitionTo = _ref.transitionTo;\n\n    function popStateListener(event) {\n      if (event.state === undefined) return; // Ignore extraneous popstate events in WebKit.\n\n      transitionTo(getCurrentLocation(event.state));\n    }\n\n    _DOMUtils.addEventListener(window, 'popstate', popStateListener);\n\n    return function () {\n      _DOMUtils.removeEventListener(window, 'popstate', popStateListener);\n    };\n  }\n\n  function finishTransition(location) {\n    var basename = location.basename;\n    var pathname = location.pathname;\n    var search = location.search;\n    var hash = location.hash;\n    var state = location.state;\n    var action = location.action;\n    var key = location.key;\n\n    if (action === _Actions.POP) return; // Nothing to do.\n\n    _DOMStateStorage.saveState(key, state);\n\n    var path = (basename || '') + pathname + search + hash;\n    var historyState = {\n      key: key\n    };\n\n    if (action === _Actions.PUSH) {\n      if (useRefresh) {\n        window.location.href = path;\n        return false; // Prevent location update.\n      } else {\n          window.history.pushState(historyState, null, path);\n        }\n    } else {\n      // REPLACE\n      if (useRefresh) {\n        window.location.replace(path);\n        return false; // Prevent location update.\n      } else {\n          window.history.replaceState(historyState, null, path);\n        }\n    }\n  }\n\n  var history = _createDOMHistory2['default'](_extends({}, options, {\n    getCurrentLocation: getCurrentLocation,\n    finishTransition: finishTransition,\n    saveState: _DOMStateStorage.saveState\n  }));\n\n  var listenerCount = 0,\n      stopPopStateListener = undefined;\n\n  function listenBefore(listener) {\n    if (++listenerCount === 1) stopPopStateListener = startPopStateListener(history);\n\n    var unlisten = history.listenBefore(listener);\n\n    return function () {\n      unlisten();\n\n      if (--listenerCount === 0) stopPopStateListener();\n    };\n  }\n\n  function listen(listener) {\n    if (++listenerCount === 1) stopPopStateListener = startPopStateListener(history);\n\n    var unlisten = history.listen(listener);\n\n    return function () {\n      unlisten();\n\n      if (--listenerCount === 0) stopPopStateListener();\n    };\n  }\n\n  // deprecated\n  function registerTransitionHook(hook) {\n    if (++listenerCount === 1) stopPopStateListener = startPopStateListener(history);\n\n    history.registerTransitionHook(hook);\n  }\n\n  // deprecated\n  function unregisterTransitionHook(hook) {\n    history.unregisterTransitionHook(hook);\n\n    if (--listenerCount === 0) stopPopStateListener();\n  }\n\n  return _extends({}, history, {\n    listenBefore: listenBefore,\n    listen: listen,\n    registerTransitionHook: registerTransitionHook,\n    unregisterTransitionHook: unregisterTransitionHook\n  });\n}\n\nexports['default'] = createBrowserHistory;\nmodule.exports = exports['default'];","'use strict';\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _invariant = require('invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nvar _ExecutionEnvironment = require('./ExecutionEnvironment');\n\nvar _DOMUtils = require('./DOMUtils');\n\nvar _createHistory = require('./createHistory');\n\nvar _createHistory2 = _interopRequireDefault(_createHistory);\n\nfunction createDOMHistory(options) {\n  var history = _createHistory2['default'](_extends({\n    getUserConfirmation: _DOMUtils.getUserConfirmation\n  }, options, {\n    go: _DOMUtils.go\n  }));\n\n  function listen(listener) {\n    !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'DOM history needs a DOM') : _invariant2['default'](false) : undefined;\n\n    return history.listen(listener);\n  }\n\n  return _extends({}, history, {\n    listen: listen\n  });\n}\n\nexports['default'] = createDOMHistory;\nmodule.exports = exports['default'];","//import warning from 'warning'\n'use strict';\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _deepEqual = require('deep-equal');\n\nvar _deepEqual2 = _interopRequireDefault(_deepEqual);\n\nvar _AsyncUtils = require('./AsyncUtils');\n\nvar _Actions = require('./Actions');\n\nvar _createLocation2 = require('./createLocation');\n\nvar _createLocation3 = _interopRequireDefault(_createLocation2);\n\nvar _runTransitionHook = require('./runTransitionHook');\n\nvar _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);\n\nvar _parsePath = require('./parsePath');\n\nvar _parsePath2 = _interopRequireDefault(_parsePath);\n\nvar _deprecate = require('./deprecate');\n\nvar _deprecate2 = _interopRequireDefault(_deprecate);\n\nfunction createRandomKey(length) {\n  return Math.random().toString(36).substr(2, length);\n}\n\nfunction locationsAreEqual(a, b) {\n  return a.pathname === b.pathname && a.search === b.search &&\n  //a.action === b.action && // Different action !== location change.\n  a.key === b.key && _deepEqual2['default'](a.state, b.state);\n}\n\nvar DefaultKeyLength = 6;\n\nfunction createHistory() {\n  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n  var getCurrentLocation = options.getCurrentLocation;\n  var finishTransition = options.finishTransition;\n  var saveState = options.saveState;\n  var go = options.go;\n  var keyLength = options.keyLength;\n  var getUserConfirmation = options.getUserConfirmation;\n\n  if (typeof keyLength !== 'number') keyLength = DefaultKeyLength;\n\n  var transitionHooks = [];\n\n  function listenBefore(hook) {\n    transitionHooks.push(hook);\n\n    return function () {\n      transitionHooks = transitionHooks.filter(function (item) {\n        return item !== hook;\n      });\n    };\n  }\n\n  var allKeys = [];\n  var changeListeners = [];\n  var location = undefined;\n\n  function getCurrent() {\n    if (pendingLocation && pendingLocation.action === _Actions.POP) {\n      return allKeys.indexOf(pendingLocation.key);\n    } else if (location) {\n      return allKeys.indexOf(location.key);\n    } else {\n      return -1;\n    }\n  }\n\n  function updateLocation(newLocation) {\n    var current = getCurrent();\n\n    location = newLocation;\n\n    if (location.action === _Actions.PUSH) {\n      allKeys = [].concat(allKeys.slice(0, current + 1), [location.key]);\n    } else if (location.action === _Actions.REPLACE) {\n      allKeys[current] = location.key;\n    }\n\n    changeListeners.forEach(function (listener) {\n      listener(location);\n    });\n  }\n\n  function listen(listener) {\n    changeListeners.push(listener);\n\n    if (location) {\n      listener(location);\n    } else {\n      var _location = getCurrentLocation();\n      allKeys = [_location.key];\n      updateLocation(_location);\n    }\n\n    return function () {\n      changeListeners = changeListeners.filter(function (item) {\n        return item !== listener;\n      });\n    };\n  }\n\n  function confirmTransitionTo(location, callback) {\n    _AsyncUtils.loopAsync(transitionHooks.length, function (index, next, done) {\n      _runTransitionHook2['default'](transitionHooks[index], location, function (result) {\n        if (result != null) {\n          done(result);\n        } else {\n          next();\n        }\n      });\n    }, function (message) {\n      if (getUserConfirmation && typeof message === 'string') {\n        getUserConfirmation(message, function (ok) {\n          callback(ok !== false);\n        });\n      } else {\n        callback(message !== false);\n      }\n    });\n  }\n\n  var pendingLocation = undefined;\n\n  function transitionTo(nextLocation) {\n    if (location && locationsAreEqual(location, nextLocation)) return; // Nothing to do.\n\n    pendingLocation = nextLocation;\n\n    confirmTransitionTo(nextLocation, function (ok) {\n      if (pendingLocation !== nextLocation) return; // Transition was interrupted.\n\n      if (ok) {\n        // treat PUSH to current path like REPLACE to be consistent with browsers\n        if (nextLocation.action === _Actions.PUSH) {\n          var prevPath = createPath(location);\n          var nextPath = createPath(nextLocation);\n\n          if (nextPath === prevPath) nextLocation.action = _Actions.REPLACE;\n        }\n\n        if (finishTransition(nextLocation) !== false) updateLocation(nextLocation);\n      } else if (location && nextLocation.action === _Actions.POP) {\n        var prevIndex = allKeys.indexOf(location.key);\n        var nextIndex = allKeys.indexOf(nextLocation.key);\n\n        if (prevIndex !== -1 && nextIndex !== -1) go(prevIndex - nextIndex); // Restore the URL.\n      }\n    });\n  }\n\n  function push(location) {\n    transitionTo(createLocation(location, _Actions.PUSH, createKey()));\n  }\n\n  function replace(location) {\n    transitionTo(createLocation(location, _Actions.REPLACE, createKey()));\n  }\n\n  function goBack() {\n    go(-1);\n  }\n\n  function goForward() {\n    go(1);\n  }\n\n  function createKey() {\n    return createRandomKey(keyLength);\n  }\n\n  function createPath(location) {\n    if (location == null || typeof location === 'string') return location;\n\n    var pathname = location.pathname;\n    var search = location.search;\n    var hash = location.hash;\n\n    var result = pathname;\n\n    if (search) result += search;\n\n    if (hash) result += hash;\n\n    return result;\n  }\n\n  function createHref(location) {\n    return createPath(location);\n  }\n\n  function createLocation(location, action) {\n    var key = arguments.length <= 2 || arguments[2] === undefined ? createKey() : arguments[2];\n\n    if (typeof action === 'object') {\n      //warning(\n      //  false,\n      //  'The state (2nd) argument to history.createLocation is deprecated; use a ' +\n      //  'location descriptor instead'\n      //)\n\n      if (typeof location === 'string') location = _parsePath2['default'](location);\n\n      location = _extends({}, location, { state: action });\n\n      action = key;\n      key = arguments[3] || createKey();\n    }\n\n    return _createLocation3['default'](location, action, key);\n  }\n\n  // deprecated\n  function setState(state) {\n    if (location) {\n      updateLocationState(location, state);\n      updateLocation(location);\n    } else {\n      updateLocationState(getCurrentLocation(), state);\n    }\n  }\n\n  function updateLocationState(location, state) {\n    location.state = _extends({}, location.state, state);\n    saveState(location.key, location.state);\n  }\n\n  // deprecated\n  function registerTransitionHook(hook) {\n    if (transitionHooks.indexOf(hook) === -1) transitionHooks.push(hook);\n  }\n\n  // deprecated\n  function unregisterTransitionHook(hook) {\n    transitionHooks = transitionHooks.filter(function (item) {\n      return item !== hook;\n    });\n  }\n\n  // deprecated\n  function pushState(state, path) {\n    if (typeof path === 'string') path = _parsePath2['default'](path);\n\n    push(_extends({ state: state }, path));\n  }\n\n  // deprecated\n  function replaceState(state, path) {\n    if (typeof path === 'string') path = _parsePath2['default'](path);\n\n    replace(_extends({ state: state }, path));\n  }\n\n  return {\n    listenBefore: listenBefore,\n    listen: listen,\n    transitionTo: transitionTo,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    createKey: createKey,\n    createPath: createPath,\n    createHref: createHref,\n    createLocation: createLocation,\n\n    setState: _deprecate2['default'](setState, 'setState is deprecated; use location.key to save state instead'),\n    registerTransitionHook: _deprecate2['default'](registerTransitionHook, 'registerTransitionHook is deprecated; use listenBefore instead'),\n    unregisterTransitionHook: _deprecate2['default'](unregisterTransitionHook, 'unregisterTransitionHook is deprecated; use the callback returned from listenBefore instead'),\n    pushState: _deprecate2['default'](pushState, 'pushState is deprecated; use push instead'),\n    replaceState: _deprecate2['default'](replaceState, 'replaceState is deprecated; use replace instead')\n  };\n}\n\nexports['default'] = createHistory;\nmodule.exports = exports['default'];","//import warning from 'warning'\n'use strict';\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _Actions = require('./Actions');\n\nvar _parsePath = require('./parsePath');\n\nvar _parsePath2 = _interopRequireDefault(_parsePath);\n\nfunction createLocation() {\n  var location = arguments.length <= 0 || arguments[0] === undefined ? '/' : arguments[0];\n  var action = arguments.length <= 1 || arguments[1] === undefined ? _Actions.POP : arguments[1];\n  var key = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];\n\n  var _fourthArg = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];\n\n  if (typeof location === 'string') location = _parsePath2['default'](location);\n\n  if (typeof action === 'object') {\n    //warning(\n    //  false,\n    //  'The state (2nd) argument to createLocation is deprecated; use a ' +\n    //  'location descriptor instead'\n    //)\n\n    location = _extends({}, location, { state: action });\n\n    action = key || _Actions.POP;\n    key = _fourthArg;\n  }\n\n  var pathname = location.pathname || '/';\n  var search = location.search || '';\n  var hash = location.hash || '';\n  var state = location.state || null;\n\n  return {\n    pathname: pathname,\n    search: search,\n    hash: hash,\n    state: state,\n    action: action,\n    key: key\n  };\n}\n\nexports['default'] = createLocation;\nmodule.exports = exports['default'];","//import warning from 'warning'\n\n\"use strict\";\n\nexports.__esModule = true;\nfunction deprecate(fn) {\n  return fn;\n  //return function () {\n  //  warning(false, '[history] ' + message)\n  //  return fn.apply(this, arguments)\n  //}\n}\n\nexports[\"default\"] = deprecate;\nmodule.exports = exports[\"default\"];","\"use strict\";\n\nexports.__esModule = true;\nfunction extractPath(string) {\n  var match = string.match(/^https?:\\/\\/[^\\/]*/);\n\n  if (match == null) return string;\n\n  return string.substring(match[0].length);\n}\n\nexports[\"default\"] = extractPath;\nmodule.exports = exports[\"default\"];","'use strict';\n\nexports.__esModule = true;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _warning = require('warning');\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nvar _extractPath = require('./extractPath');\n\nvar _extractPath2 = _interopRequireDefault(_extractPath);\n\nfunction parsePath(path) {\n  var pathname = _extractPath2['default'](path);\n  var search = '';\n  var hash = '';\n\n  process.env.NODE_ENV !== 'production' ? _warning2['default'](path === pathname, 'A path must be pathname + search + hash only, not a fully qualified URL like \"%s\"', path) : undefined;\n\n  var hashIndex = pathname.indexOf('#');\n  if (hashIndex !== -1) {\n    hash = pathname.substring(hashIndex);\n    pathname = pathname.substring(0, hashIndex);\n  }\n\n  var searchIndex = pathname.indexOf('?');\n  if (searchIndex !== -1) {\n    search = pathname.substring(searchIndex);\n    pathname = pathname.substring(0, searchIndex);\n  }\n\n  if (pathname === '') pathname = '/';\n\n  return {\n    pathname: pathname,\n    search: search,\n    hash: hash\n  };\n}\n\nexports['default'] = parsePath;\nmodule.exports = exports['default'];","'use strict';\n\nexports.__esModule = true;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _warning = require('warning');\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nfunction runTransitionHook(hook, location, callback) {\n  var result = hook(location, callback);\n\n  if (hook.length < 2) {\n    // Assume the hook runs synchronously and automatically\n    // call the callback with the return value.\n    callback(result);\n  } else {\n    process.env.NODE_ENV !== 'production' ? _warning2['default'](result === undefined, 'You should not \"return\" in a transition hook with a callback argument; call the callback instead') : undefined;\n  }\n}\n\nexports['default'] = runTransitionHook;\nmodule.exports = exports['default'];","/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar invariant = function(condition, format, a, b, c, d, e, f) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  }\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error(\n        'Minified exception occurred; use the non-minified dev environment ' +\n        'for the full error message and additional helpful warnings.'\n      );\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(\n        format.replace(/%s/g, function() { return args[argIndex++]; })\n      );\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n};\n\nmodule.exports = invariant;\n","/*!\n * Lo-Dash v0.9.2 <http://lodash.com>\n * (c) 2012 John-David Dalton <http://allyoucanleet.com/>\n * Based on Underscore.js 1.4.2 <http://underscorejs.org>\n * (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.\n * Available under MIT license <http://lodash.com/license>\n */\n;(function(window, undefined) {\n\n  /** Detect free variable `exports` */\n  var freeExports = typeof exports == 'object' && exports;\n\n  /** Detect free variable `global` and use it as `window` */\n  var freeGlobal = typeof global == 'object' && global;\n  if (freeGlobal.global === freeGlobal) {\n    window = freeGlobal;\n  }\n\n  /** Used for array and object method references */\n  var arrayRef = [],\n      // avoid a Closure Compiler bug by creatively creating an object\n      objectRef = new function(){};\n\n  /** Used to generate unique IDs */\n  var idCounter = 0;\n\n  /** Used internally to indicate various things */\n  var indicatorObject = objectRef;\n\n  /** Used by `cachedContains` as the default size when optimizations are enabled for large arrays */\n  var largeArraySize = 30;\n\n  /** Used to restore the original `_` reference in `noConflict` */\n  var oldDash = window._;\n\n  /** Used to detect template delimiter values that require a with-statement */\n  var reComplexDelimiter = /[-?+=!~*%&^<>|{(\\/]|\\[\\D|\\b(?:delete|in|instanceof|new|typeof|void)\\b/;\n\n  /** Used to match HTML entities */\n  var reEscapedHtml = /&(?:amp|lt|gt|quot|#x27);/g;\n\n  /** Used to match empty string literals in compiled template source */\n  var reEmptyStringLeading = /\\b__p \\+= '';/g,\n      reEmptyStringMiddle = /\\b(__p \\+=) '' \\+/g,\n      reEmptyStringTrailing = /(__e\\(.*?\\)|\\b__t\\)) \\+\\n'';/g;\n\n  /** Used to match regexp flags from their coerced string values */\n  var reFlags = /\\w*$/;\n\n  /** Used to insert the data object variable into compiled template source */\n  var reInsertVariable = /(?:__e|__t = )\\(\\s*(?![\\d\\s\"']|this\\.)/g;\n\n  /** Used to detect if a method is native */\n  var reNative = RegExp('^' +\n    (objectRef.valueOf + '')\n      .replace(/[.*+?^=!:${}()|[\\]\\/\\\\]/g, '\\\\$&')\n      .replace(/valueOf|for [^\\]]+/g, '.+?') + '$'\n  );\n\n  /**\n   * Used to match ES6 template delimiters\n   * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-7.8.6\n   */\n  var reEsTemplate = /\\$\\{((?:(?=\\\\?)\\\\?[\\s\\S])*?)}/g;\n\n  /** Used to match \"interpolate\" template delimiters */\n  var reInterpolate = /<%=([\\s\\S]+?)%>/g;\n\n  /** Used to ensure capturing order of template delimiters */\n  var reNoMatch = /($^)/;\n\n  /** Used to match HTML characters */\n  var reUnescapedHtml = /[&<>\"']/g;\n\n  /** Used to match unescaped characters in compiled string literals */\n  var reUnescapedString = /['\\n\\r\\t\\u2028\\u2029\\\\]/g;\n\n  /** Used to fix the JScript [[DontEnum]] bug */\n  var shadowed = [\n    'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',\n    'toLocaleString', 'toString', 'valueOf'\n  ];\n\n  /** Used to make template sourceURLs easier to identify */\n  var templateCounter = 0;\n\n  /** Native method shortcuts */\n  var ceil = Math.ceil,\n      concat = arrayRef.concat,\n      floor = Math.floor,\n      getPrototypeOf = reNative.test(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,\n      hasOwnProperty = objectRef.hasOwnProperty,\n      push = arrayRef.push,\n      propertyIsEnumerable = objectRef.propertyIsEnumerable,\n      slice = arrayRef.slice,\n      toString = objectRef.toString;\n\n  /* Native method shortcuts for methods with the same name as other `lodash` methods */\n  var nativeBind = reNative.test(nativeBind = slice.bind) && nativeBind,\n      nativeIsArray = reNative.test(nativeIsArray = Array.isArray) && nativeIsArray,\n      nativeIsFinite = window.isFinite,\n      nativeIsNaN = window.isNaN,\n      nativeKeys = reNative.test(nativeKeys = Object.keys) && nativeKeys,\n      nativeMax = Math.max,\n      nativeMin = Math.min,\n      nativeRandom = Math.random;\n\n  /** `Object#toString` result shortcuts */\n  var argsClass = '[object Arguments]',\n      arrayClass = '[object Array]',\n      boolClass = '[object Boolean]',\n      dateClass = '[object Date]',\n      funcClass = '[object Function]',\n      numberClass = '[object Number]',\n      objectClass = '[object Object]',\n      regexpClass = '[object RegExp]',\n      stringClass = '[object String]';\n\n  /**\n   * Detect the JScript [[DontEnum]] bug:\n   *\n   * In IE < 9 an objects own properties, shadowing non-enumerable ones, are\n   * made non-enumerable as well.\n   */\n  var hasDontEnumBug;\n\n  /** Detect if own properties are iterated after inherited properties (IE < 9) */\n  var iteratesOwnLast;\n\n  /**\n   * Detect if `Array#shift` and `Array#splice` augment array-like objects\n   * incorrectly:\n   *\n   * Firefox < 10, IE compatibility mode, and IE < 9 have buggy Array `shift()`\n   * and `splice()` functions that fail to remove the last element, `value[0]`,\n   * of array-like objects even though the `length` property is set to `0`.\n   * The `shift()` method is buggy in IE 8 compatibility mode, while `splice()`\n   * is buggy regardless of mode in IE < 9 and buggy in compatibility mode in IE 9.\n   */\n  var hasObjectSpliceBug = (hasObjectSpliceBug = { '0': 1, 'length': 1 },\n    arrayRef.splice.call(hasObjectSpliceBug, 0, 1), hasObjectSpliceBug[0]);\n\n  /** Detect if an `arguments` object's indexes are non-enumerable (IE < 9) */\n  var noArgsEnum = true;\n\n  (function() {\n    var props = [];\n    function ctor() { this.x = 1; }\n    ctor.prototype = { 'valueOf': 1, 'y': 1 };\n    for (var prop in new ctor) { props.push(prop); }\n    for (prop in arguments) { noArgsEnum = !prop; }\n\n    hasDontEnumBug = !/valueOf/.test(props);\n    iteratesOwnLast = props[0] != 'x';\n  }(1));\n\n  /** Detect if an `arguments` object's [[Class]] is unresolvable (Firefox < 4, IE < 9) */\n  var noArgsClass = !isArguments(arguments);\n\n  /** Detect if `Array#slice` cannot be used to convert strings to arrays (Opera < 10.52) */\n  var noArraySliceOnStrings = slice.call('x')[0] != 'x';\n\n  /**\n   * Detect lack of support for accessing string characters by index:\n   *\n   * IE < 8 can't access characters by index and IE 8 can only access\n   * characters by index on string literals.\n   */\n  var noCharByIndex = ('x'[0] + Object('x')[0]) != 'xx';\n\n  /**\n   * Detect if a node's [[Class]] is unresolvable (IE < 9)\n   * and that the JS engine won't error when attempting to coerce an object to\n   * a string without a `toString` property value of `typeof` \"function\".\n   */\n  try {\n    var noNodeClass = ({ 'toString': 0 } + '', toString.call(window.document || 0) == objectClass);\n  } catch(e) { }\n\n  /* Detect if `Function#bind` exists and is inferred to be fast (all but V8) */\n  var isBindFast = nativeBind && /\\n|Opera/.test(nativeBind + toString.call(window.opera));\n\n  /* Detect if `Object.keys` exists and is inferred to be fast (IE, Opera, V8) */\n  var isKeysFast = nativeKeys && /^.+$|true/.test(nativeKeys + !!window.attachEvent);\n\n  /**\n   * Detect if sourceURL syntax is usable without erroring:\n   *\n   * The JS engine in Adobe products, like InDesign, will throw a syntax error\n   * when it encounters a single line comment beginning with the `@` symbol.\n   *\n   * The JS engine in Narwhal will generate the function `function anonymous(){//}`\n   * and throw a syntax error.\n   *\n   * Avoid comments beginning `@` symbols in IE because they are part of its\n   * non-standard conditional compilation support.\n   * http://msdn.microsoft.com/en-us/library/121hztk3(v=vs.94).aspx\n   */\n  try {\n    var useSourceURL = (Function('//@')(), !window.attachEvent);\n  } catch(e) { }\n\n  /** Used to identify object classifications that `_.clone` supports */\n  var cloneableClasses = {};\n  cloneableClasses[argsClass] = cloneableClasses[funcClass] = false;\n  cloneableClasses[arrayClass] = cloneableClasses[boolClass] = cloneableClasses[dateClass] =\n  cloneableClasses[numberClass] = cloneableClasses[objectClass] = cloneableClasses[regexpClass] =\n  cloneableClasses[stringClass] = true;\n\n  /** Used to determine if values are of the language type Object */\n  var objectTypes = {\n    'boolean': false,\n    'function': true,\n    'object': true,\n    'number': false,\n    'string': false,\n    'undefined': false\n  };\n\n  /** Used to escape characters for inclusion in compiled string literals */\n  var stringEscapes = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    '\\n': 'n',\n    '\\r': 'r',\n    '\\t': 't',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * The `lodash` function.\n   *\n   * @name _\n   * @constructor\n   * @category Chaining\n   * @param {Mixed} value The value to wrap in a `lodash` instance.\n   * @returns {Object} Returns a `lodash` instance.\n   */\n  function lodash(value) {\n    // exit early if already wrapped\n    if (value && value.__wrapped__) {\n      return value;\n    }\n    // allow invoking `lodash` without the `new` operator\n    if (!(this instanceof lodash)) {\n      return new lodash(value);\n    }\n    this.__wrapped__ = value;\n  }\n\n  /**\n   * By default, the template delimiters used by Lo-Dash are similar to those in\n   * embedded Ruby (ERB). Change the following template settings to use alternative\n   * delimiters.\n   *\n   * @static\n   * @memberOf _\n   * @type Object\n   */\n  lodash.templateSettings = {\n\n    /**\n     * Used to detect `data` property values to be HTML-escaped.\n     *\n     * @static\n     * @memberOf _.templateSettings\n     * @type RegExp\n     */\n    'escape': /<%-([\\s\\S]+?)%>/g,\n\n    /**\n     * Used to detect code to be evaluated.\n     *\n     * @static\n     * @memberOf _.templateSettings\n     * @type RegExp\n     */\n    'evaluate': /<%([\\s\\S]+?)%>/g,\n\n    /**\n     * Used to detect `data` property values to inject.\n     *\n     * @static\n     * @memberOf _.templateSettings\n     * @type RegExp\n     */\n    'interpolate': reInterpolate,\n\n    /**\n     * Used to reference the data object in the template text.\n     *\n     * @static\n     * @memberOf _.templateSettings\n     * @type String\n     */\n    'variable': ''\n  };\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * The template used to create iterator functions.\n   *\n   * @private\n   * @param {Obect} data The data object used to populate the text.\n   * @returns {String} Returns the interpolated text.\n   */\n  var iteratorTemplate = template(\n    // conditional strict mode\n    '<% if (obj.useStrict) { %>\\'use strict\\';\\n<% } %>' +\n\n    // the `iteratee` may be reassigned by the `top` snippet\n    'var index, value, iteratee = <%= firstArg %>, ' +\n    // assign the `result` variable an initial value\n    'result = <%= firstArg %>;\\n' +\n    // exit early if the first argument is falsey\n    'if (!<%= firstArg %>) return result;\\n' +\n    // add code before the iteration branches\n    '<%= top %>;\\n' +\n\n    // array-like iteration:\n    '<% if (arrayLoop) { %>' +\n    'var length = iteratee.length; index = -1;\\n' +\n    'if (typeof length == \\'number\\') {' +\n\n    // add support for accessing string characters by index if needed\n    '  <% if (noCharByIndex) { %>\\n' +\n    '  if (isString(iteratee)) {\\n' +\n    '    iteratee = iteratee.split(\\'\\')\\n' +\n    '  }' +\n    '  <% } %>\\n' +\n\n    // iterate over the array-like value\n    '  while (++index < length) {\\n' +\n    '    value = iteratee[index];\\n' +\n    '    <%= arrayLoop %>\\n' +\n    '  }\\n' +\n    '}\\n' +\n    'else {' +\n\n    // object iteration:\n    // add support for iterating over `arguments` objects if needed\n    '  <%  } else if (noArgsEnum) { %>\\n' +\n    '  var length = iteratee.length; index = -1;\\n' +\n    '  if (length && isArguments(iteratee)) {\\n' +\n    '    while (++index < length) {\\n' +\n    '      value = iteratee[index += \\'\\'];\\n' +\n    '      <%= objectLoop %>\\n' +\n    '    }\\n' +\n    '  } else {' +\n    '  <% } %>' +\n\n    // Firefox < 3.6, Opera > 9.50 - Opera < 11.60, and Safari < 5.1\n    // (if the prototype or a property on the prototype has been set)\n    // incorrectly sets a function's `prototype` property [[Enumerable]]\n    // value to `true`. Because of this Lo-Dash standardizes on skipping\n    // the the `prototype` property of functions regardless of its\n    // [[Enumerable]] value.\n    '  <% if (!hasDontEnumBug) { %>\\n' +\n    '  var skipProto = typeof iteratee == \\'function\\' && \\n' +\n    '    propertyIsEnumerable.call(iteratee, \\'prototype\\');\\n' +\n    '  <% } %>' +\n\n    // iterate own properties using `Object.keys` if it's fast\n    '  <% if (isKeysFast && useHas) { %>\\n' +\n    '  var ownIndex = -1,\\n' +\n    '      ownProps = objectTypes[typeof iteratee] ? nativeKeys(iteratee) : [],\\n' +\n    '      length = ownProps.length;\\n\\n' +\n    '  while (++ownIndex < length) {\\n' +\n    '    index = ownProps[ownIndex];\\n' +\n    '    <% if (!hasDontEnumBug) { %>if (!(skipProto && index == \\'prototype\\')) {\\n  <% } %>' +\n    '    value = iteratee[index];\\n' +\n    '    <%= objectLoop %>\\n' +\n    '    <% if (!hasDontEnumBug) { %>}\\n<% } %>' +\n    '  }' +\n\n    // else using a for-in loop\n    '  <% } else { %>\\n' +\n    '  for (index in iteratee) {<%' +\n    '    if (!hasDontEnumBug || useHas) { %>\\n    if (<%' +\n    '      if (!hasDontEnumBug) { %>!(skipProto && index == \\'prototype\\')<% }' +\n    '      if (!hasDontEnumBug && useHas) { %> && <% }' +\n    '      if (useHas) { %>hasOwnProperty.call(iteratee, index)<% }' +\n    '    %>) {' +\n    '    <% } %>\\n' +\n    '    value = iteratee[index];\\n' +\n    '    <%= objectLoop %>;' +\n    '    <% if (!hasDontEnumBug || useHas) { %>\\n    }<% } %>\\n' +\n    '  }' +\n    '  <% } %>' +\n\n    // Because IE < 9 can't set the `[[Enumerable]]` attribute of an\n    // existing property and the `constructor` property of a prototype\n    // defaults to non-enumerable, Lo-Dash skips the `constructor`\n    // property when it infers it's iterating over a `prototype` object.\n    '  <% if (hasDontEnumBug) { %>\\n\\n' +\n    '  var ctor = iteratee.constructor;\\n' +\n    '    <% for (var k = 0; k < 7; k++) { %>\\n' +\n    '  index = \\'<%= shadowed[k] %>\\';\\n' +\n    '  if (<%' +\n    '      if (shadowed[k] == \\'constructor\\') {' +\n    '        %>!(ctor && ctor.prototype === iteratee) && <%' +\n    '      } %>hasOwnProperty.call(iteratee, index)) {\\n' +\n    '    value = iteratee[index];\\n' +\n    '    <%= objectLoop %>\\n' +\n    '  }' +\n    '    <% } %>' +\n    '  <% } %>' +\n    '  <% if (arrayLoop || noArgsEnum) { %>\\n}<% } %>\\n' +\n\n    // add code to the bottom of the iteration function\n    '<%= bottom %>;\\n' +\n    // finally, return the `result`\n    'return result'\n  );\n\n  /**\n   * Reusable iterator options shared by `forEach`, `forIn`, and `forOwn`.\n   */\n  var forEachIteratorOptions = {\n    'args': 'collection, callback, thisArg',\n    'top': 'callback = createCallback(callback, thisArg)',\n    'arrayLoop': 'if (callback(value, index, collection) === false) return result',\n    'objectLoop': 'if (callback(value, index, collection) === false) return result'\n  };\n\n  /** Reusable iterator options for `defaults`, and `extend` */\n  var extendIteratorOptions = {\n    'useHas': false,\n    'args': 'object',\n    'top':\n      'for (var argsIndex = 1, argsLength = arguments.length; argsIndex < argsLength; argsIndex++) {\\n' +\n      '  if (iteratee = arguments[argsIndex]) {',\n    'objectLoop': 'result[index] = value',\n    'bottom': '  }\\n}'\n  };\n\n  /** Reusable iterator options for `forIn` and `forOwn` */\n  var forOwnIteratorOptions = {\n    'arrayLoop': null\n  };\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Creates a function optimized to search large arrays for a given `value`,\n   * starting at `fromIndex`, using strict equality for comparisons, i.e. `===`.\n   *\n   * @private\n   * @param {Array} array The array to search.\n   * @param {Mixed} value The value to search for.\n   * @param {Number} [fromIndex=0] The index to search from.\n   * @param {Number} [largeSize=30] The length at which an array is considered large.\n   * @returns {Boolean} Returns `true` if `value` is found, else `false`.\n   */\n  function cachedContains(array, fromIndex, largeSize) {\n    fromIndex || (fromIndex = 0);\n\n    var length = array.length,\n        isLarge = (length - fromIndex) >= (largeSize || largeArraySize);\n\n    if (isLarge) {\n      var cache = {},\n          index = fromIndex - 1;\n\n      while (++index < length) {\n        // manually coerce `value` to a string because `hasOwnProperty`, in some\n        // older versions of Firefox, coerces objects incorrectly\n        var key = array[index] + '';\n        (hasOwnProperty.call(cache, key) ? cache[key] : (cache[key] = [])).push(array[index]);\n      }\n    }\n    return function(value) {\n      if (isLarge) {\n        var key = value + '';\n        return hasOwnProperty.call(cache, key) && indexOf(cache[key], value) > -1;\n      }\n      return indexOf(array, value, fromIndex) > -1;\n    }\n  }\n\n  /**\n   * Used by `_.max` and `_.min` as the default `callback` when a given\n   * `collection` is a string value.\n   *\n   * @private\n   * @param {String} value The character to inspect.\n   * @returns {Number} Returns the code unit of given character.\n   */\n  function charAtCallback(value) {\n    return value.charCodeAt(0);\n  }\n\n  /**\n   * Used by `sortBy` to compare transformed `collection` values, stable sorting\n   * them in ascending order.\n   *\n   * @private\n   * @param {Object} a The object to compare to `b`.\n   * @param {Object} b The object to compare to `a`.\n   * @returns {Number} Returns the sort order indicator of `1` or `-1`.\n   */\n  function compareAscending(a, b) {\n    var ai = a.index,\n        bi = b.index;\n\n    a = a.criteria;\n    b = b.criteria;\n\n    // ensure a stable sort in V8 and other engines\n    // http://code.google.com/p/v8/issues/detail?id=90\n    if (a !== b) {\n      if (a > b || a === undefined) {\n        return 1;\n      }\n      if (a < b || b === undefined) {\n        return -1;\n      }\n    }\n    return ai < bi ? -1 : 1;\n  }\n\n  /**\n   * Creates a function that, when called, invokes `func` with the `this`\n   * binding of `thisArg` and prepends any `partailArgs` to the arguments passed\n   * to the bound function.\n   *\n   * @private\n   * @param {Function|String} func The function to bind or the method name.\n   * @param {Mixed} [thisArg] The `this` binding of `func`.\n   * @param {Array} partialArgs An array of arguments to be partially applied.\n   * @returns {Function} Returns the new bound function.\n   */\n  function createBound(func, thisArg, partialArgs) {\n    var isFunc = isFunction(func),\n        isPartial = !partialArgs,\n        methodName = func;\n\n    // juggle arguments\n    if (isPartial) {\n      partialArgs = thisArg;\n    }\n\n    function bound() {\n      // `Function#bind` spec\n      // http://es5.github.com/#x15.3.4.5\n      var args = arguments,\n          thisBinding = isPartial ? this : thisArg;\n\n      if (!isFunc) {\n        func = thisArg[methodName];\n      }\n      if (partialArgs.length) {\n        args = args.length\n          ? partialArgs.concat(slice.call(args))\n          : partialArgs;\n      }\n      if (this instanceof bound) {\n        // get `func` instance if `bound` is invoked in a `new` expression\n        noop.prototype = func.prototype;\n        thisBinding = new noop;\n\n        // mimic the constructor's `return` behavior\n        // http://es5.github.com/#x13.2.2\n        var result = func.apply(thisBinding, args);\n        return isObject(result)\n          ? result\n          : thisBinding\n      }\n      return func.apply(thisBinding, args);\n    }\n    return bound;\n  }\n\n  /**\n   * Produces an iteration callback bound to an optional `thisArg`. If `func` is\n   * a property name, the callback will return the property value for a given element.\n   *\n   * @private\n   * @param {Function|String} [func=identity|property] The function called per\n   * iteration or property name to query.\n   * @param {Mixed} [thisArg] The `this` binding of `callback`.\n   * @returns {Function} Returns a callback function.\n   */\n  function createCallback(func, thisArg) {\n    if (!func) {\n      return identity;\n    }\n    if (typeof func != 'function') {\n      return function(object) {\n        return object[func];\n      };\n    }\n    if (thisArg !== undefined) {\n      return function(value, index, object) {\n        return func.call(thisArg, value, index, object);\n      };\n    }\n    return func;\n  }\n\n  /**\n   * Creates compiled iteration functions.\n   *\n   * @private\n   * @param {Object} [options1, options2, ...] The compile options object(s).\n   *  useHas - A boolean to specify using `hasOwnProperty` checks in the object loop.\n   *  args - A string of comma separated arguments the iteration function will accept.\n   *  top - A string of code to execute before the iteration branches.\n   *  arrayLoop - A string of code to execute in the array loop.\n   *  objectLoop - A string of code to execute in the object loop.\n   *  bottom - A string of code to execute after the iteration branches.\n   *\n   * @returns {Function} Returns the compiled function.\n   */\n  function createIterator() {\n    var data = {\n      'arrayLoop': '',\n      'bottom': '',\n      'hasDontEnumBug': hasDontEnumBug,\n      'isKeysFast': isKeysFast,\n      'objectLoop': '',\n      'noArgsEnum': noArgsEnum,\n      'noCharByIndex': noCharByIndex,\n      'shadowed': shadowed,\n      'top': '',\n      'useHas': true\n    };\n\n    // merge options into a template data object\n    for (var object, index = 0; object = arguments[index]; index++) {\n      for (var key in object) {\n        data[key] = object[key];\n      }\n    }\n    var args = data.args;\n    data.firstArg = /^[^,]+/.exec(args)[0];\n\n    // create the function factory\n    var factory = Function(\n        'createCallback, hasOwnProperty, isArguments, isString, objectTypes, ' +\n        'nativeKeys, propertyIsEnumerable',\n      'return function(' + args + ') {\\n' + iteratorTemplate(data) + '\\n}'\n    );\n    // return the compiled function\n    return factory(\n      createCallback, hasOwnProperty, isArguments, isString, objectTypes,\n      nativeKeys, propertyIsEnumerable\n    );\n  }\n\n  /**\n   * Used by `template` to escape characters for inclusion in compiled\n   * string literals.\n   *\n   * @private\n   * @param {String} match The matched character to escape.\n   * @returns {String} Returns the escaped character.\n   */\n  function escapeStringChar(match) {\n    return '\\\\' + stringEscapes[match];\n  }\n\n  /**\n   * Used by `escape` to convert characters to HTML entities.\n   *\n   * @private\n   * @param {String} match The matched character to escape.\n   * @returns {String} Returns the escaped character.\n   */\n  function escapeHtmlChar(match) {\n    return htmlEscapes[match];\n  }\n\n  /**\n   * A no-operation function.\n   *\n   * @private\n   */\n  function noop() {\n    // no operation performed\n  }\n\n  /**\n   * Used by `unescape` to convert HTML entities to characters.\n   *\n   * @private\n   * @param {String} match The matched character to unescape.\n   * @returns {String} Returns the unescaped character.\n   */\n  function unescapeHtmlChar(match) {\n    return htmlUnescapes[match];\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Checks if `value` is an `arguments` object.\n   *\n   * @static\n   * @memberOf _\n   * @category Objects\n   * @param {Mixed} value The value to check.\n   * @returns {Boolean} Returns `true` if the `value` is an `arguments` object, else `false`.\n   * @example\n   *\n   * (function() { return _.isArguments(arguments); })(1, 2, 3);\n   * // => true\n   *\n   * _.isArguments([1, 2, 3]);\n   * // => false\n   */\n  function isArguments(value) {\n    return toString.call(value) == argsClass;\n  }\n  // fallback for browsers that can't detect `arguments` objects by [[Class]]\n  if (noArgsClass) {\n    isArguments = function(value) {\n      return value ? hasOwnProperty.call(value, 'callee') : false;\n    };\n  }\n\n  /**\n   * Iterates over `object`'s own and inherited enumerable properties, executing\n   * the `callback` for each property. The `callback` is bound to `thisArg` and\n   * invoked with three arguments; (value, key, object). Callbacks may exit iteration\n   * early by explicitly returning `false`.\n   *\n   * @static\n   * @memberOf _\n   * @category Objects\n   * @param {Object} object The object to iterate over.\n   * @param {Function} callback The function called per iteration.\n   * @param {Mixed} [thisArg] The `this` binding of `callback`.\n   * @returns {Object} Returns `object`.\n   * @example\n   *\n   * function Dog(name) {\n   *   this.name = name;\n   * }\n   *\n   * Dog.prototype.bark = function() {\n   *   alert('Woof, woof!');\n   * };\n   *\n   * _.forIn(new Dog('Dagny'), function(value, key) {\n   *   alert(key);\n   * });\n   * // => alerts 'name' and 'bark' (order is not guaranteed)\n   */\n  var forIn = createIterator(forEachIteratorOptions, forOwnIteratorOptions, {\n    'useHas': false\n  });\n\n  /**\n   * Iterates over `object`'s own enumerable properties, executing the `callback`\n   * for each property. The `callback` is bound to `thisArg` and invoked with three\n   * arguments; (value, key, object). Callbacks may exit iteration early by explicitly\n   * returning `false`.\n   *\n   * @static\n   * @memberOf _\n   * @category Objects\n   * @param {Object} object The object to iterate over.\n   * @param {Function} callback The function called per iteration.\n   * @param {Mixed} [thisArg] The `this` binding of `callback`.\n   * @returns {Object} Returns `object`.\n   * @example\n   *\n   * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {\n   *   alert(key);\n   * });\n   * // => alerts '0', '1', and 'length' (order is not guaranteed)\n   */\n  var forOwn = createIterator(forEachIteratorOptions, forOwnIteratorOptions);\n\n  /**\n   * A fallback implementation of `isPlainObject` that checks if a given `value`\n   * is an object created by the `Object` constructor, assuming objects created\n   * by the `Object` constructor have no inherited enumerable properties and that\n   * there are no `Object.prototype` extensions.\n   *\n   * @private\n   * @param {Mixed} value The value to check.\n   * @returns {Boolean} Returns `true` if `value` is a plain object, else `false`.\n   */\n  function shimIsPlainObject(value) {\n    // avoid non-objects and false positives for `arguments` objects\n    var result = false;\n    if (!(value && typeof value == 'object') || isArguments(value)) {\n      return result;\n    }\n    // IE < 9 presents DOM nodes as `Object` objects except they have `toString`\n    // methods that are `typeof` \"string\" and still can coerce nodes to strings.\n    // Also check that the constructor is `Object` (i.e. `Object instanceof Object`)\n    var ctor = value.constructor;\n    if ((!noNodeClass || !(typeof value.toString != 'function' && typeof (value + '') == 'string')) &&\n        (!isFunction(ctor) || ctor instanceof ctor)) {\n      // IE < 9 iterates inherited properties before own properties. If the first\n      // iterated property is an object's own property then there are no inherited\n      // enumerable properties.\n      if (iteratesOwnLast) {\n        forIn(value, function(value, key, object) {\n          result = !hasOwnProperty.call(object, key);\n          return false;\n        });\n        return result === false;\n      }\n      // In most environments an object's own properties are iterated before\n      // its inherited properties. If the last iterated property is an object's\n      // own property then there are no inherited enumerable properties.\n      forIn(value, function(value, key) {\n        result = key;\n      });\n      return result === false || hasOwnProperty.call(value, result);\n    }\n    return result;\n  }\n\n  /**\n   * A fallback implementation of `Object.keys` that produces an array of the\n   * given object's own enumerable property names.\n   *\n   * @private\n   * @param {Object} object The object to inspect.\n   * @returns {Array} Returns a new array of property names.\n   */\n  function shimKeys(object) {\n    var result = [];\n    forOwn(object, function(value, key) {\n      result.push(key);\n    });\n    return result;\n  }\n\n  /**\n   * Used to convert characters to HTML entities:\n   *\n   * Though the `>` character is escaped for symmetry, characters like `>` and `/`\n   * don't require escaping in HTML and have no special meaning unless they're part\n   * of a tag or an unquoted attribute value.\n   * http://mathiasbynens.be/notes/ambiguous-ampersands (under \"semi-related fun fact\")\n   */\n  var htmlEscapes = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;'\n  };\n\n  /** Used to convert HTML entities to characters */\n  var htmlUnescapes = invert(htmlEscapes);\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Creates a clone of `value`. If `deep` is `true`, all nested objects will\n   * also be cloned otherwise they will be assigned by reference. Functions, DOM\n   * nodes, `arguments` objects, and objects created by constructors other than\n   * `Object` are **not** cloned.\n   *\n   * @static\n   * @memberOf _\n   * @category Objects\n   * @param {Mixed} value The value to clone.\n   * @param {Boolean} deep A flag to indicate a deep clone.\n   * @param- {Object} [guard] Internally used to allow this method to work with\n   *  others like `_.map` without using their callback `index` argument for `deep`.\n   * @param- {Array} [stackA=[]] Internally used to track traversed source objects.\n   * @param- {Array} [stackB=[]] Internally used to associate clones with their\n   *  source counterparts.\n   * @returns {Mixed} Returns the cloned `value`.\n   * @example\n   *\n   * var stooges = [\n   *   { 'name': 'moe', 'age': 40 },\n   *   { 'name': 'larry', 'age': 50 },\n   *   { 'name': 'curly', 'age': 60 }\n   * ];\n   *\n   * _.clone({ 'name': 'moe' });\n   * // => { 'name': 'moe' }\n   *\n   * var shallow = _.clone(stooges);\n   * shallow[0] === stooges[0];\n   * // => true\n   *\n   * var deep = _.clone(stooges, true);\n   * shallow[0] === stooges[0];\n   * // => false\n   */\n  function clone(value, deep, guard, stackA, stackB) {\n    if (value == null) {\n      return value;\n    }\n    if (guard) {\n      deep = false;\n    }\n    // inspect [[Class]]\n    var isObj = isObject(value);\n    if (isObj) {\n      // don't clone `arguments` objects, functions, or non-object Objects\n      var className = toString.call(value);\n      if (!cloneableClasses[className] || (noArgsClass && isArguments(value))) {\n        return value;\n      }\n      var isArr = className == arrayClass;\n      isObj = isArr || (className == objectClass ? isPlainObject(value) : isObj);\n    }\n    // shallow clone\n    if (!isObj || !deep) {\n      // don't clone functions\n      return isObj\n        ? (isArr ? slice.call(value) : extend({}, value))\n        : value;\n    }\n\n    var ctor = value.constructor;\n    switch (className) {\n      case boolClass:\n      case dateClass:\n        return new ctor(+value);\n\n      case numberClass:\n      case stringClass:\n        return new ctor(value);\n\n      case regexpClass:\n        return ctor(value.source, reFlags.exec(value));\n    }\n    // check for circular references and return corresponding clone\n    stackA || (stackA = []);\n    stackB || (stackB = []);\n\n    var length = stackA.length;\n    while (length--) {\n      if (stackA[length] == value) {\n        return stackB[length];\n      }\n    }\n    // init cloned object\n    var result = isArr ? ctor(value.length) : {};\n\n    // add the source value to the stack of traversed objects\n    // and associate it with its clone\n    stackA.push(value);\n    stackB.push(result);\n\n    // recursively populate clone (susceptible to call stack limits)\n    (isArr ? forEach : forOwn)(value, function(objValue, key) {\n      result[key] = clone(objValue, deep, null, stackA, stackB);\n    });\n\n    return result;\n  }\n\n  /**\n   * Assigns enumerable properties of the default object(s) to the `destination`\n   * object for all `destination` properties that resolve to `null`/`undefined`.\n   * Once a property is set, additional defaults of the same property will be\n   * ignored.\n   *\n   * @static\n   * @memberOf _\n   * @category Objects\n   * @param {Object} object The destination object.\n   * @param {Object} [default1, default2, ...] The default objects.\n   * @returns {Object} Returns the destination object.\n   * @example\n   *\n   * var iceCream = { 'flavor': 'chocolate' };\n   * _.defaults(iceCream, { 'flavor': 'vanilla', 'sprinkles': 'rainbow' });\n   * // => { 'flavor': 'chocolate', 'sprinkles': 'rainbow' }\n   */\n  var defaults = createIterator(extendIteratorOptions, {\n    'objectLoop': 'if (result[index] == null) ' + extendIteratorOptions.objectLoop\n  });\n\n  /**\n   * Assigns enumerable properties of the source object(s) to the `destination`\n   * object. Subsequent sources will overwrite propery assignments of previous\n   * sources.\n   *\n   * @static\n   * @memberOf _\n   * @category Objects\n   * @param {Object} object The destination object.\n   * @param {Object} [source1, source2, ...] The source objects.\n   * @returns {Object} Returns the destination object.\n   * @example\n   *\n   * _.extend({ 'name': 'moe' }, { 'age': 40 });\n   * // => { 'name': 'moe', 'age': 40 }\n   */\n  var extend = createIterator(extendIteratorOptions);\n\n  /**\n   * Creates a sorted array of all enumerable properties, own and inherited,\n   * of `object` that have function values.\n   *\n   * @static\n   * @memberOf _\n   * @alias methods\n   * @category Objects\n   * @param {Object} object The object to inspect.\n   * @returns {Array} Returns a new array of property names that have function values.\n   * @example\n   *\n   * _.functions(_);\n   * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]\n   */\n  function functions(object) {\n    var result = [];\n    forIn(object, function(value, key) {\n      if (isFunction(value)) {\n        result.push(key);\n      }\n    });\n    return result.sort();\n  }\n\n  /**\n   * Checks if the specified object `property` exists and is a direct property,\n   * instead of an inherited property.\n   *\n   * @static\n   * @memberOf _\n   * @category Objects\n   * @param {Object} object The object to check.\n   * @param {String} property The property to check for.\n   * @returns {Boolean} Returns `true` if key is a direct property, else `false`.\n   * @example\n   *\n   * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');\n   * // => true\n   */\n  function has(object, property) {\n    return object ? hasOwnProperty.call(object, property) : false;\n  }\n\n  /**\n   * Creates an object composed of the inverted keys and values of the given `object`.\n   *\n   * @static\n   * @memberOf _\n   * @category Objects\n   * @param {Object} object The object to invert.\n   * @returns {Object} Returns the created inverted object.\n   * @example\n   *\n   *  _.invert({ 'first': 'Moe', 'second': 'Larry', 'third': 'Curly' });\n   * // => { 'Moe': 'first', 'Larry': 'second', 'Curly': 'third' } (order is not guaranteed)\n   */\n  function invert(object) {\n    var result = {};\n    forOwn(object, function(value, key) {\n      result[value] = key;\n    });\n    return result;\n  }\n\n  /**\n   * Checks if `value` is an array.\n   *\n   * @static\n   * @memberOf _\n   * @category Objects\n   * @param {Mixed} value The value to check.\n   * @returns {Boolean} Returns `true` if the `value` is an array, else `false`.\n   * @example\n   *\n   * (function() { return _.isArray(arguments); })();\n   * // => false\n   *\n   * _.isArray([1, 2, 3]);\n   * // => true\n   */\n  var isArray = nativeIsArray || function(value) {\n    return toString.call(value) == arrayClass;\n  };\n\n  /**\n   * Checks if `value` is a boolean (`true` or `false`) value.\n   *\n   * @static\n   * @memberOf _\n   * @category Objects\n   * @param {Mixed} value The value to check.\n   * @returns {Boolean} Returns `true` if the `value` is a boolean value, else `false`.\n   * @example\n   *\n   * _.isBoolean(null);\n   * // => false\n   */\n  function isBoolean(value) {\n    return value === true || value === false || toString.call(value) == boolClass;\n  }\n\n  /**\n   * Checks if `value` is a date.\n   *\n   * @static\n   * @memberOf _\n   * @category Objects\n   * @param {Mixed} value The value to check.\n   * @returns {Boolean} Returns `true` if the `value` is a date, else `false`.\n   * @example\n   *\n   * _.isDate(new Date);\n   * // => true\n   */\n  function isDate(value) {\n    return toString.call(value) == dateClass;\n  }\n\n  /**\n   * Checks if `value` is a DOM element.\n   *\n   * @static\n   * @memberOf _\n   * @category Objects\n   * @param {Mixed} value The value to check.\n   * @returns {Boolean} Returns `true` if the `value` is a DOM element, else `false`.\n   * @example\n   *\n   * _.isElement(document.body);\n   * // => true\n   */\n  function isElement(value) {\n    return value ? value.nodeType === 1 : false;\n  }\n\n  /**\n   * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a\n   * length of `0` and objects with no own enumerable properties are considered\n   * \"empty\".\n   *\n   * @static\n   * @memberOf _\n   * @category Objects\n   * @param {Array|Object|String} value The value to inspect.\n   * @returns {Boolean} Returns `true` if the `value` is empty, else `false`.\n   * @example\n   *\n   * _.isEmpty([1, 2, 3]);\n   * // => false\n   *\n   * _.isEmpty({});\n   * // => true\n   *\n   * _.isEmpty('');\n   * // => true\n   */\n  function isEmpty(value) {\n    var result = true;\n    if (!value) {\n      return result;\n    }\n    var className = toString.call(value),\n        length = value.length;\n\n    if ((className == arrayClass || className == stringClass ||\n        className == argsClass || (noArgsClass && isArguments(value))) ||\n        (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {\n      return !length;\n    }\n    forOwn(value, function() {\n      return (result = false);\n    });\n    return result;\n  }\n\n  /**\n   * Performs a deep comparison between two values to determine if they are\n   * equivalent to each other.\n   *\n   * @static\n   * @memberOf _\n   * @category Objects\n   * @param {Mixed} a The value to compare.\n   * @param {Mixed} b The other value to compare.\n   * @param- {Object} [stackA=[]] Internally used track traversed `a` objects.\n   * @param- {Object} [stackB=[]] Internally used track traversed `b` objects.\n   * @returns {Boolean} Returns `true` if the values are equvalent, else `false`.\n   * @example\n   *\n   * var moe = { 'name': 'moe', 'luckyNumbers': [13, 27, 34] };\n   * var clone = { 'name': 'moe', 'luckyNumbers': [13, 27, 34] };\n   *\n   * moe == clone;\n   * // => false\n   *\n   * _.isEqual(moe, clone);\n   * // => true\n   */\n  function isEqual(a, b, stackA, stackB) {\n    // exit early for identical values\n    if (a === b) {\n      // treat `+0` vs. `-0` as not equal\n      return a !== 0 || (1 / a == 1 / b);\n    }\n    // a strict comparison is necessary because `null == undefined`\n    if (a == null || b == null) {\n      return a === b;\n    }\n    // compare [[Class]] names\n    var className = toString.call(a);\n    if (className != toString.call(b)) {\n      return false;\n    }\n    switch (className) {\n      case boolClass:\n      case dateClass:\n        // coerce dates and booleans to numbers, dates to milliseconds and booleans\n        // to `1` or `0`, treating invalid dates coerced to `NaN` as not equal\n        return +a == +b;\n\n      case numberClass:\n        // treat `NaN` vs. `NaN` as equal\n        return a != +a\n          ? b != +b\n          // but treat `+0` vs. `-0` as not equal\n          : (a == 0 ? (1 / a == 1 / b) : a == +b);\n\n      case regexpClass:\n      case stringClass:\n        // coerce regexes to strings (http://es5.github.com/#x15.10.6.4)\n        // treat string primitives and their corresponding object instances as equal\n        return a == b + '';\n    }\n    // exit early, in older browsers, if `a` is array-like but not `b`\n    var isArr = className == arrayClass || className == argsClass;\n    if (noArgsClass && !isArr && (isArr = isArguments(a)) && !isArguments(b)) {\n      return false;\n    }\n    if (!isArr) {\n      // unwrap any `lodash` wrapped values\n      if (a.__wrapped__ || b.__wrapped__) {\n        return isEqual(a.__wrapped__ || a, b.__wrapped__ || b);\n      }\n      // exit for functions and DOM nodes\n      if (className != objectClass || (noNodeClass && (\n          (typeof a.toString != 'function' && typeof (a + '') == 'string') ||\n          (typeof b.toString != 'function' && typeof (b + '') == 'string')))) {\n        return false;\n      }\n      var ctorA = a.constructor,\n          ctorB = b.constructor;\n\n      // non `Object` object instances with different constructors are not equal\n      if (ctorA != ctorB && !(\n            isFunction(ctorA) && ctorA instanceof ctorA &&\n            isFunction(ctorB) && ctorB instanceof ctorB\n          )) {\n        return false;\n      }\n    }\n    // assume cyclic structures are equal\n    // the algorithm for detecting cyclic structures is adapted from ES 5.1\n    // section 15.12.3, abstract operation `JO` (http://es5.github.com/#x15.12.3)\n    stackA || (stackA = []);\n    stackB || (stackB = []);\n\n    var length = stackA.length;\n    while (length--) {\n      if (stackA[length] == a) {\n        return stackB[length] == b;\n      }\n    }\n\n    var index = -1,\n        result = true,\n        size = 0;\n\n    // add `a` and `b` to the stack of traversed objects\n    stackA.push(a);\n    stackB.push(b);\n\n    // recursively compare objects and arrays (susceptible to call stack limits)\n    if (isArr) {\n      // compare lengths to determine if a deep comparison is necessary\n      size = a.length;\n      result = size == b.length;\n\n      if (result) {\n        // deep compare the contents, ignoring non-numeric properties\n        while (size--) {\n          if (!(result = isEqual(a[size], b[size], stackA, stackB))) {\n            break;\n          }\n        }\n      }\n      return result;\n    }\n    // deep compare objects\n    for (var key in a) {\n      if (hasOwnProperty.call(a, key)) {\n        // count the number of properties.\n        size++;\n        // deep compare each property value.\n        if (!(hasOwnProperty.call(b, key) && isEqual(a[key], b[key], stackA, stackB))) {\n          return false;\n        }\n      }\n    }\n    // ensure both objects have the same number of properties\n    for (key in b) {\n      // The JS engine in Adobe products, like InDesign, has a bug that causes\n      // `!size--` to throw an error so it must be wrapped in parentheses.\n      // https://github.com/documentcloud/underscore/issues/355\n      if (hasOwnProperty.call(b, key) && !(size--)) {\n        // `size` will be `-1` if `b` has more properties than `a`\n        return false;\n      }\n    }\n    // handle JScript [[DontEnum]] bug\n    if (hasDontEnumBug) {\n      while (++index < 7) {\n        key = shadowed[index];\n        if (hasOwnProperty.call(a, key) &&\n            !(hasOwnProperty.call(b, key) && isEqual(a[key], b[key], stackA, stackB))) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Checks if `value` is, or can be coerced to, a finite number.\n   *\n   * Note: This is not the same as native `isFinite`, which will return true for\n   * booleans and empty strings. See http://es5.github.com/#x15.1.2.5.\n   *\n   * @deprecated\n   * @static\n   * @memberOf _\n   * @category Objects\n   * @param {Mixed} value The value to check.\n   * @returns {Boolean} Returns `true` if the `value` is a finite number, else `false`.\n   * @example\n   *\n   * _.isFinite(-101);\n   * // => true\n   *\n   * _.isFinite('10');\n   * // => true\n   *\n   * _.isFinite(true);\n   * // => false\n   *\n   * _.isFinite('');\n   * // => false\n   *\n   * _.isFinite(Infinity);\n   * // => false\n   */\n  function isFinite(value) {\n    return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));\n  }\n\n  /**\n   * Checks if `value` is a function.\n   *\n   * @static\n   * @memberOf _\n   * @category Objects\n   * @param {Mixed} value The value to check.\n   * @returns {Boolean} Returns `true` if the `value` is a function, else `false`.\n   * @example\n   *\n   * _.isFunction(_);\n   * // => true\n   */\n  function isFunction(value) {\n    return typeof value == 'function';\n  }\n  // fallback for older versions of Chrome and Safari\n  if (isFunction(/x/)) {\n    isFunction = function(value) {\n      return toString.call(value) == funcClass;\n    };\n  }\n\n  /**\n   * Checks if `value` is the language type of Object.\n   * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n   *\n   * @static\n   * @memberOf _\n   * @category Objects\n   * @param {Mixed} value The value to check.\n   * @returns {Boolean} Returns `true` if the `value` is an object, else `false`.\n   * @example\n   *\n   * _.isObject({});\n   * // => true\n   *\n   * _.isObject([1, 2, 3]);\n   * // => true\n   *\n   * _.isObject(1);\n   * // => false\n   */\n  function isObject(value) {\n    // check if the value is the ECMAScript language type of Object\n    // http://es5.github.com/#x8\n    // and avoid a V8 bug\n    // http://code.google.com/p/v8/issues/detail?id=2291\n    return value ? objectTypes[typeof value] : false;\n  }\n\n  /**\n   * Checks if `value` is `NaN`.\n   *\n   * Note: This is not the same as native `isNaN`, which will return true for\n   * `undefined` and other values. See http://es5.github.com/#x15.1.2.4.\n   *\n   * @deprecated\n   * @static\n   * @memberOf _\n   * @category Objects\n   * @param {Mixed} value The value to check.\n   * @returns {Boolean} Returns `true` if the `value` is `NaN`, else `false`.\n   * @example\n   *\n   * _.isNaN(NaN);\n   * // => true\n   *\n   * _.isNaN(new Number(NaN));\n   * // => true\n   *\n   * isNaN(undefined);\n   * // => true\n   *\n   * _.isNaN(undefined);\n   * // => false\n   */\n  function isNaN(value) {\n    // `NaN` as a primitive is the only value that is not equal to itself\n    // (perform the [[Class]] check first to avoid errors with some host objects in IE)\n    return toString.call(value) == numberClass && value != +value\n  }\n\n  /**\n   * Checks if `value` is `null`.\n   *\n   * @deprecated\n   * @static\n   * @memberOf _\n   * @category Objects\n   * @param {Mixed} value The value to check.\n   * @returns {Boolean} Returns `true` if the `value` is `null`, else `false`.\n   * @example\n   *\n   * _.isNull(null);\n   * // => true\n   *\n   * _.isNull(undefined);\n   * // => false\n   */\n  function isNull(value) {\n    return value === null;\n  }\n\n  /**\n   * Checks if `value` is a number.\n   *\n   * @static\n   * @memberOf _\n   * @category Objects\n   * @param {Mixed} value The value to check.\n   * @returns {Boolean} Returns `true` if the `value` is a number, else `false`.\n   * @example\n   *\n   * _.isNumber(8.4 * 5);\n   * // => true\n   */\n  function isNumber(value) {\n    return toString.call(value) == numberClass;\n  }\n\n  /**\n   * Checks if a given `value` is an object created by the `Object` constructor.\n   *\n   * @static\n   * @memberOf _\n   * @category Objects\n   * @param {Mixed} value The value to check.\n   * @returns {Boolean} Returns `true` if `value` is a plain object, else `false`.\n   * @example\n   *\n   * function Stooge(name, age) {\n   *   this.name = name;\n   *   this.age = age;\n   * }\n   *\n   * _.isPlainObject(new Stooge('moe', 40));\n   * // => false\n   *\n   * _.isPlainObject([1, 2, 3]);\n   * // => false\n   *\n   * _.isPlainObject({ 'name': 'moe', 'age': 40 });\n   * // => true\n   */\n  var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {\n    if (!(value && typeof value == 'object')) {\n      return false;\n    }\n    var valueOf = value.valueOf,\n        objProto = typeof valueOf == 'function' && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);\n\n    return objProto\n      ? value == objProto || (getPrototypeOf(value) == objProto && !isArguments(value))\n      : shimIsPlainObject(value);\n  };\n\n  /**\n   * Checks if `value` is a regular expression.\n   *\n   * @static\n   * @memberOf _\n   * @category Objects\n   * @param {Mixed} value The value to check.\n   * @returns {Boolean} Returns `true` if the `value` is a regular expression, else `false`.\n   * @example\n   *\n   * _.isRegExp(/moe/);\n   * // => true\n   */\n  function isRegExp(value) {\n    return toString.call(value) == regexpClass;\n  }\n\n  /**\n   * Checks if `value` is a string.\n   *\n   * @static\n   * @memberOf _\n   * @category Objects\n   * @param {Mixed} value The value to check.\n   * @returns {Boolean} Returns `true` if the `value` is a string, else `false`.\n   * @example\n   *\n   * _.isString('moe');\n   * // => true\n   */\n  function isString(value) {\n    return toString.call(value) == stringClass;\n  }\n\n  /**\n   * Checks if `value` is `undefined`.\n   *\n   * @deprecated\n   * @static\n   * @memberOf _\n   * @category Objects\n   * @param {Mixed} value The value to check.\n   * @returns {Boolean} Returns `true` if the `value` is `undefined`, else `false`.\n   * @example\n   *\n   * _.isUndefined(void 0);\n   * // => true\n   */\n  function isUndefined(value) {\n    return value === undefined;\n  }\n\n  /**\n   * Creates an array composed of the own enumerable property names of `object`.\n   *\n   * @static\n   * @memberOf _\n   * @category Objects\n   * @param {Object} object The object to inspect.\n   * @returns {Array} Returns a new array of property names.\n   * @example\n   *\n   * _.keys({ 'one': 1, 'two': 2, 'three': 3 });\n   * // => ['one', 'two', 'three'] (order is not guaranteed)\n   */\n  var keys = !nativeKeys ? shimKeys : function(object) {\n    // avoid iterating over the `prototype` property\n    return typeof object == 'function' && propertyIsEnumerable.call(object, 'prototype')\n      ? shimKeys(object)\n      : (isObject(object) ? nativeKeys(object) : []);\n  };\n\n  /**\n   * Merges enumerable properties of the source object(s) into the `destination`\n   * object. Subsequent sources will overwrite propery assignments of previous\n   * sources.\n   *\n   * @static\n   * @memberOf _\n   * @category Objects\n   * @param {Object} object The destination object.\n   * @param {Object} [source1, source2, ...] The source objects.\n   * @param- {Object} [indicator] Internally used to indicate that the `stack`\n   *  argument is an array of traversed objects instead of another source object.\n   * @param- {Array} [stackA=[]] Internally used to track traversed source objects.\n   * @param- {Array} [stackB=[]] Internally used to associate values with their\n   *  source counterparts.\n   * @returns {Object} Returns the destination object.\n   * @example\n   *\n   * var stooges = [\n   *   { 'name': 'moe' },\n   *   { 'name': 'larry' }\n   * ];\n   *\n   * var ages = [\n   *   { 'age': 40 },\n   *   { 'age': 50 }\n   * ];\n   *\n   * _.merge(stooges, ages);\n   * // => [{ 'name': 'moe', 'age': 40 }, { 'name': 'larry', 'age': 50 }]\n   */\n  function merge(object, source, indicator) {\n    var args = arguments,\n        index = 0,\n        length = 2,\n        stackA = args[3],\n        stackB = args[4];\n\n    if (indicator !== objectRef) {\n      stackA = [];\n      stackB = [];\n      length = args.length;\n    }\n    while (++index < length) {\n      forOwn(args[index], function(source, key) {\n        var found, isArr, value;\n        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {\n          // avoid merging previously merged cyclic sources\n          var stackLength = stackA.length;\n          while (stackLength--) {\n            found = stackA[stackLength] == source;\n            if (found) {\n              break;\n            }\n          }\n          if (found) {\n            object[key] = stackB[stackLength];\n          }\n          else {\n            // add `source` and associated `value` to the stack of traversed objects\n            stackA.push(source);\n            stackB.push(value = (value = object[key], isArr)\n              ? (isArray(value) ? value : [])\n              : (isPlainObject(value) ? value : {})\n            );\n            // recursively merge objects and arrays (susceptible to call stack limits)\n            object[key] = merge(value, source, objectRef, stackA, stackB);\n          }\n        } else if (source != null) {\n          object[key] = source;\n        }\n      });\n    }\n    return object;\n  }\n\n  /**\n   * Creates a shallow clone of `object` excluding the specified properties.\n   * Property names may be specified as individual arguments or as arrays of\n   * property names. If `callback` is passed, it will be executed for each property\n   * in the `object`, omitting the properties `callback` returns truthy for. The\n   * `callback` is bound to `thisArg` and invoked with three arguments; (value, key, object).\n   *\n   * @static\n   * @memberOf _\n   * @category Objects\n   * @param {Object} object The source object.\n   * @param {Function|String} callback|[prop1, prop2, ...] The properties to omit\n   *  or the function called per iteration.\n   * @param {Mixed} [thisArg] The `this` binding of `callback`.\n   * @returns {Object} Returns an object without the omitted properties.\n   * @example\n   *\n   * _.omit({ 'name': 'moe', 'age': 40, 'userid': 'moe1' }, 'userid');\n   * // => { 'name': 'moe', 'age': 40 }\n   *\n   * _.omit({ 'name': 'moe', '_hint': 'knucklehead', '_seed': '96c4eb' }, function(value, key) {\n   *   return key.charAt(0) == '_';\n   * });\n   * // => { 'name': 'moe' }\n   */\n  function omit(object, callback, thisArg) {\n    var isFunc = typeof callback == 'function',\n        result = {};\n\n    if (isFunc) {\n      callback = createCallback(callback, thisArg);\n    } else {\n      var props = concat.apply(arrayRef, arguments);\n    }\n    forIn(object, function(value, key, object) {\n      if (isFunc\n            ? !callback(value, key, object)\n            : indexOf(props, key, 1) < 0\n          ) {\n        result[key] = value;\n      }\n    });\n    return result;\n  }\n\n  /**\n   * Creates a two dimensional array of the given object's key-value pairs,\n   * i.e. `[[key1, value1], [key2, value2]]`.\n   *\n   * @static\n   * @memberOf _\n   * @category Objects\n   * @param {Object} object The object to inspect.\n   * @returns {Array} Returns new array of key-value pairs.\n   * @example\n   *\n   * _.pairs({ 'moe': 30, 'larry': 40, 'curly': 50 });\n   * // => [['moe', 30], ['larry', 40], ['curly', 50]] (order is not guaranteed)\n   */\n  function pairs(object) {\n    var result = [];\n    forOwn(object, function(value, key) {\n      result.push([key, value]);\n    });\n    return result;\n  }\n\n  /**\n   * Creates a shallow clone of `object` composed of the specified properties.\n   * Property names may be specified as individual arguments or as arrays of\n   * property names. If `callback` is passed, it will be executed for each property\n   * in the `object`, picking the properties `callback` returns truthy for. The\n   * `callback` is bound to `thisArg` and invoked with three arguments; (value, key, object).\n   *\n   * @static\n   * @memberOf _\n   * @category Objects\n   * @param {Object} object The source object.\n   * @param {Function|String} callback|[prop1, prop2, ...] The properties to pick\n   *  or the function called per iteration.\n   * @param {Mixed} [thisArg] The `this` binding of `callback`.\n   * @returns {Object} Returns an object composed of the picked properties.\n   * @example\n   *\n   * _.pick({ 'name': 'moe', 'age': 40, 'userid': 'moe1' }, 'name', 'age');\n   * // => { 'name': 'moe', 'age': 40 }\n   *\n   * _.pick({ 'name': 'moe', '_hint': 'knucklehead', '_seed': '96c4eb' }, function(value, key) {\n   *   return key.charAt(0) != '_';\n   * });\n   * // => { 'name': 'moe' }\n   */\n  function pick(object, callback, thisArg) {\n    var result = {};\n    if (typeof callback != 'function') {\n      var index = 0,\n          props = concat.apply(arrayRef, arguments),\n          length = props.length;\n\n      while (++index < length) {\n        var key = props[index];\n        if (key in object) {\n          result[key] = object[key];\n        }\n      }\n    } else {\n      callback = createCallback(callback, thisArg);\n      forIn(object, function(value, key, object) {\n        if (callback(value, key, object)) {\n          result[key] = value;\n        }\n      });\n    }\n    return result;\n  }\n\n  /**\n   * Creates an array composed of the own enumerable property values of `object`.\n   *\n   * @static\n   * @memberOf _\n   * @category Objects\n   * @param {Object} object The object to inspect.\n   * @returns {Array} Returns a new array of property values.\n   * @example\n   *\n   * _.values({ 'one': 1, 'two': 2, 'three': 3 });\n   * // => [1, 2, 3]\n   */\n  function values(object) {\n    var result = [];\n    forOwn(object, function(value) {\n      result.push(value);\n    });\n    return result;\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Checks if a given `target` element is present in a `collection` using strict\n   * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used\n   * as the offset from the end of the collection.\n   *\n   * @static\n   * @memberOf _\n   * @alias include\n   * @category Collections\n   * @param {Array|Object|String} collection The collection to iterate over.\n   * @param {Mixed} target The value to check for.\n   * @param {Number} [fromIndex=0] The index to search from.\n   * @returns {Boolean} Returns `true` if the `target` element is found, else `false`.\n   * @example\n   *\n   * _.contains([1, 2, 3], 1);\n   * // => true\n   *\n   * _.contains([1, 2, 3], 1, 2);\n   * // => false\n   *\n   * _.contains({ 'name': 'moe', 'age': 40 }, 'moe');\n   * // => true\n   *\n   * _.contains('curly', 'ur');\n   * // => true\n   */\n  function contains(collection, target, fromIndex) {\n    var index = -1,\n        length = collection ? collection.length : 0;\n\n    fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;\n    if (typeof length == 'number') {\n      return (isString(collection)\n        ? collection.indexOf(target, fromIndex)\n        : indexOf(collection, target, fromIndex)\n      ) > -1;\n    }\n    return some(collection, function(value) {\n      return ++index >= fromIndex && value === target;\n    });\n  }\n\n  /**\n   * Creates an object composed of keys returned from running each element of\n   * `collection` through a `callback`. The corresponding value of each key is\n   * the number of times the key was returned by `callback`. The `callback` is\n   * bound to `thisArg` and invoked with three arguments; (value, index|key, collection).\n   * The `callback` argument may also be the name of a property to count by (e.g. 'length').\n   *\n   * @static\n   * @memberOf _\n   * @category Collections\n   * @param {Array|Object|String} collection The collection to iterate over.\n   * @param {Function|String} callback|property The function called per iteration\n   *  or property name to count by.\n   * @param {Mixed} [thisArg] The `this` binding of `callback`.\n   * @returns {Object} Returns the composed aggregate object.\n   * @example\n   *\n   * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });\n   * // => { '4': 1, '6': 2 }\n   *\n   * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);\n   * // => { '4': 1, '6': 2 }\n   *\n   * _.countBy(['one', 'two', 'three'], 'length');\n   * // => { '3': 2, '5': 1 }\n   */\n  function countBy(collection, callback, thisArg) {\n    var result = {};\n    callback = createCallback(callback, thisArg);\n    forEach(collection, function(value, key, collection) {\n      key = callback(value, key, collection);\n      (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);\n    });\n    return result;\n  }\n\n  /**\n   * Checks if the `callback` returns a truthy value for **all** elements of a\n   * `collection`. The `callback` is bound to `thisArg` and invoked with three\n   * arguments; (value, index|key, collection).\n   *\n   * @static\n   * @memberOf _\n   * @alias all\n   * @category Collections\n   * @param {Array|Object|String} collection The collection to iterate over.\n   * @param {Function} [callback=identity] The function called per iteration.\n   * @param {Mixed} [thisArg] The `this` binding of `callback`.\n   * @returns {Boolean} Returns `true` if all elements pass the callback check,\n   *  else `false`.\n   * @example\n   *\n   * _.every([true, 1, null, 'yes'], Boolean);\n   * // => false\n   */\n  function every(collection, callback, thisArg) {\n    var result = true;\n    callback = createCallback(callback, thisArg);\n\n    if (isArray(collection)) {\n      var index = -1,\n          length = collection.length;\n\n      while (++index < length) {\n        if (!(result = !!callback(collection[index], index, collection))) {\n          break;\n        }\n      }\n    } else {\n      forEach(collection, function(value, index, collection) {\n        return (result = !!callback(value, index, collection));\n      });\n    }\n    return result;\n  }\n\n  /**\n   * Examines each element in a `collection`, returning an array of all elements\n   * the `callback` returns truthy for. The `callback` is bound to `thisArg` and\n   * invoked with three arguments; (value, index|key, collection).\n   *\n   * @static\n   * @memberOf _\n   * @alias select\n   * @category Collections\n   * @param {Array|Object|String} collection The collection to iterate over.\n   * @param {Function} [callback=identity] The function called per iteration.\n   * @param {Mixed} [thisArg] The `this` binding of `callback`.\n   * @returns {Array} Returns a new array of elements that passed the callback check.\n   * @example\n   *\n   * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });\n   * // => [2, 4, 6]\n   */\n  function filter(collection, callback, thisArg) {\n    var result = [];\n    callback = createCallback(callback, thisArg);\n    forEach(collection, function(value, index, collection) {\n      if (callback(value, index, collection)) {\n        result.push(value);\n      }\n    });\n    return result;\n  }\n\n  /**\n   * Examines each element in a `collection`, returning the first one the `callback`\n   * returns truthy for. The function returns as soon as it finds an acceptable\n   * element, and does not iterate over the entire `collection`. The `callback` is\n   * bound to `thisArg` and invoked with three arguments; (value, index|key, collection).\n   *\n   * @static\n   * @memberOf _\n   * @alias detect\n   * @category Collections\n   * @param {Array|Object|String} collection The collection to iterate over.\n   * @param {Function} callback The function called per iteration.\n   * @param {Mixed} [thisArg] The `this` binding of `callback`.\n   * @returns {Mixed} Returns the element that passed the callback check,\n   *  else `undefined`.\n   * @example\n   *\n   * var even = _.find([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });\n   * // => 2\n   */\n  function find(collection, callback, thisArg) {\n    var result;\n    callback = createCallback(callback, thisArg);\n    forEach(collection, function(value, index, collection) {\n      if (callback(value, index, collection)) {\n        result = value;\n        return false;\n      }\n    });\n    return result;\n  }\n\n  /**\n   * Iterates over a `collection`, executing the `callback` for each element in\n   * the `collection`. The `callback` is bound to `thisArg` and invoked with three\n   * arguments; (value, index|key, collection). Callbacks may exit iteration early\n   * by explicitly returning `false`.\n   *\n   * @static\n   * @memberOf _\n   * @alias each\n   * @category Collections\n   * @param {Array|Object|String} collection The collection to iterate over.\n   * @param {Function} callback The function called per iteration.\n   * @param {Mixed} [thisArg] The `this` binding of `callback`.\n   * @returns {Array|Object|String} Returns `collection`.\n   * @example\n   *\n   * _([1, 2, 3]).forEach(alert).join(',');\n   * // => alerts each number and returns '1,2,3'\n   *\n   * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, alert);\n   * // => alerts each number (order is not guaranteed)\n   */\n  var forEach = createIterator(forEachIteratorOptions);\n\n  /**\n   * Creates an object composed of keys returned from running each element of\n   * `collection` through a `callback`. The corresponding value of each key is an\n   * array of elements passed to `callback` that returned the key. The `callback`\n   * is bound to `thisArg` and invoked with three arguments; (value, index|key, collection).\n   * The `callback` argument may also be the name of a property to group by (e.g. 'length').\n   *\n   * @static\n   * @memberOf _\n   * @category Collections\n   * @param {Array|Object|String} collection The collection to iterate over.\n   * @param {Function|String} callback|property The function called per iteration\n   *  or property name to group by.\n   * @param {Mixed} [thisArg] The `this` binding of `callback`.\n   * @returns {Object} Returns the composed aggregate object.\n   * @example\n   *\n   * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });\n   * // => { '4': [4.2], '6': [6.1, 6.4] }\n   *\n   * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);\n   * // => { '4': [4.2], '6': [6.1, 6.4] }\n   *\n   * _.groupBy(['one', 'two', 'three'], 'length');\n   * // => { '3': ['one', 'two'], '5': ['three'] }\n   */\n  function groupBy(collection, callback, thisArg) {\n    var result = {};\n    callback = createCallback(callback, thisArg);\n    forEach(collection, function(value, key, collection) {\n      key = callback(value, key, collection);\n      (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);\n    });\n    return result;\n  }\n\n  /**\n   * Invokes the method named by `methodName` on each element in the `collection`,\n   * returning an array of the results of each invoked method. Additional arguments\n   * will be passed to each invoked method. If `methodName` is a function it will\n   * be invoked for, and `this` bound to, each element in the `collection`.\n   *\n   * @static\n   * @memberOf _\n   * @category Collections\n   * @param {Array|Object|String} collection The collection to iterate over.\n   * @param {Function|String} methodName The name of the method to invoke or\n   *  the function invoked per iteration.\n   * @param {Mixed} [arg1, arg2, ...] Arguments to invoke the method with.\n   * @returns {Array} Returns a new array of the results of each invoked method.\n   * @example\n   *\n   * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');\n   * // => [[1, 5, 7], [1, 2, 3]]\n   *\n   * _.invoke([123, 456], String.prototype.split, '');\n   * // => [['1', '2', '3'], ['4', '5', '6']]\n   */\n  function invoke(collection, methodName) {\n    var args = slice.call(arguments, 2),\n        isFunc = typeof methodName == 'function',\n        result = [];\n\n    forEach(collection, function(value) {\n      result.push((isFunc ? methodName : value[methodName]).apply(value, args));\n    });\n    return result;\n  }\n\n  /**\n   * Creates an array of values by running each element in the `collection`\n   * through a `callback`. The `callback` is bound to `thisArg` and invoked with\n   * three arguments; (value, index|key, collection).\n   *\n   * @static\n   * @memberOf _\n   * @alias collect\n   * @category Collections\n   * @param {Array|Object|String} collection The collection to iterate over.\n   * @param {Function} [callback=identity] The function called per iteration.\n   * @param {Mixed} [thisArg] The `this` binding of `callback`.\n   * @returns {Array} Returns a new array of the results of each `callback` execution.\n   * @example\n   *\n   * _.map([1, 2, 3], function(num) { return num * 3; });\n   * // => [3, 6, 9]\n   *\n   * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });\n   * // => [3, 6, 9] (order is not guaranteed)\n   */\n  function map(collection, callback, thisArg) {\n    var index = -1,\n        length = collection ? collection.length : 0,\n        result = Array(typeof length == 'number' ? length : 0);\n\n    callback = createCallback(callback, thisArg);\n    if (isArray(collection)) {\n      while (++index < length) {\n        result[index] = callback(collection[index], index, collection);\n      }\n    } else {\n      forEach(collection, function(value, key, collection) {\n        result[++index] = callback(value, key, collection);\n      });\n    }\n    return result;\n  }\n\n  /**\n   * Retrieves the maximum value of an `array`. If `callback` is passed,\n   * it will be executed for each value in the `array` to generate the\n   * criterion by which the value is ranked. The `callback` is bound to\n   * `thisArg` and invoked with three arguments; (value, index, collection).\n   *\n   * @static\n   * @memberOf _\n   * @category Collections\n   * @param {Array|Object|String} collection The collection to iterate over.\n   * @param {Function} [callback] The function called per iteration.\n   * @param {Mixed} [thisArg] The `this` binding of `callback`.\n   * @returns {Mixed} Returns the maximum value.\n   * @example\n   *\n   * var stooges = [\n   *   { 'name': 'moe', 'age': 40 },\n   *   { 'name': 'larry', 'age': 50 },\n   *   { 'name': 'curly', 'age': 60 }\n   * ];\n   *\n   * _.max(stooges, function(stooge) { return stooge.age; });\n   * // => { 'name': 'curly', 'age': 60 };\n   */\n  function max(collection, callback, thisArg) {\n    var computed = -Infinity,\n        index = -1,\n        length = collection ? collection.length : 0,\n        result = computed;\n\n    if (callback || !isArray(collection)) {\n      callback = !callback && isString(collection)\n        ? charAtCallback\n        : createCallback(callback, thisArg);\n\n      forEach(collection, function(value, index, collection) {\n        var current = callback(value, index, collection);\n        if (current > computed) {\n          computed = current;\n          result = value;\n        }\n      });\n    } else {\n      while (++index < length) {\n        if (collection[index] > result) {\n          result = collection[index];\n        }\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Retrieves the minimum value of an `array`. If `callback` is passed,\n   * it will be executed for each value in the `array` to generate the\n   * criterion by which the value is ranked. The `callback` is bound to `thisArg`\n   * and invoked with three arguments; (value, index, collection).\n   *\n   * @static\n   * @memberOf _\n   * @category Collections\n   * @param {Array|Object|String} collection The collection to iterate over.\n   * @param {Function} [callback] The function called per iteration.\n   * @param {Mixed} [thisArg] The `this` binding of `callback`.\n   * @returns {Mixed} Returns the minimum value.\n   * @example\n   *\n   * _.min([10, 5, 100, 2, 1000]);\n   * // => 2\n   */\n  function min(collection, callback, thisArg) {\n    var computed = Infinity,\n        index = -1,\n        length = collection ? collection.length : 0,\n        result = computed;\n\n    if (callback || !isArray(collection)) {\n      callback = !callback && isString(collection)\n        ? charAtCallback\n        : createCallback(callback, thisArg);\n\n      forEach(collection, function(value, index, collection) {\n        var current = callback(value, index, collection);\n        if (current < computed) {\n          computed = current;\n          result = value;\n        }\n      });\n    } else {\n      while (++index < length) {\n        if (collection[index] < result) {\n          result = collection[index];\n        }\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Retrieves the value of a specified property from all elements in\n   * the `collection`.\n   *\n   * @static\n   * @memberOf _\n   * @category Collections\n   * @param {Array|Object|String} collection The collection to iterate over.\n   * @param {String} property The property to pluck.\n   * @returns {Array} Returns a new array of property values.\n   * @example\n   *\n   * var stooges = [\n   *   { 'name': 'moe', 'age': 40 },\n   *   { 'name': 'larry', 'age': 50 },\n   *   { 'name': 'curly', 'age': 60 }\n   * ];\n   *\n   * _.pluck(stooges, 'name');\n   * // => ['moe', 'larry', 'curly']\n   */\n  function pluck(collection, property) {\n    var result = [];\n    forEach(collection, function(value) {\n      result.push(value[property]);\n    });\n    return result;\n  }\n\n  /**\n   * Boils down a `collection` to a single value. The initial state of the\n   * reduction is `accumulator` and each successive step of it should be returned\n   * by the `callback`. The `callback` is bound to `thisArg` and invoked with 4\n   * arguments; for arrays they are (accumulator, value, index|key, collection).\n   *\n   * @static\n   * @memberOf _\n   * @alias foldl, inject\n   * @category Collections\n   * @param {Array|Object|String} collection The collection to iterate over.\n   * @param {Function} callback The function called per iteration.\n   * @param {Mixed} [accumulator] Initial value of the accumulator.\n   * @param {Mixed} [thisArg] The `this` binding of `callback`.\n   * @returns {Mixed} Returns the accumulated value.\n   * @example\n   *\n   * var sum = _.reduce([1, 2, 3], function(memo, num) { return memo + num; });\n   * // => 6\n   */\n  function reduce(collection, callback, accumulator, thisArg) {\n    var noaccum = arguments.length < 3;\n    callback = createCallback(callback, thisArg);\n    forEach(collection, function(value, index, collection) {\n      accumulator = noaccum\n        ? (noaccum = false, value)\n        : callback(accumulator, value, index, collection)\n    });\n    return accumulator;\n  }\n\n  /**\n   * The right-associative version of `_.reduce`.\n   *\n   * @static\n   * @memberOf _\n   * @alias foldr\n   * @category Collections\n   * @param {Array|Object|String} collection The collection to iterate over.\n   * @param {Function} callback The function called per iteration.\n   * @param {Mixed} [accumulator] Initial value of the accumulator.\n   * @param {Mixed} [thisArg] The `this` binding of `callback`.\n   * @returns {Mixed} Returns the accumulated value.\n   * @example\n   *\n   * var list = [[0, 1], [2, 3], [4, 5]];\n   * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);\n   * // => [4, 5, 2, 3, 0, 1]\n   */\n  function reduceRight(collection, callback, accumulator, thisArg) {\n    var iteratee = collection,\n        length = collection ? collection.length : 0,\n        noaccum = arguments.length < 3;\n\n    if (typeof length != 'number') {\n      var props = keys(collection);\n      length = props.length;\n    } else if (noCharByIndex && isString(collection)) {\n      iteratee = collection.split('');\n    }\n    forEach(collection, function(value, index, collection) {\n      index = props ? props[--length] : --length;\n      accumulator = noaccum\n        ? (noaccum = false, iteratee[index])\n        : callback.call(thisArg, accumulator, iteratee[index], index, collection);\n    });\n    return accumulator;\n  }\n\n  /**\n   * The opposite of `_.filter`, this method returns the values of a\n   * `collection` that `callback` does **not** return truthy for.\n   *\n   * @static\n   * @memberOf _\n   * @category Collections\n   * @param {Array|Object|String} collection The collection to iterate over.\n   * @param {Function} [callback=identity] The function called per iteration.\n   * @param {Mixed} [thisArg] The `this` binding of `callback`.\n   * @returns {Array} Returns a new array of elements that did **not** pass the\n   *  callback check.\n   * @example\n   *\n   * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });\n   * // => [1, 3, 5]\n   */\n  function reject(collection, callback, thisArg) {\n    callback = createCallback(callback, thisArg);\n    return filter(collection, function(value, index, collection) {\n      return !callback(value, index, collection);\n    });\n  }\n\n  /**\n   * Creates an array of shuffled `array` values, using a version of the\n   * Fisher-Yates shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.\n   *\n   * @static\n   * @memberOf _\n   * @category Collections\n   * @param {Array|Object|String} collection The collection to shuffle.\n   * @returns {Array} Returns a new shuffled collection.\n   * @example\n   *\n   * _.shuffle([1, 2, 3, 4, 5, 6]);\n   * // => [4, 1, 6, 3, 5, 2]\n   */\n  function shuffle(collection) {\n    var index = -1,\n        result = Array(collection ? collection.length : 0);\n\n    forEach(collection, function(value) {\n      var rand = floor(nativeRandom() * (++index + 1));\n      result[index] = result[rand];\n      result[rand] = value;\n    });\n    return result;\n  }\n\n  /**\n   * Gets the size of the `collection` by returning `collection.length` for arrays\n   * and array-like objects or the number of own enumerable properties for objects.\n   *\n   * @static\n   * @memberOf _\n   * @category Collections\n   * @param {Array|Object|String} collection The collection to inspect.\n   * @returns {Number} Returns `collection.length` or number of own enumerable properties.\n   * @example\n   *\n   * _.size([1, 2]);\n   * // => 2\n   *\n   * _.size({ 'one': 1, 'two': 2, 'three': 3 });\n   * // => 3\n   *\n   * _.size('curly');\n   * // => 5\n   */\n  function size(collection) {\n    var length = collection ? collection.length : 0;\n    return typeof length == 'number' ? length : keys(collection).length;\n  }\n\n  /**\n   * Checks if the `callback` returns a truthy value for **any** element of a\n   * `collection`. The function returns as soon as it finds passing value, and\n   * does not iterate over the entire `collection`. The `callback` is bound to\n   * `thisArg` and invoked with three arguments; (value, index|key, collection).\n   *\n   * @static\n   * @memberOf _\n   * @alias any\n   * @category Collections\n   * @param {Array|Object|String} collection The collection to iterate over.\n   * @param {Function} [callback=identity] The function called per iteration.\n   * @param {Mixed} [thisArg] The `this` binding of `callback`.\n   * @returns {Boolean} Returns `true` if any element passes the callback check,\n   *  else `false`.\n   * @example\n   *\n   * _.some([null, 0, 'yes', false]);\n   * // => true\n   */\n  function some(collection, callback, thisArg) {\n    var result;\n    callback = createCallback(callback, thisArg);\n\n    if (isArray(collection)) {\n      var index = -1,\n          length = collection.length;\n\n      while (++index < length) {\n        if (result = callback(collection[index], index, collection)) {\n          break;\n        }\n      }\n    } else {\n      forEach(collection, function(value, index, collection) {\n        return !(result = callback(value, index, collection));\n      });\n    }\n    return !!result;\n  }\n\n  /**\n   * Creates an array, stable sorted in ascending order by the results of\n   * running each element of `collection` through a `callback`. The `callback`\n   * is bound to `thisArg` and invoked with three arguments; (value, index|key, collection).\n   * The `callback` argument may also be the name of a property to sort by (e.g. 'length').\n   *\n   * @static\n   * @memberOf _\n   * @category Collections\n   * @param {Array|Object|String} collection The collection to iterate over.\n   * @param {Function|String} callback|property The function called per iteration\n   *  or property name to sort by.\n   * @param {Mixed} [thisArg] The `this` binding of `callback`.\n   * @returns {Array} Returns a new array of sorted elements.\n   * @example\n   *\n   * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });\n   * // => [3, 1, 2]\n   *\n   * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);\n   * // => [3, 1, 2]\n   *\n   * _.sortBy(['larry', 'brendan', 'moe'], 'length');\n   * // => ['moe', 'larry', 'brendan']\n   */\n  function sortBy(collection, callback, thisArg) {\n    var result = [];\n    callback = createCallback(callback, thisArg);\n    forEach(collection, function(value, index, collection) {\n      result.push({\n        'criteria': callback(value, index, collection),\n        'index': index,\n        'value': value\n      });\n    });\n\n    var length = result.length;\n    result.sort(compareAscending);\n    while (length--) {\n      result[length] = result[length].value;\n    }\n    return result;\n  }\n\n  /**\n   * Converts the `collection`, to an array.\n   *\n   * @static\n   * @memberOf _\n   * @category Collections\n   * @param {Array|Object|String} collection The collection to convert.\n   * @returns {Array} Returns the new converted array.\n   * @example\n   *\n   * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);\n   * // => [2, 3, 4]\n   */\n  function toArray(collection) {\n    if (collection && typeof collection.length == 'number') {\n      return (noArraySliceOnStrings ? isString(collection) : typeof collection == 'string')\n        ? collection.split('')\n        : slice.call(collection);\n    }\n    return values(collection);\n  }\n\n  /**\n   * Examines each element in a `collection`, returning an array of all elements\n   * that contain the given `properties`.\n   *\n   * @static\n   * @memberOf _\n   * @category Collections\n   * @param {Array|Object|String} collection The collection to iterate over.\n   * @param {Object} properties The object of property values to filter by.\n   * @returns {Array} Returns a new array of elements that contain the given `properties`.\n   * @example\n   *\n   * var stooges = [\n   *   { 'name': 'moe', 'age': 40 },\n   *   { 'name': 'larry', 'age': 50 },\n   *   { 'name': 'curly', 'age': 60 }\n   * ];\n   *\n   * _.where(stooges, { 'age': 40 });\n   * // => [{ 'name': 'moe', 'age': 40 }]\n   */\n  function where(collection, properties) {\n    var props = [];\n    forIn(properties, function(value, prop) {\n      props.push(prop);\n    });\n    return filter(collection, function(object) {\n      var length = props.length;\n      while (length--) {\n        var result = object[props[length]] === properties[props[length]];\n        if (!result) {\n          break;\n        }\n      }\n      return !!result;\n    });\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Creates an array with all falsey values of `array` removed. The values\n   * `false`, `null`, `0`, `\"\"`, `undefined` and `NaN` are all falsey.\n   *\n   * @static\n   * @memberOf _\n   * @category Arrays\n   * @param {Array} array The array to compact.\n   * @returns {Array} Returns a new filtered array.\n   * @example\n   *\n   * _.compact([0, 1, false, 2, '', 3]);\n   * // => [1, 2, 3]\n   */\n  function compact(array) {\n    var index = -1,\n        length = array ? array.length : 0,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n      if (value) {\n        result.push(value);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Creates an array of `array` elements not present in the other arrays\n   * using strict equality for comparisons, i.e. `===`.\n   *\n   * @static\n   * @memberOf _\n   * @category Arrays\n   * @param {Array} array The array to process.\n   * @param {Array} [array1, array2, ...] Arrays to check.\n   * @returns {Array} Returns a new array of `array` elements not present in the\n   *  other arrays.\n   * @example\n   *\n   * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);\n   * // => [1, 3, 4]\n   */\n  function difference(array) {\n    var index = -1,\n        length = array ? array.length : 0,\n        flattened = concat.apply(arrayRef, arguments),\n        contains = cachedContains(flattened, length),\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n      if (!contains(value)) {\n        result.push(value);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Gets the first element of the `array`. Pass `n` to return the first `n`\n   * elements of the `array`.\n   *\n   * @static\n   * @memberOf _\n   * @alias head, take\n   * @category Arrays\n   * @param {Array} array The array to query.\n   * @param {Number} [n] The number of elements to return.\n   * @param- {Object} [guard] Internally used to allow this method to work with\n   *  others like `_.map` without using their callback `index` argument for `n`.\n   * @returns {Mixed} Returns the first element or an array of the first `n`\n   *  elements of `array`.\n   * @example\n   *\n   * _.first([5, 4, 3, 2, 1]);\n   * // => 5\n   */\n  function first(array, n, guard) {\n    if (array) {\n      return (n == null || guard) ? array[0] : slice.call(array, 0, n);\n    }\n  }\n\n  /**\n   * Flattens a nested array (the nesting can be to any depth). If `shallow` is\n   * truthy, `array` will only be flattened a single level.\n   *\n   * @static\n   * @memberOf _\n   * @category Arrays\n   * @param {Array} array The array to compact.\n   * @param {Boolean} shallow A flag to indicate only flattening a single level.\n   * @returns {Array} Returns a new flattened array.\n   * @example\n   *\n   * _.flatten([1, [2], [3, [[4]]]]);\n   * // => [1, 2, 3, 4];\n   *\n   * _.flatten([1, [2], [3, [[4]]]], true);\n   * // => [1, 2, 3, [[4]]];\n   */\n  function flatten(array, shallow) {\n    var index = -1,\n        length = array ? array.length : 0,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n\n      // recursively flatten arrays (susceptible to call stack limits)\n      if (isArray(value)) {\n        push.apply(result, shallow ? value : flatten(value));\n      } else {\n        result.push(value);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Gets the index at which the first occurrence of `value` is found using\n   * strict equality for comparisons, i.e. `===`. If the `array` is already\n   * sorted, passing `true` for `fromIndex` will run a faster binary search.\n   *\n   * @static\n   * @memberOf _\n   * @category Arrays\n   * @param {Array} array The array to search.\n   * @param {Mixed} value The value to search for.\n   * @param {Boolean|Number} [fromIndex=0] The index to search from or `true` to\n   *  perform a binary search on a sorted `array`.\n   * @returns {Number} Returns the index of the matched value or `-1`.\n   * @example\n   *\n   * _.indexOf([1, 2, 3, 1, 2, 3], 2);\n   * // => 1\n   *\n   * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);\n   * // => 4\n   *\n   * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);\n   * // => 2\n   */\n  function indexOf(array, value, fromIndex) {\n    var index = -1,\n        length = array ? array.length : 0;\n\n    if (typeof fromIndex == 'number') {\n      index = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0) - 1;\n    } else if (fromIndex) {\n      index = sortedIndex(array, value);\n      return array[index] === value ? index : -1;\n    }\n    while (++index < length) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Gets all but the last element of `array`. Pass `n` to exclude the last `n`\n   * elements from the result.\n   *\n   * @static\n   * @memberOf _\n   * @category Arrays\n   * @param {Array} array The array to query.\n   * @param {Number} [n=1] The number of elements to exclude.\n   * @param- {Object} [guard] Internally used to allow this method to work with\n   *  others like `_.map` without using their callback `index` argument for `n`.\n   * @returns {Array} Returns all but the last element or `n` elements of `array`.\n   * @example\n   *\n   * _.initial([3, 2, 1]);\n   * // => [3, 2]\n   */\n  function initial(array, n, guard) {\n    return array\n      ? slice.call(array, 0, -((n == null || guard) ? 1 : n))\n      : [];\n  }\n\n  /**\n   * Computes the intersection of all the passed-in arrays using strict equality\n   * for comparisons, i.e. `===`.\n   *\n   * @static\n   * @memberOf _\n   * @category Arrays\n   * @param {Array} [array1, array2, ...] Arrays to process.\n   * @returns {Array} Returns a new array of unique elements, in order, that are\n   *  present in **all** of the arrays.\n   * @example\n   *\n   * _.intersection([1, 2, 3], [101, 2, 1, 10], [2, 1]);\n   * // => [1, 2]\n   */\n  function intersection(array) {\n    var args = arguments,\n        argsLength = args.length,\n        cache = {},\n        result = [];\n\n    forEach(array, function(value) {\n      if (indexOf(result, value) < 0) {\n        var length = argsLength;\n        while (--length) {\n          if (!(cache[length] || (cache[length] = cachedContains(args[length])))(value)) {\n            return;\n          }\n        }\n        result.push(value);\n      }\n    });\n    return result;\n  }\n\n  /**\n   * Gets the last element of the `array`. Pass `n` to return the last `n`\n   * elements of the `array`.\n   *\n   * @static\n   * @memberOf _\n   * @category Arrays\n   * @param {Array} array The array to query.\n   * @param {Number} [n] The number of elements to return.\n   * @param- {Object} [guard] Internally used to allow this method to work with\n   *  others like `_.map` without using their callback `index` argument for `n`.\n   * @returns {Mixed} Returns the last element or an array of the last `n`\n   *  elements of `array`.\n   * @example\n   *\n   * _.last([3, 2, 1]);\n   * // => 1\n   */\n  function last(array, n, guard) {\n    if (array) {\n      var length = array.length;\n      return (n == null || guard) ? array[length - 1] : slice.call(array, -n || length);\n    }\n  }\n\n  /**\n   * Gets the index at which the last occurrence of `value` is found using strict\n   * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used\n   * as the offset from the end of the collection.\n   *\n   * @static\n   * @memberOf _\n   * @category Arrays\n   * @param {Array} array The array to search.\n   * @param {Mixed} value The value to search for.\n   * @param {Number} [fromIndex=array.length-1] The index to search from.\n   * @returns {Number} Returns the index of the matched value or `-1`.\n   * @example\n   *\n   * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);\n   * // => 4\n   *\n   * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);\n   * // => 1\n   */\n  function lastIndexOf(array, value, fromIndex) {\n    var index = array ? array.length : 0;\n    if (typeof fromIndex == 'number') {\n      index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;\n    }\n    while (index--) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Creates an object composed from arrays of `keys` and `values`. Pass either\n   * a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`, or\n   * two arrays, one of `keys` and one of corresponding `values`.\n   *\n   * @static\n   * @memberOf _\n   * @category Arrays\n   * @param {Array} keys The array of keys.\n   * @param {Array} [values=[]] The array of values.\n   * @returns {Object} Returns an object composed of the given keys and\n   *  corresponding values.\n   * @example\n   *\n   * _.object(['moe', 'larry', 'curly'], [30, 40, 50]);\n   * // => { 'moe': 30, 'larry': 40, 'curly': 50 }\n   */\n  function object(keys, values) {\n    var index = -1,\n        length = keys ? keys.length : 0,\n        result = {};\n\n    while (++index < length) {\n      var key = keys[index];\n      if (values) {\n        result[key] = values[index];\n      } else {\n        result[key[0]] = key[1];\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Creates an array of numbers (positive and/or negative) progressing from\n   * `start` up to but not including `stop`. This method is a port of Python's\n   * `range()` function. See http://docs.python.org/library/functions.html#range.\n   *\n   * @static\n   * @memberOf _\n   * @category Arrays\n   * @param {Number} [start=0] The start of the range.\n   * @param {Number} end The end of the range.\n   * @param {Number} [step=1] The value to increment or descrement by.\n   * @returns {Array} Returns a new range array.\n   * @example\n   *\n   * _.range(10);\n   * // => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n   *\n   * _.range(1, 11);\n   * // => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n   *\n   * _.range(0, 30, 5);\n   * // => [0, 5, 10, 15, 20, 25]\n   *\n   * _.range(0, -10, -1);\n   * // => [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]\n   *\n   * _.range(0);\n   * // => []\n   */\n  function range(start, end, step) {\n    start = +start || 0;\n    step = +step || 1;\n\n    if (end == null) {\n      end = start;\n      start = 0;\n    }\n    // use `Array(length)` so V8 will avoid the slower \"dictionary\" mode\n    // http://www.youtube.com/watch?v=XAqIpGU8ZZk#t=16m27s\n    var index = -1,\n        length = nativeMax(0, ceil((end - start) / step)),\n        result = Array(length);\n\n    while (++index < length) {\n      result[index] = start;\n      start += step;\n    }\n    return result;\n  }\n\n  /**\n   * The opposite of `_.initial`, this method gets all but the first value of\n   * `array`. Pass `n` to exclude the first `n` values from the result.\n   *\n   * @static\n   * @memberOf _\n   * @alias drop, tail\n   * @category Arrays\n   * @param {Array} array The array to query.\n   * @param {Number} [n=1] The number of elements to exclude.\n   * @param- {Object} [guard] Internally used to allow this method to work with\n   *  others like `_.map` without using their callback `index` argument for `n`.\n   * @returns {Array} Returns all but the first value or `n` values of `array`.\n   * @example\n   *\n   * _.rest([3, 2, 1]);\n   * // => [2, 1]\n   */\n  function rest(array, n, guard) {\n    return array\n      ? slice.call(array, (n == null || guard) ? 1 : n)\n      : [];\n  }\n\n  /**\n   * Uses a binary search to determine the smallest index at which the `value`\n   * should be inserted into `array` in order to maintain the sort order of the\n   * sorted `array`. If `callback` is passed, it will be executed for `value` and\n   * each element in `array` to compute their sort ranking. The `callback` is\n   * bound to `thisArg` and invoked with one argument; (value). The `callback`\n   * argument may also be the name of a property to order by.\n   *\n   * @static\n   * @memberOf _\n   * @category Arrays\n   * @param {Array} array The array to iterate over.\n   * @param {Mixed} value The value to evaluate.\n   * @param {Function|String} [callback=identity|property] The function called\n   *  per iteration or property name to order by.\n   * @param {Mixed} [thisArg] The `this` binding of `callback`.\n   * @returns {Number} Returns the index at which the value should be inserted\n   *  into `array`.\n   * @example\n   *\n   * _.sortedIndex([20, 30, 50], 40);\n   * // => 2\n   *\n   * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');\n   * // => 2\n   *\n   * var dict = {\n   *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }\n   * };\n   *\n   * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {\n   *   return dict.wordToNumber[word];\n   * });\n   * // => 2\n   *\n   * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {\n   *   return this.wordToNumber[word];\n   * }, dict);\n   * // => 2\n   */\n  function sortedIndex(array, value, callback, thisArg) {\n    var low = 0,\n        high = array ? array.length : low;\n\n    // explicitly reference `identity` for better engine inlining\n    callback = callback ? createCallback(callback, thisArg) : identity;\n    value = callback(value);\n    while (low < high) {\n      var mid = (low + high) >>> 1;\n      callback(array[mid]) < value\n        ? low = mid + 1\n        : high = mid;\n    }\n    return low;\n  }\n\n  /**\n   * Computes the union of the passed-in arrays using strict equality for\n   * comparisons, i.e. `===`.\n   *\n   * @static\n   * @memberOf _\n   * @category Arrays\n   * @param {Array} [array1, array2, ...] Arrays to process.\n   * @returns {Array} Returns a new array of unique values, in order, that are\n   *  present in one or more of the arrays.\n   * @example\n   *\n   * _.union([1, 2, 3], [101, 2, 1, 10], [2, 1]);\n   * // => [1, 2, 3, 101, 10]\n   */\n  function union() {\n    return uniq(concat.apply(arrayRef, arguments));\n  }\n\n  /**\n   * Creates a duplicate-value-free version of the `array` using strict equality\n   * for comparisons, i.e. `===`. If the `array` is already sorted, passing `true`\n   * for `isSorted` will run a faster algorithm. If `callback` is passed, each\n   * element of `array` is passed through a callback` before uniqueness is computed.\n   * The `callback` is bound to `thisArg` and invoked with three arguments; (value, index, array).\n   *\n   * @static\n   * @memberOf _\n   * @alias unique\n   * @category Arrays\n   * @param {Array} array The array to process.\n   * @param {Boolean} [isSorted=false] A flag to indicate that the `array` is already sorted.\n   * @param {Function} [callback=identity] The function called per iteration.\n   * @param {Mixed} [thisArg] The `this` binding of `callback`.\n   * @returns {Array} Returns a duplicate-value-free array.\n   * @example\n   *\n   * _.uniq([1, 2, 1, 3, 1]);\n   * // => [1, 2, 3]\n   *\n   * _.uniq([1, 1, 2, 2, 3], true);\n   * // => [1, 2, 3]\n   *\n   * _.uniq([1, 2, 1.5, 3, 2.5], function(num) { return Math.floor(num); });\n   * // => [1, 2, 3]\n   *\n   * _.uniq([1, 2, 1.5, 3, 2.5], function(num) { return this.floor(num); }, Math);\n   * // => [1, 2, 3]\n   */\n  function uniq(array, isSorted, callback, thisArg) {\n    var index = -1,\n        length = array ? array.length : 0,\n        result = [],\n        seen = result;\n\n    // juggle arguments\n    if (typeof isSorted == 'function') {\n      thisArg = callback;\n      callback = isSorted;\n      isSorted = false;\n    }\n    // init value cache for large arrays\n    var isLarge = !isSorted && length > 74;\n    if (isLarge) {\n      var cache = {};\n    }\n    if (callback) {\n      seen = [];\n      callback = createCallback(callback, thisArg);\n    }\n    while (++index < length) {\n      var value = array[index],\n          computed = callback ? callback(value, index, array) : value;\n\n      if (isLarge) {\n        // manually coerce `computed` to a string because `hasOwnProperty`, in\n        // some older versions of Firefox, coerces objects incorrectly\n        seen = hasOwnProperty.call(cache, computed + '') ? cache[computed] : (cache[computed] = []);\n      }\n      if (isSorted\n            ? !index || seen[seen.length - 1] !== computed\n            : indexOf(seen, computed) < 0\n          ) {\n        if (callback || isLarge) {\n          seen.push(computed);\n        }\n        result.push(value);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Creates an array with all occurrences of the passed values removed using\n   * strict equality for comparisons, i.e. `===`.\n   *\n   * @static\n   * @memberOf _\n   * @category Arrays\n   * @param {Array} array The array to filter.\n   * @param {Mixed} [value1, value2, ...] Values to remove.\n   * @returns {Array} Returns a new filtered array.\n   * @example\n   *\n   * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);\n   * // => [2, 3, 4]\n   */\n  function without(array) {\n    var index = -1,\n        length = array ? array.length : 0,\n        contains = cachedContains(arguments, 1, 20),\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n      if (!contains(value)) {\n        result.push(value);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Groups the elements of each array at their corresponding indexes. Useful for\n   * separate data sources that are coordinated through matching array indexes.\n   * For a matrix of nested arrays, `_.zip.apply(...)` can transpose the matrix\n   * in a similar fashion.\n   *\n   * @static\n   * @memberOf _\n   * @category Arrays\n   * @param {Array} [array1, array2, ...] Arrays to process.\n   * @returns {Array} Returns a new array of grouped elements.\n   * @example\n   *\n   * _.zip(['moe', 'larry', 'curly'], [30, 40, 50], [true, false, false]);\n   * // => [['moe', 30, true], ['larry', 40, false], ['curly', 50, false]]\n   */\n  function zip(array) {\n    var index = -1,\n        length = array ? max(pluck(arguments, 'length')) : 0,\n        result = Array(length);\n\n    while (++index < length) {\n      result[index] = pluck(arguments, index);\n    }\n    return result;\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Creates a function that is restricted to executing `func` only after it is\n   * called `n` times. The `func` is executed with the `this` binding of the\n   * created function.\n   *\n   * @static\n   * @memberOf _\n   * @category Functions\n   * @param {Number} n The number of times the function must be called before\n   * it is executed.\n   * @param {Function} func The function to restrict.\n   * @returns {Function} Returns the new restricted function.\n   * @example\n   *\n   * var renderNotes = _.after(notes.length, render);\n   * _.forEach(notes, function(note) {\n   *   note.asyncSave({ 'success': renderNotes });\n   * });\n   * // `renderNotes` is run once, after all notes have saved\n   */\n  function after(n, func) {\n    if (n < 1) {\n      return func();\n    }\n    return function() {\n      if (--n < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  }\n\n  /**\n   * Creates a function that, when called, invokes `func` with the `this`\n   * binding of `thisArg` and prepends any additional `bind` arguments to those\n   * passed to the bound function.\n   *\n   * @static\n   * @memberOf _\n   * @category Functions\n   * @param {Function} func The function to bind.\n   * @param {Mixed} [thisArg] The `this` binding of `func`.\n   * @param {Mixed} [arg1, arg2, ...] Arguments to be partially applied.\n   * @returns {Function} Returns the new bound function.\n   * @example\n   *\n   * var func = function(greeting) {\n   *   return greeting + ' ' + this.name;\n   * };\n   *\n   * func = _.bind(func, { 'name': 'moe' }, 'hi');\n   * func();\n   * // => 'hi moe'\n   */\n  function bind(func, thisArg) {\n    // use `Function#bind` if it exists and is fast\n    // (in V8 `Function#bind` is slower except when partially applied)\n    return isBindFast || (nativeBind && arguments.length > 2)\n      ? nativeBind.call.apply(nativeBind, arguments)\n      : createBound(func, thisArg, slice.call(arguments, 2));\n  }\n\n  /**\n   * Binds methods on `object` to `object`, overwriting the existing method.\n   * If no method names are provided, all the function properties of `object`\n   * will be bound.\n   *\n   * @static\n   * @memberOf _\n   * @category Functions\n   * @param {Object} object The object to bind and assign the bound methods to.\n   * @param {String} [methodName1, methodName2, ...] Method names on the object to bind.\n   * @returns {Object} Returns `object`.\n   * @example\n   *\n   * var buttonView = {\n   *  'label': 'lodash',\n   *  'onClick': function() { alert('clicked: ' + this.label); }\n   * };\n   *\n   * _.bindAll(buttonView);\n   * jQuery('#lodash_button').on('click', buttonView.onClick);\n   * // => When the button is clicked, `this.label` will have the correct value\n   */\n  function bindAll(object) {\n    var funcs = arguments,\n        index = funcs.length > 1 ? 0 : (funcs = functions(object), -1),\n        length = funcs.length;\n\n    while (++index < length) {\n      var key = funcs[index];\n      object[key] = bind(object[key], object);\n    }\n    return object;\n  }\n\n  /**\n   * Creates a function that is the composition of the passed functions,\n   * where each function consumes the return value of the function that follows.\n   * In math terms, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.\n   * Each function is executed with the `this` binding of the composed function.\n   *\n   * @static\n   * @memberOf _\n   * @category Functions\n   * @param {Function} [func1, func2, ...] Functions to compose.\n   * @returns {Function} Returns the new composed function.\n   * @example\n   *\n   * var greet = function(name) { return 'hi: ' + name; };\n   * var exclaim = function(statement) { return statement + '!'; };\n   * var welcome = _.compose(exclaim, greet);\n   * welcome('moe');\n   * // => 'hi: moe!'\n   */\n  function compose() {\n    var funcs = arguments;\n    return function() {\n      var args = arguments,\n          length = funcs.length;\n\n      while (length--) {\n        args = [funcs[length].apply(this, args)];\n      }\n      return args[0];\n    };\n  }\n\n  /**\n   * Creates a function that will delay the execution of `func` until after\n   * `wait` milliseconds have elapsed since the last time it was invoked. Pass\n   * `true` for `immediate` to cause debounce to invoke `func` on the leading,\n   * instead of the trailing, edge of the `wait` timeout. Subsequent calls to\n   * the debounced function will return the result of the last `func` call.\n   *\n   * @static\n   * @memberOf _\n   * @category Functions\n   * @param {Function} func The function to debounce.\n   * @param {Number} wait The number of milliseconds to delay.\n   * @param {Boolean} immediate A flag to indicate execution is on the leading\n   *  edge of the timeout.\n   * @returns {Function} Returns the new debounced function.\n   * @example\n   *\n   * var lazyLayout = _.debounce(calculateLayout, 300);\n   * jQuery(window).on('resize', lazyLayout);\n   */\n  function debounce(func, wait, immediate) {\n    var args,\n        result,\n        thisArg,\n        timeoutId;\n\n    function delayed() {\n      timeoutId = null;\n      if (!immediate) {\n        result = func.apply(thisArg, args);\n      }\n    }\n    return function() {\n      var isImmediate = immediate && !timeoutId;\n      args = arguments;\n      thisArg = this;\n\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(delayed, wait);\n\n      if (isImmediate) {\n        result = func.apply(thisArg, args);\n      }\n      return result;\n    };\n  }\n\n  /**\n   * Executes the `func` function after `wait` milliseconds. Additional arguments\n   * will be passed to `func` when it is invoked.\n   *\n   * @static\n   * @memberOf _\n   * @category Functions\n   * @param {Function} func The function to delay.\n   * @param {Number} wait The number of milliseconds to delay execution.\n   * @param {Mixed} [arg1, arg2, ...] Arguments to invoke the function with.\n   * @returns {Number} Returns the `setTimeout` timeout id.\n   * @example\n   *\n   * var log = _.bind(console.log, console);\n   * _.delay(log, 1000, 'logged later');\n   * // => 'logged later' (Appears after one second.)\n   */\n  function delay(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function() { func.apply(undefined, args); }, wait);\n  }\n\n  /**\n   * Defers executing the `func` function until the current call stack has cleared.\n   * Additional arguments will be passed to `func` when it is invoked.\n   *\n   * @static\n   * @memberOf _\n   * @category Functions\n   * @param {Function} func The function to defer.\n   * @param {Mixed} [arg1, arg2, ...] Arguments to invoke the function with.\n   * @returns {Number} Returns the `setTimeout` timeout id.\n   * @example\n   *\n   * _.defer(function() { alert('deferred'); });\n   * // returns from the function before `alert` is called\n   */\n  function defer(func) {\n    var args = slice.call(arguments, 1);\n    return setTimeout(function() { func.apply(undefined, args); }, 1);\n  }\n\n  /**\n   * Creates a function that, when called, invokes `object[methodName]` and\n   * prepends any additional `lateBind` arguments to those passed to the bound\n   * function. This method differs from `_.bind` by allowing bound functions to\n   * reference methods that will be redefined or don't yet exist.\n   *\n   * @static\n   * @memberOf _\n   * @category Functions\n   * @param {Object} object The object the method belongs to.\n   * @param {String} methodName The method name.\n   * @param {Mixed} [arg1, arg2, ...] Arguments to be partially applied.\n   * @returns {Function} Returns the new bound function.\n   * @example\n   *\n   * var object = {\n   *   'name': 'moe',\n   *   'greet': function(greeting) {\n   *     return greeting + ' ' + this.name;\n   *   }\n   * };\n   *\n   * var func = _.lateBind(object, 'greet', 'hi');\n   * func();\n   * // => 'hi moe'\n   *\n   * object.greet = function(greeting) {\n   *   return greeting + ', ' + this.name + '!';\n   * };\n   *\n   * func();\n   * // => 'hi, moe!'\n   */\n  function lateBind(object, methodName) {\n    return createBound(methodName, object, slice.call(arguments, 2));\n  }\n\n  /**\n   * Creates a function that memoizes the result of `func`. If `resolver` is\n   * passed, it will be used to determine the cache key for storing the result\n   * based on the arguments passed to the memoized function. By default, the first\n   * argument passed to the memoized function is used as the cache key. The `func`\n   * is executed with the `this` binding of the memoized function.\n   *\n   * @static\n   * @memberOf _\n   * @category Functions\n   * @param {Function} func The function to have its output memoized.\n   * @param {Function} [resolver] A function used to resolve the cache key.\n   * @returns {Function} Returns the new memoizing function.\n   * @example\n   *\n   * var fibonacci = _.memoize(function(n) {\n   *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);\n   * });\n   */\n  function memoize(func, resolver) {\n    var cache = {};\n    return function() {\n      var key = resolver ? resolver.apply(this, arguments) : arguments[0];\n      return hasOwnProperty.call(cache, key)\n        ? cache[key]\n        : (cache[key] = func.apply(this, arguments));\n    };\n  }\n\n  /**\n   * Creates a function that is restricted to execute `func` once. Repeat calls to\n   * the function will return the value of the first call. The `func` is executed\n   * with the `this` binding of the created function.\n   *\n   * @static\n   * @memberOf _\n   * @category Functions\n   * @param {Function} func The function to restrict.\n   * @returns {Function} Returns the new restricted function.\n   * @example\n   *\n   * var initialize = _.once(createApplication);\n   * initialize();\n   * initialize();\n   * // Application is only created once.\n   */\n  function once(func) {\n    var result,\n        ran = false;\n\n    return function() {\n      if (ran) {\n        return result;\n      }\n      ran = true;\n      result = func.apply(this, arguments);\n\n      // clear the `func` variable so the function may be garbage collected\n      func = null;\n      return result;\n    };\n  }\n\n  /**\n   * Creates a function that, when called, invokes `func` with any additional\n   * `partial` arguments prepended to those passed to the new function. This\n   * method is similar to `bind`, except it does **not** alter the `this` binding.\n   *\n   * @static\n   * @memberOf _\n   * @category Functions\n   * @param {Function} func The function to partially apply arguments to.\n   * @param {Mixed} [arg1, arg2, ...] Arguments to be partially applied.\n   * @returns {Function} Returns the new partially applied function.\n   * @example\n   *\n   * var greet = function(greeting, name) { return greeting + ': ' + name; };\n   * var hi = _.partial(greet, 'hi');\n   * hi('moe');\n   * // => 'hi: moe'\n   */\n  function partial(func) {\n    return createBound(func, slice.call(arguments, 1));\n  }\n\n  /**\n   * Creates a function that, when executed, will only call the `func`\n   * function at most once per every `wait` milliseconds. If the throttled\n   * function is invoked more than once during the `wait` timeout, `func` will\n   * also be called on the trailing edge of the timeout. Subsequent calls to the\n   * throttled function will return the result of the last `func` call.\n   *\n   * @static\n   * @memberOf _\n   * @category Functions\n   * @param {Function} func The function to throttle.\n   * @param {Number} wait The number of milliseconds to throttle executions to.\n   * @returns {Function} Returns the new throttled function.\n   * @example\n   *\n   * var throttled = _.throttle(updatePosition, 100);\n   * jQuery(window).on('scroll', throttled);\n   */\n  function throttle(func, wait) {\n    var args,\n        result,\n        thisArg,\n        timeoutId,\n        lastCalled = 0;\n\n    function trailingCall() {\n      lastCalled = new Date;\n      timeoutId = null;\n      result = func.apply(thisArg, args);\n    }\n    return function() {\n      var now = new Date,\n          remaining = wait - (now - lastCalled);\n\n      args = arguments;\n      thisArg = this;\n\n      if (remaining <= 0) {\n        clearTimeout(timeoutId);\n        lastCalled = now;\n        result = func.apply(thisArg, args);\n      }\n      else if (!timeoutId) {\n        timeoutId = setTimeout(trailingCall, remaining);\n      }\n      return result;\n    };\n  }\n\n  /**\n   * Creates a function that passes `value` to the `wrapper` function as its\n   * first argument. Additional arguments passed to the function are appended\n   * to those passed to the `wrapper` function. The `wrapper` is executed with\n   * the `this` binding of the created function.\n   *\n   * @static\n   * @memberOf _\n   * @category Functions\n   * @param {Mixed} value The value to wrap.\n   * @param {Function} wrapper The wrapper function.\n   * @returns {Function} Returns the new function.\n   * @example\n   *\n   * var hello = function(name) { return 'hello ' + name; };\n   * hello = _.wrap(hello, function(func) {\n   *   return 'before, ' + func('moe') + ', after';\n   * });\n   * hello();\n   * // => 'before, hello moe, after'\n   */\n  function wrap(value, wrapper) {\n    return function() {\n      var args = [value];\n      push.apply(args, arguments);\n      return wrapper.apply(this, args);\n    };\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Converts the characters `&`, `<`, `>`, `\"`, and `'` in `string` to their\n   * corresponding HTML entities.\n   *\n   * @static\n   * @memberOf _\n   * @category Utilities\n   * @param {String} string The string to escape.\n   * @returns {String} Returns the escaped string.\n   * @example\n   *\n   * _.escape('Moe, Larry & Curly');\n   * // => \"Moe, Larry &amp; Curly\"\n   */\n  function escape(string) {\n    return string == null ? '' : (string + '').replace(reUnescapedHtml, escapeHtmlChar);\n  }\n\n  /**\n   * This function returns the first argument passed to it.\n   *\n   * Note: It is used throughout Lo-Dash as a default callback.\n   *\n   * @static\n   * @memberOf _\n   * @category Utilities\n   * @param {Mixed} value Any value.\n   * @returns {Mixed} Returns `value`.\n   * @example\n   *\n   * var moe = { 'name': 'moe' };\n   * moe === _.identity(moe);\n   * // => true\n   */\n  function identity(value) {\n    return value;\n  }\n\n  /**\n   * Adds functions properties of `object` to the `lodash` function and chainable\n   * wrapper.\n   *\n   * @static\n   * @memberOf _\n   * @category Utilities\n   * @param {Object} object The object of function properties to add to `lodash`.\n   * @example\n   *\n   * _.mixin({\n   *   'capitalize': function(string) {\n   *     return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();\n   *   }\n   * });\n   *\n   * _.capitalize('larry');\n   * // => 'Larry'\n   *\n   * _('curly').capitalize();\n   * // => 'Curly'\n   */\n  function mixin(object) {\n    forEach(functions(object), function(methodName) {\n      var func = lodash[methodName] = object[methodName];\n\n      lodash.prototype[methodName] = function() {\n        var args = [this.__wrapped__];\n        push.apply(args, arguments);\n\n        var result = func.apply(lodash, args);\n        if (this.__chain__) {\n          result = new lodash(result);\n          result.__chain__ = true;\n        }\n        return result;\n      };\n    });\n  }\n\n  /**\n   * Reverts the '_' variable to its previous value and returns a reference to\n   * the `lodash` function.\n   *\n   * @static\n   * @memberOf _\n   * @category Utilities\n   * @returns {Function} Returns the `lodash` function.\n   * @example\n   *\n   * var lodash = _.noConflict();\n   */\n  function noConflict() {\n    window._ = oldDash;\n    return this;\n  }\n\n  /**\n   * Produces a random number between `min` and `max` (inclusive). If only one\n   * argument is passed, a number between `0` and the given number will be returned.\n   *\n   * @static\n   * @memberOf _\n   * @category Utilities\n   * @param {Number} [min=0] The minimum possible value.\n   * @param {Number} [max=1] The maximum possible value.\n   * @returns {Number} Returns a random number.\n   * @example\n   *\n   * _.random(0, 5);\n   * // => a number between 1 and 5\n   *\n   * _.random(5);\n   * // => also a number between 1 and 5\n   */\n  function random(min, max) {\n    if (min == null && max == null) {\n      max = 1;\n    }\n    min = +min || 0;\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + floor(nativeRandom() * ((+max || 0) - min + 1));\n  }\n\n  /**\n   * Resolves the value of `property` on `object`. If `property` is a function\n   * it will be invoked and its result returned, else the property value is\n   * returned. If `object` is falsey, then `null` is returned.\n   *\n   * @deprecated\n   * @static\n   * @memberOf _\n   * @category Utilities\n   * @param {Object} object The object to inspect.\n   * @param {String} property The property to get the value of.\n   * @returns {Mixed} Returns the resolved value.\n   * @example\n   *\n   * var object = {\n   *   'cheese': 'crumpets',\n   *   'stuff': function() {\n   *     return 'nonsense';\n   *   }\n   * };\n   *\n   * _.result(object, 'cheese');\n   * // => 'crumpets'\n   *\n   * _.result(object, 'stuff');\n   * // => 'nonsense'\n   */\n  function result(object, property) {\n    // based on Backbone's private `getValue` function\n    // https://github.com/documentcloud/backbone/blob/0.9.2/backbone.js#L1419-1424\n    var value = object ? object[property] : null;\n    return isFunction(value) ? object[property]() : value;\n  }\n\n  /**\n   * A micro-templating method that handles arbitrary delimiters, preserves\n   * whitespace, and correctly escapes quotes within interpolated code.\n   *\n   * Note: In the development build `_.template` utilizes sourceURLs for easier\n   * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl\n   *\n   * Note: Lo-Dash may be used in Chrome extensions by either creating a `lodash csp`\n   * build and avoiding `_.template` use, or loading Lo-Dash in a sandboxed page.\n   * See http://developer.chrome.com/trunk/extensions/sandboxingEval.html\n   *\n   * @static\n   * @memberOf _\n   * @category Utilities\n   * @param {String} text The template text.\n   * @param {Obect} data The data object used to populate the text.\n   * @param {Object} options The options object.\n   *  escape - The \"escape\" delimiter regexp.\n   *  evaluate - The \"evaluate\" delimiter regexp.\n   *  interpolate - The \"interpolate\" delimiter regexp.\n   *  sourceURL - The sourceURL of the template's compiled source.\n   *  variable - The data object variable name.\n   *\n   * @returns {Function|String} Returns a compiled function when no `data` object\n   *  is given, else it returns the interpolated text.\n   * @example\n   *\n   * // using a compiled template\n   * var compiled = _.template('hello <%= name %>');\n   * compiled({ 'name': 'moe' });\n   * // => 'hello moe'\n   *\n   * var list = '<% _.forEach(people, function(name) { %><li><%= name %></li><% }); %>';\n   * _.template(list, { 'people': ['moe', 'larry', 'curly'] });\n   * // => '<li>moe</li><li>larry</li><li>curly</li>'\n   *\n   * // using the \"escape\" delimiter to escape HTML in data property values\n   * _.template('<b><%- value %></b>', { 'value': '<script>' });\n   * // => '<b>&lt;script&gt;</b>'\n   *\n   * // using the ES6 delimiter as an alternative to the default \"interpolate\" delimiter\n   * _.template('hello ${ name }', { 'name': 'curly' });\n   * // => 'hello curly'\n   *\n   * // using the internal `print` function in \"evaluate\" delimiters\n   * _.template('<% print(\"hello \" + epithet); %>!', { 'epithet': 'stooge' });\n   * // => 'hello stooge!'\n   *\n   * // using custom template delimiters\n   * _.templateSettings = {\n   *   'interpolate': /{{([\\s\\S]+?)}}/g\n   * };\n   *\n   * _.template('hello {{ name }}!', { 'name': 'mustache' });\n   * // => 'hello mustache!'\n   *\n   * // using the `sourceURL` option to specify a custom sourceURL for the template\n   * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });\n   * compiled(data);\n   * // => find the source of \"greeting.jst\" under the Sources tab or Resources panel of the web inspector\n   *\n   * // using the `variable` option to ensure a with-statement isn't used in the compiled template\n   * var compiled = _.template('hello <%= data.name %>!', null, { 'variable': 'data' });\n   * compiled.source;\n   * // => function(data) {\n   *   var __t, __p = '', __e = _.escape;\n   *   __p += 'hello ' + ((__t = ( data.name )) == null ? '' : __t) + '!';\n   *   return __p;\n   * }\n   *\n   * // using the `source` property to inline compiled templates for meaningful\n   * // line numbers in error messages and a stack trace\n   * fs.writeFileSync(path.join(cwd, 'jst.js'), '\\\n   *   var JST = {\\\n   *     \"main\": ' + _.template(mainText).source + '\\\n   *   };\\\n   * ');\n   */\n  function template(text, data, options) {\n    // based on John Resig's `tmpl` implementation\n    // http://ejohn.org/blog/javascript-micro-templating/\n    // and Laura Doktorova's doT.js\n    // https://github.com/olado/doT\n    text || (text = '');\n    options || (options = {});\n\n    var isEvaluating,\n        result,\n        settings = lodash.templateSettings,\n        index = 0,\n        interpolate = options.interpolate || settings.interpolate || reNoMatch,\n        source = \"__p += '\",\n        variable = options.variable || settings.variable,\n        hasVariable = variable;\n\n    // compile regexp to match each delimiter\n    var reDelimiters = RegExp(\n      (options.escape || settings.escape || reNoMatch).source + '|' +\n      interpolate.source + '|' +\n      (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +\n      (options.evaluate || settings.evaluate || reNoMatch).source + '|$'\n    , 'g');\n\n    text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {\n      interpolateValue || (interpolateValue = esTemplateValue);\n\n      // escape characters that cannot be included in string literals\n      source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);\n\n      // replace delimiters with snippets\n      source +=\n        escapeValue ? \"' +\\n__e(\" + escapeValue + \") +\\n'\" :\n        evaluateValue ? \"';\\n\" + evaluateValue + \";\\n__p += '\" :\n        interpolateValue ? \"' +\\n((__t = (\" + interpolateValue + \")) == null ? '' : __t) +\\n'\" : '';\n\n      isEvaluating || (isEvaluating = evaluateValue || reComplexDelimiter.test(escapeValue || interpolateValue));\n      index = offset + match.length;\n    });\n\n    source += \"';\\n\";\n\n    // if `variable` is not specified and the template contains \"evaluate\"\n    // delimiters, wrap a with-statement around the generated code to add the\n    // data object to the top of the scope chain\n    if (!hasVariable) {\n      variable = 'obj';\n      if (isEvaluating) {\n        source = 'with (' + variable + ') {\\n' + source + '\\n}\\n';\n      }\n      else {\n        // avoid a with-statement by prepending data object references to property names\n        var reDoubleVariable = RegExp('(\\\\(\\\\s*)' + variable + '\\\\.' + variable + '\\\\b', 'g');\n        source = source\n          .replace(reInsertVariable, '$&' + variable + '.')\n          .replace(reDoubleVariable, '$1__d');\n      }\n    }\n\n    // cleanup code by stripping empty strings\n    source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)\n      .replace(reEmptyStringMiddle, '$1')\n      .replace(reEmptyStringTrailing, '$1;');\n\n    // frame code as the function body\n    source = 'function(' + variable + ') {\\n' +\n      (hasVariable ? '' : variable + ' || (' + variable + ' = {});\\n') +\n      'var __t, __p = \\'\\', __e = _.escape' +\n      (isEvaluating\n        ? ', __j = Array.prototype.join;\\n' +\n          'function print() { __p += __j.call(arguments, \\'\\') }\\n'\n        : (hasVariable ? '' : ', __d = ' + variable + '.' + variable + ' || ' + variable) + ';\\n'\n      ) +\n      source +\n      'return __p\\n}';\n\n    // use a sourceURL for easier debugging\n    // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl\n    var sourceURL = useSourceURL\n      ? '\\n//@ sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']')\n      : '';\n\n    try {\n      result = Function('_', 'return ' + source + sourceURL)(lodash);\n    } catch(e) {\n      e.source = source;\n      throw e;\n    }\n\n    if (data) {\n      return result(data);\n    }\n    // provide the compiled function's source via its `toString` method, in\n    // supported environments, or the `source` property as a convenience for\n    // inlining compiled templates during the build process\n    result.source = source;\n    return result;\n  }\n\n  /**\n   * Executes the `callback` function `n` times, returning an array of the results\n   * of each `callback` execution. The `callback` is bound to `thisArg` and invoked\n   * with one argument; (index).\n   *\n   * @static\n   * @memberOf _\n   * @category Utilities\n   * @param {Number} n The number of times to execute the callback.\n   * @param {Function} callback The function called per iteration.\n   * @param {Mixed} [thisArg] The `this` binding of `callback`.\n   * @returns {Array} Returns a new array of the results of each `callback` execution.\n   * @example\n   *\n   * var diceRolls = _.times(3, _.partial(_.random, 1, 6));\n   * // => [3, 6, 4]\n   *\n   * _.times(3, function(n) { mage.castSpell(n); });\n   * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively\n   *\n   * _.times(3, function(n) { this.cast(n); }, mage);\n   * // => also calls `mage.castSpell(n)` three times\n   */\n  function times(n, callback, thisArg) {\n    n = +n || 0;\n    var index = -1,\n        result = Array(n);\n\n    while (++index < n) {\n      result[index] = callback.call(thisArg, index);\n    }\n    return result;\n  }\n\n  /**\n   * The opposite of `_.escape`, this method converts the HTML entities\n   * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#x27;` in `string` to their\n   * corresponding characters.\n   *\n   * @static\n   * @memberOf _\n   * @category Utilities\n   * @param {String} string The string to unescape.\n   * @returns {String} Returns the unescaped string.\n   * @example\n   *\n   * _.unescape('Moe, Larry &amp; Curly');\n   * // => \"Moe, Larry & Curly\"\n   */\n  function unescape(string) {\n    return string == null ? '' : (string + '').replace(reEscapedHtml, unescapeHtmlChar);\n  }\n\n  /**\n   * Generates a unique id. If `prefix` is passed, the id will be appended to it.\n   *\n   * @static\n   * @memberOf _\n   * @category Utilities\n   * @param {String} [prefix] The value to prefix the id with.\n   * @returns {Number|String} Returns a numeric id if no prefix is passed, else\n   *  a string id may be returned.\n   * @example\n   *\n   * _.uniqueId('contact_');\n   * // => 'contact_104'\n   */\n  function uniqueId(prefix) {\n    var id = idCounter++;\n    return prefix ? prefix + id : id;\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Wraps the value in a `lodash` wrapper object.\n   *\n   * @static\n   * @memberOf _\n   * @category Chaining\n   * @param {Mixed} value The value to wrap.\n   * @returns {Object} Returns the wrapper object.\n   * @example\n   *\n   * var stooges = [\n   *   { 'name': 'moe', 'age': 40 },\n   *   { 'name': 'larry', 'age': 50 },\n   *   { 'name': 'curly', 'age': 60 }\n   * ];\n   *\n   * var youngest = _.chain(stooges)\n   *     .sortBy(function(stooge) { return stooge.age; })\n   *     .map(function(stooge) { return stooge.name + ' is ' + stooge.age; })\n   *     .first()\n   *     .value();\n   * // => 'moe is 40'\n   */\n  function chain(value) {\n    value = new lodash(value);\n    value.__chain__ = true;\n    return value;\n  }\n\n  /**\n   * Invokes `interceptor` with the `value` as the first argument, and then\n   * returns `value`. The purpose of this method is to \"tap into\" a method chain,\n   * in order to perform operations on intermediate results within the chain.\n   *\n   * @static\n   * @memberOf _\n   * @category Chaining\n   * @param {Mixed} value The value to pass to `interceptor`.\n   * @param {Function} interceptor The function to invoke.\n   * @returns {Mixed} Returns `value`.\n   * @example\n   *\n   * _.chain([1, 2, 3, 200])\n   *  .filter(function(num) { return num % 2 == 0; })\n   *  .tap(alert)\n   *  .map(function(num) { return num * num })\n   *  .value();\n   * // => // [2, 200] (alerted)\n   * // => [4, 40000]\n   */\n  function tap(value, interceptor) {\n    interceptor(value);\n    return value;\n  }\n\n  /**\n   * Enables method chaining on the wrapper object.\n   *\n   * @name chain\n   * @deprecated\n   * @memberOf _\n   * @category Chaining\n   * @returns {Mixed} Returns the wrapper object.\n   * @example\n   *\n   * _([1, 2, 3]).value();\n   * // => [1, 2, 3]\n   */\n  function wrapperChain() {\n    this.__chain__ = true;\n    return this;\n  }\n\n  /**\n   * Extracts the wrapped value.\n   *\n   * @name value\n   * @memberOf _\n   * @category Chaining\n   * @returns {Mixed} Returns the wrapped value.\n   * @example\n   *\n   * _([1, 2, 3]).value();\n   * // => [1, 2, 3]\n   */\n  function wrapperValue() {\n    return this.__wrapped__;\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * The semantic version number.\n   *\n   * @static\n   * @memberOf _\n   * @type String\n   */\n  lodash.VERSION = '0.9.2';\n\n  // assign static methods\n  lodash.after = after;\n  lodash.bind = bind;\n  lodash.bindAll = bindAll;\n  lodash.chain = chain;\n  lodash.clone = clone;\n  lodash.compact = compact;\n  lodash.compose = compose;\n  lodash.contains = contains;\n  lodash.countBy = countBy;\n  lodash.debounce = debounce;\n  lodash.defaults = defaults;\n  lodash.defer = defer;\n  lodash.delay = delay;\n  lodash.difference = difference;\n  lodash.escape = escape;\n  lodash.every = every;\n  lodash.extend = extend;\n  lodash.filter = filter;\n  lodash.find = find;\n  lodash.first = first;\n  lodash.flatten = flatten;\n  lodash.forEach = forEach;\n  lodash.forIn = forIn;\n  lodash.forOwn = forOwn;\n  lodash.functions = functions;\n  lodash.groupBy = groupBy;\n  lodash.has = has;\n  lodash.identity = identity;\n  lodash.indexOf = indexOf;\n  lodash.initial = initial;\n  lodash.intersection = intersection;\n  lodash.invert = invert;\n  lodash.invoke = invoke;\n  lodash.isArguments = isArguments;\n  lodash.isArray = isArray;\n  lodash.isBoolean = isBoolean;\n  lodash.isDate = isDate;\n  lodash.isElement = isElement;\n  lodash.isEmpty = isEmpty;\n  lodash.isEqual = isEqual;\n  lodash.isFinite = isFinite;\n  lodash.isFunction = isFunction;\n  lodash.isNaN = isNaN;\n  lodash.isNull = isNull;\n  lodash.isNumber = isNumber;\n  lodash.isObject = isObject;\n  lodash.isPlainObject = isPlainObject;\n  lodash.isRegExp = isRegExp;\n  lodash.isString = isString;\n  lodash.isUndefined = isUndefined;\n  lodash.keys = keys;\n  lodash.last = last;\n  lodash.lastIndexOf = lastIndexOf;\n  lodash.lateBind = lateBind;\n  lodash.map = map;\n  lodash.max = max;\n  lodash.memoize = memoize;\n  lodash.merge = merge;\n  lodash.min = min;\n  lodash.mixin = mixin;\n  lodash.noConflict = noConflict;\n  lodash.object = object;\n  lodash.omit = omit;\n  lodash.once = once;\n  lodash.pairs = pairs;\n  lodash.partial = partial;\n  lodash.pick = pick;\n  lodash.pluck = pluck;\n  lodash.random = random;\n  lodash.range = range;\n  lodash.reduce = reduce;\n  lodash.reduceRight = reduceRight;\n  lodash.reject = reject;\n  lodash.rest = rest;\n  lodash.result = result;\n  lodash.shuffle = shuffle;\n  lodash.size = size;\n  lodash.some = some;\n  lodash.sortBy = sortBy;\n  lodash.sortedIndex = sortedIndex;\n  lodash.tap = tap;\n  lodash.template = template;\n  lodash.throttle = throttle;\n  lodash.times = times;\n  lodash.toArray = toArray;\n  lodash.unescape = unescape;\n  lodash.union = union;\n  lodash.uniq = uniq;\n  lodash.uniqueId = uniqueId;\n  lodash.values = values;\n  lodash.where = where;\n  lodash.without = without;\n  lodash.wrap = wrap;\n  lodash.zip = zip;\n\n  // assign aliases\n  lodash.all = every;\n  lodash.any = some;\n  lodash.collect = map;\n  lodash.detect = find;\n  lodash.drop = rest;\n  lodash.each = forEach;\n  lodash.foldl = reduce;\n  lodash.foldr = reduceRight;\n  lodash.head = first;\n  lodash.include = contains;\n  lodash.inject = reduce;\n  lodash.methods = functions;\n  lodash.select = filter;\n  lodash.tail = rest;\n  lodash.take = first;\n  lodash.unique = uniq;\n\n  // add pseudo private property to be used and removed during the build process\n  lodash._iteratorTemplate = iteratorTemplate;\n\n  /*--------------------------------------------------------------------------*/\n\n  // add all static functions to `lodash.prototype`\n  mixin(lodash);\n\n  // add `lodash.prototype.chain` after calling `mixin()` to avoid overwriting\n  // it with the wrapped `lodash.chain`\n  lodash.prototype.chain = wrapperChain;\n  lodash.prototype.value = wrapperValue;\n\n  // add all mutator Array functions to the wrapper.\n  forEach(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {\n    var func = arrayRef[methodName];\n\n    lodash.prototype[methodName] = function() {\n      var value = this.__wrapped__;\n      func.apply(value, arguments);\n\n      // avoid array-like object bugs with `Array#shift` and `Array#splice` in\n      // Firefox < 10 and IE < 9\n      if (hasObjectSpliceBug && value.length === 0) {\n        delete value[0];\n      }\n      if (this.__chain__) {\n        value = new lodash(value);\n        value.__chain__ = true;\n      }\n      return value;\n    };\n  });\n\n  // add all accessor Array functions to the wrapper.\n  forEach(['concat', 'join', 'slice'], function(methodName) {\n    var func = arrayRef[methodName];\n\n    lodash.prototype[methodName] = function() {\n      var value = this.__wrapped__,\n          result = func.apply(value, arguments);\n\n      if (this.__chain__) {\n        result = new lodash(result);\n        result.__chain__ = true;\n      }\n      return result;\n    };\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  // expose Lo-Dash\n  // some AMD build optimizers, like r.js, check for specific condition patterns like the following:\n  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\n    // Expose Lo-Dash to the global object even when an AMD loader is present in\n    // case Lo-Dash was injected by a third-party script and not intended to be\n    // loaded as a module. The global assignment can be reverted in the Lo-Dash\n    // module via its `noConflict()` method.\n    window._ = lodash;\n\n    // define as an anonymous module so, through path mapping, it can be\n    // referenced as the \"underscore\" module\n    define(function() {\n      return lodash;\n    });\n  }\n  // check for `exports` after `define` in case a build optimizer adds an `exports` object\n  else if (freeExports) {\n    // in Node.js or RingoJS v0.8.0+\n    if (typeof module == 'object' && module && module.exports == freeExports) {\n      (module.exports = lodash)._ = lodash;\n    }\n    // in Narwhal or RingoJS v0.7.0-\n    else {\n      freeExports._ = lodash;\n    }\n  }\n  else {\n    // in a browser or Rhino\n    window._ = lodash;\n  }\n}(this));\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/**\n * Copyright 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warning = function() {};\n\nif (process.env.NODE_ENV !== 'production') {\n  warning = function(condition, format, args) {\n    var len = arguments.length;\n    args = new Array(len > 2 ? len - 2 : 0);\n    for (var key = 2; key < len; key++) {\n      args[key - 2] = arguments[key];\n    }\n    if (format === undefined) {\n      throw new Error(\n        '`warning(condition, format, ...args)` requires a warning ' +\n        'message argument'\n      );\n    }\n\n    if (format.length < 10 || (/^[s\\W]*$/).test(format)) {\n      throw new Error(\n        'The warning format should be able to uniquely identify this ' +\n        'warning. Please, use a more descriptive format than: ' + format\n      );\n    }\n\n    if (!condition) {\n      var argIndex = 0;\n      var message = 'Warning: ' +\n        format.replace(/%s/g, function() {\n          return args[argIndex++];\n        });\n      if (typeof console !== 'undefined') {\n        console.error(message);\n      }\n      try {\n        // This error was thrown as a convenience so that you can use this stack\n        // to find the callsite that caused this warning to fire.\n        throw new Error(message);\n      } catch(x) {}\n    }\n  };\n}\n\nmodule.exports = warning;\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJhcHAvYWN0aW9ucy9Mb2dpbkFjdGlvbnMuanMiLCJhcHAvYWN0aW9ucy9OYXZiYXJBY3Rpb25zLmpzIiwiYXBwL2FjdGlvbnMvU2lnblVwQWN0aW9ucy5qcyIsImFwcC9hbHQuanMiLCJhcHAvY29tcG9uZW50cy9BeGlvbVNjaS5qcyIsImFwcC9jb21wb25lbnRzL0Zvb3Rlci5qcyIsImFwcC9jb21wb25lbnRzL0hvbWUuanMiLCJhcHAvY29tcG9uZW50cy9Mb2dpbi5qcyIsImFwcC9jb21wb25lbnRzL05hdmJhci5qcyIsImFwcC9jb21wb25lbnRzL1NpZ25VcC5qcyIsImFwcC9tYWluLmpzIiwiYXBwL3JvdXRlcy5qcyIsImFwcC9zdG9yZXMvTG9naW5TdG9yZS5qcyIsImFwcC9zdG9yZXMvTmF2YmFyU3RvcmUuanMiLCJhcHAvc3RvcmVzL1NpZ25VcFN0b3JlLmpzIiwibm9kZV9tb2R1bGVzL2RlZXAtZXF1YWwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZGVlcC1lcXVhbC9saWIvaXNfYXJndW1lbnRzLmpzIiwibm9kZV9tb2R1bGVzL2RlZXAtZXF1YWwvbGliL2tleXMuanMiLCJub2RlX21vZHVsZXMvaGlzdG9yeS9saWIvQWN0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9oaXN0b3J5L2xpYi9Bc3luY1V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2hpc3RvcnkvbGliL0RPTVN0YXRlU3RvcmFnZS5qcyIsIm5vZGVfbW9kdWxlcy9oaXN0b3J5L2xpYi9ET01VdGlscy5qcyIsIm5vZGVfbW9kdWxlcy9oaXN0b3J5L2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudC5qcyIsIm5vZGVfbW9kdWxlcy9oaXN0b3J5L2xpYi9jcmVhdGVCcm93c2VySGlzdG9yeS5qcyIsIm5vZGVfbW9kdWxlcy9oaXN0b3J5L2xpYi9jcmVhdGVET01IaXN0b3J5LmpzIiwibm9kZV9tb2R1bGVzL2hpc3RvcnkvbGliL2NyZWF0ZUhpc3RvcnkuanMiLCJub2RlX21vZHVsZXMvaGlzdG9yeS9saWIvY3JlYXRlTG9jYXRpb24uanMiLCJub2RlX21vZHVsZXMvaGlzdG9yeS9saWIvZGVwcmVjYXRlLmpzIiwibm9kZV9tb2R1bGVzL2hpc3RvcnkvbGliL2V4dHJhY3RQYXRoLmpzIiwibm9kZV9tb2R1bGVzL2hpc3RvcnkvbGliL3BhcnNlUGF0aC5qcyIsIm5vZGVfbW9kdWxlcy9oaXN0b3J5L2xpYi9ydW5UcmFuc2l0aW9uSG9vay5qcyIsIm5vZGVfbW9kdWxlcy9pbnZhcmlhbnQvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvbG9kYXNoLmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy93YXJuaW5nL2Jyb3dzZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7OztBQ0FBOzs7O0FBQ0E7Ozs7Ozs7O0lBQ00sWTtBQUVMLHlCQUNBO0FBQUE7O0FBQ0MsT0FBSyxlQUFMLENBQ0MsWUFERDtBQUdBOzs7OzRCQUVTLEksRUFDVjtBQUNDLEtBQUUsSUFBRixDQUNBO0FBQ0MsVUFBTSxNQURQO0FBRUMsU0FBSyxRQUZOO0FBR0MsVUFBTSxJQUhQO0FBSUMsYUFBUztBQUpWLElBREE7QUFPQTs7Ozs7O0FBR0YsSUFBSSxlQUFlLFNBQWYsWUFBZSxDQUFTLElBQVQsRUFDbkI7QUFDQyxTQUFRLEdBQVIsQ0FBWSxJQUFaO0FBQ0EsY0FBYSxPQUFiLENBQXFCLE1BQXJCLEVBQTZCLEtBQUssU0FBTCxDQUFlLElBQWYsQ0FBN0I7QUFDQSxTQUFRLEdBQVIsQ0FBWSxLQUFLLEtBQWpCO0FBQ0EsU0FBUSxHQUFSLENBQVksS0FBSyxLQUFMLENBQVcsYUFBYSxJQUF4QixFQUE4QixLQUExQztBQUNBLFVBQVMsSUFBVCxHQUFnQixHQUFoQjtBQUNBLENBUEQ7O2tCQVNlLGNBQUksYUFBSixDQUFrQixZQUFsQixDOzs7Ozs7Ozs7QUNoQ2Y7Ozs7QUFDQTs7Ozs7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OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDakxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNscUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgYWx0IGZyb20gJy4uL2FsdCdcbmNsYXNzIExvZ2luQWN0aW9uc1xue1xuXHRjb25zdHJ1Y3RvcigpXG5cdHtcblx0XHR0aGlzLmdlbmVyYXRlQWN0aW9ucyhcblx0XHRcdCd1cGRhdGVVc2VyJ1xuXHRcdClcblx0fVxuXG5cdGxvZ2luVXNlcih1c2VyKVxuXHR7XG5cdFx0JC5hamF4KFxuXHRcdHtcblx0XHRcdHR5cGU6ICdQT1NUJyxcblx0XHRcdHVybDogJy9sb2dpbicsXG5cdFx0XHRkYXRhOiB1c2VyLFxuXHRcdFx0c3VjY2VzczogbG9naW5TdWNjZXNzXG5cdFx0fSlcblx0fVxufVxuXG52YXIgbG9naW5TdWNjZXNzID0gZnVuY3Rpb24oZGF0YSlcbntcblx0Y29uc29sZS5sb2coZGF0YSlcblx0bG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJ1c2VyXCIsIEpTT04uc3RyaW5naWZ5KGRhdGEpKVxuXHRjb25zb2xlLmxvZyhkYXRhLmVtYWlsKVxuXHRjb25zb2xlLmxvZyhKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS51c2VyKS5lbWFpbClcblx0bG9jYXRpb24uaHJlZiA9ICcvJ1xufVxuXG5leHBvcnQgZGVmYXVsdCBhbHQuY3JlYXRlQWN0aW9ucyhMb2dpbkFjdGlvbnMpIiwiaW1wb3J0IGFsdCBmcm9tICcuLi9hbHQnXG5pbXBvcnQge2Fzc2lnbn0gZnJvbSAnbG9kYXNoJ1xuXG5jbGFzcyBOYXZiYXJBY3Rpb25zXG57XG5cdGNvbnN0cnVjdG9yKClcblx0e1xuXHRcdHRoaXMuZ2VuZXJhdGVBY3Rpb25zKFxuXHRcdFx0J3VwZGF0ZVNob3BwaW5nQ2FydCcsXG5cdFx0XHQndXBkYXRlU2VhY2hRdWVyeScsXG5cdFx0KVxuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFsdC5jcmVhdGVBY3Rpb25zKE5hdmJhckFjdGlvbnMpIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IGFsdCBmcm9tICcuLi9hbHQnXG5jbGFzcyBTaWduVXBBY3Rpb25zXG57XG5cdGNvbnN0cnVjdG9yKClcblx0e1xuXHRcdHRoaXMuZ2VuZXJhdGVBY3Rpb25zKFxuXHRcdFx0J3VwZGF0ZVVzZXInXG5cdFx0KVxuXHR9XG5cblx0Y3JlYXRlVXNlcih1c2VyKVxuXHR7XG5cdFx0JC5hamF4KFxuXHRcdHtcblx0XHRcdHR5cGU6ICdQT1NUJyxcblx0XHRcdHVybDogJy9hcGkvdXNlcnMnLFxuXHRcdFx0ZGF0YTogdXNlclxuXHRcdH0pXG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgYWx0LmNyZWF0ZUFjdGlvbnMoU2lnblVwQWN0aW9ucykiLCJpbXBvcnQgQWx0IGZyb20gJ2FsdCdcblxudmFyIGFsdCA9IG5ldyBBbHQoKVxuXG5leHBvcnQgZGVmYXVsdCBhbHQiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgTmF2YmFyIGZyb20gJy4vTmF2YmFyJ1xuaW1wb3J0IEZvb3RlciBmcm9tICcuL0Zvb3RlcidcblxuY2xhc3MgQXhpb21TY2kgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnRcbntcblx0cmVuZGVyKClcblx0e1xuXHRcdHJldHVybihcblx0XHRcdDxkaXY+XG5cdFx0XHRcdDxOYXZiYXIgaGlzdG9yeT17dGhpcy5wcm9wcy5oaXN0b3J5fS8+XG5cdFx0XHRcdHt0aGlzLnByb3BzLmNoaWxkcmVufVxuXHRcdFx0XHQ8Rm9vdGVyIC8+XG5cdFx0XHQ8L2Rpdj5cblx0XHQpXG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQXhpb21TY2kiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQge0xpbmt9IGZyb20gJ3JlYWN0LXJvdXRlcidcbmltcG9ydCBGb290ZXJTdG9yZSBmcm9tICcuLi9zdG9yZXMvTmF2YmFyU3RvcmUnXG5pbXBvcnQgRm9vdGVyQWN0aW9ucyBmcm9tICcuLi9hY3Rpb25zL05hdmJhckFjdGlvbnMnXG5cbmNsYXNzIEZvb3RlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudFxue1xuXHRjb25zdHJ1Y3Rvcihwcm9wcylcblx0e1xuXHRcdHN1cGVyKHByb3BzKVxuXHRcdHRoaXMuc3RhdGUgPSBGb290ZXJTdG9yZS5nZXRTdGF0ZSgpXG5cdFx0dGhpcy5vbkNoYW5nZSA9IHRoaXMub25DaGFuZ2UuYmluZCh0aGlzKVxuXHR9XG5cblx0Y29tcG9uZW50RGlkTW91bnQoKSBcblx0e1xuXHQgICAgRm9vdGVyU3RvcmUubGlzdGVuKHRoaXMub25DaGFuZ2UpO1xuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkgXG4gICAge1xuICAgIFx0Rm9vdGVyU3RvcmUudW5saXN0ZW4odGhpcy5vbkNoYW5nZSk7XG4gIFx0fVxuXG4gIFx0b25DaGFuZ2Uoc3RhdGUpXG4gIFx0e1xuICBcdFx0dGhpcy5zZXRTdGF0ZShzdGF0ZSlcbiAgXHR9XG5cbiAgXHRyZW5kZXIoKVxuICBcdHtcbiAgXHRcdHZhciBsaW5rcyA9IFtcIkFib3V0IFVzXCIsIFwiUHJpdmFjeSBQb2xpY3lcIiwgXCJUZXJtcyBvZiBVc2VcIiwgXCJDYXJlZXJzXCIsIFwiQ29udGFjdFwiLCBcIkhlbHBcIl0ubWFwKChsaW5rKSA9PiB7XG4gIFx0XHRcdHJldHVybiAoXG4gIFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9J2NvbC1sZy0yJyBrZXk9e2xpbmt9PlxuICBcdFx0XHRcdFx0PExpbmsgdG89JyMnPlxuICBcdFx0XHRcdFx0XHR7bGlua31cbiAgXHRcdFx0XHRcdDwvTGluaz5cbiAgXHRcdFx0XHQ8L2Rpdj5cbiAgXHRcdFx0KVxuICBcdFx0fSlcblxuICBcdFx0cmV0dXJuIChcbiAgXHRcdFx0PGZvb3Rlcj5cbiAgXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImNvbnRhaW5lci1mbHVpZCBncmV5XCI+XG4gIFx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInJvd1wiPlxuICBcdFx0XHRcdFx0XHR7bGlua3N9XG4gIFx0XHRcdFx0XHQ8L2Rpdj5cbiAgXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwicm93XCI+XG4gIFx0XHRcdFx0XHRcdEF4aW9tLVNjaWVudGlmaWMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gIFx0XHRcdFx0XHQ8L2Rpdj5cbiAgXHRcdFx0XHQ8L2Rpdj5cbiAgXHRcdFx0PC9mb290ZXI+XG4gIFx0XHQpXG4gIFx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBGb290ZXIiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5cbmNsYXNzIEhvbWUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQgXG57XG4gIHJlbmRlcigpIFxuICB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPSdhbGVydCBhbGVydC1pbmZvJz5cbiAgICAgICAgSGVsbG8gZnJvbSBIb21lIENvbXBvbmVudFxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEhvbWUiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQge0xpbmt9IGZyb20gJ3JlYWN0LXJvdXRlcidcbmltcG9ydCBMb2dpblN0b3JlIGZyb20gJy4uL3N0b3Jlcy9Mb2dpblN0b3JlJ1xuaW1wb3J0IExvZ2luQWN0aW9ucyBmcm9tICcuLi9hY3Rpb25zL0xvZ2luQWN0aW9ucydcblxuY2xhc3MgTG9naW4gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnRcbntcblx0Y29uc3RydWN0b3IocHJvcHMpXG5cdHtcblx0XHRzdXBlcihwcm9wcylcblx0XHR0aGlzLnN0YXRlID0gTG9naW5TdG9yZS5nZXRTdGF0ZSgpXG5cdFx0dGhpcy5vbkNoYW5nZSA9IHRoaXMub25DaGFuZ2UuYmluZCh0aGlzKVxuXHR9XG5cblx0Y29tcG9uZW50RGlkTW91bnQoKVxuXHR7XG5cdFx0TG9naW5TdG9yZS5saXN0ZW4odGhpcy5vbkNoYW5nZSlcblx0fVxuXG5cdGNvbXBvbmVudFdpbGxVbm1vdW50KClcblx0e1xuXHRcdExvZ2luU3RvcmUudW5saXN0ZW4odGhpcy5vbkNoYW5nZSlcblx0fVxuXG5cdG9uQ2hhbmdlKHN0YXRlKVxuXHR7XG5cdFx0dGhpcy5zZXRTdGF0ZShzdGF0ZSlcblx0fVxuXG5cdGhhbmRsZVN1Ym1pdChlKVxuXHR7XG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpXG5cdFx0dmFyIHVzZXIgPSB7XG5cdFx0XHRcImVtYWlsXCI6IHRoaXMuc3RhdGUuZW1haWwsXG5cdFx0XHRcInBhc3N3b3JkXCI6IHRoaXMuc3RhdGUucGFzc3dvcmRcblx0XHR9XG5cdFx0TG9naW5BY3Rpb25zLmxvZ2luVXNlcih1c2VyKVxuXHR9XG5cblx0cmVuZGVyKClcblx0e1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8Zm9ybSBvblN1Ym1pdD17dGhpcy5oYW5kbGVTdWJtaXQuYmluZCh0aGlzKX0+XG5cdFx0XHRcdDxpbnB1dCB0eXBlPSdlbWFpbCcgY2xhc3NOYW1lPSdmb3JtLWNvbnRyb2wnIG5hbWU9J2VtYWlsJyBvbkNoYW5nZT17TG9naW5BY3Rpb25zLnVwZGF0ZVVzZXJ9IHZhbHVlPXt0aGlzLnN0YXRlLmVtYWlsfSBwbGFjZWhvbGRlcj0nRW1haWwnIHJlcXVpcmVkLz5cblx0XHRcdFx0PGlucHV0IHR5cGU9J3Bhc3N3b3JkJyBjbGFzc05hbWU9J2Zvcm0tY29udHJvbCcgbmFtZT0ncGFzc3dvcmQnIG9uQ2hhbmdlPXtMb2dpbkFjdGlvbnMudXBkYXRlVXNlcn0gdmFsdWU9e3RoaXMuc3RhdGUucGFzc3dvcmR9IHBsYWNlaG9sZGVyPSdQYXNzd29yZCcgcmVxdWlyZWQvPlxuXHRcdFx0XHQ8YnV0dG9uIHR5cGU9J3N1Ym1pdCcgY2xhc3NOYW1lPSdidG4gYnRuLXByaW1hcnknPkxvZ2luPC9idXR0b24+XG5cdFx0XHRcdDxkaXY+RG9udCBoYXZlIGFuIGFjY291bnQ/PC9kaXY+XG5cdFx0XHRcdDxMaW5rIHRvPScvc2lnbnVwJz5TaWduIFVwIEhlcmU8L0xpbms+XG5cdFx0XHQ8L2Zvcm0+XG5cdFx0KVxuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExvZ2luIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHtMaW5rfSBmcm9tICdyZWFjdC1yb3V0ZXInXG5pbXBvcnQgTmF2YmFyU3RvcmUgZnJvbSAnLi4vc3RvcmVzL05hdmJhclN0b3JlJ1xuaW1wb3J0IE5hdmJhckFjdGlvbnMgZnJvbSAnLi4vYWN0aW9ucy9OYXZiYXJBY3Rpb25zJ1xuXG5jbGFzcyBOYXZiYXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnRcbntcblx0Y29uc3RydWN0b3IocHJvcHMpXG5cdHtcblx0XHRzdXBlcihwcm9wcylcblx0XHR0aGlzLnN0YXRlID0gTmF2YmFyU3RvcmUuZ2V0U3RhdGUoKVxuXHRcdHRoaXMub25DaGFuZ2UgPSB0aGlzLm9uQ2hhbmdlLmJpbmQodGhpcylcblx0fVxuXG5cdGNvbXBvbmVudERpZE1vdW50KClcblx0e1xuXHRcdE5hdmJhclN0b3JlLmxpc3Rlbih0aGlzLm9uQ2hhbmdlKVxuXHRcdC8vIE5hdmJhckFjdGlvbnMuZ2V0Q2hhcmFjdGVyQ291bnQoKVxuXHRcdC8vIGxldCBzb2NrZXQgPSBpby5jb25uZWN0KClcblx0fVxuXG5cdGNvbXBvbmVudFdpbGxVbm1vdW50KClcblx0e1xuXHRcdE5hdmJhclN0b3JlLnVubGlzdGVuKHRoaXMub25DaGFuZ2UpXG5cdH1cblxuXHRvbkNoYW5nZShzdGF0ZSlcblx0e1xuXHRcdHRoaXMuc2V0U3RhdGUoc3RhdGUpXG5cdH1cblxuXHRoYW5kbGVTZWFyY2goKVxuXHR7XG5cdFx0Y29uc29sZS5sb2coXCJTZWFyY2hpbmcuLi5cIilcblx0fVxuXG5cdHJlbmRlcigpXG5cdHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PG5hdiBjbGFzc05hbWU9J25hdmJhciBuYXZiYXItZGVmYXVsdCBuYXZiYXItc3RhdGljLXRvcCc+XG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPSdjb250YWluZXItZmx1aWQnPlxuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPSdyb3cgYmx1ZSc+XG5cdFx0XHRcdFx0XHQ8ZGl2PkF4aW9tLVNjaWVudGlmaWM8L2Rpdj5cblx0XHRcdFx0XHRcdDxMaW5rIHRvPScvbG9naW4nIGNsYXNzTmFtZT0nYnRuIGJ0bi1kZWZhdWx0Jz5Mb2dpbjwvTGluaz5cblx0XHRcdFx0XHRcdDxMaW5rIHRvPScvc2lnbnVwJyBjbGFzc05hbWU9J2J0biBidG4tZGVmYXVsdCc+U2lnbiBVcDwvTGluaz5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT0ncm93Jz5cblx0XHRcdFx0XHRcdDxmb3JtIHJlZj0nc2VhcmNoRm9ybScgY2xhc3NOYW1lPSduYXZiYXItZm9ybSBuYXZiYXItbGVmdCBhbmltYXRlZCcgb25TdWJtaXQ9e3RoaXMuaGFuZGxlU2VhcmNoLmJpbmQodGhpcyl9PlxuXHRcdFx0XHQgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0naW5wdXQtZ3JvdXAnPlxuXHRcdFx0XHQgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPSd0ZXh0JyBjbGFzc05hbWU9J2Zvcm0tY29udHJvbCcgcGxhY2Vob2xkZXI9e1wiVHlwZSBJdGVtICMgb3Iga2V5d29yZFwifSB2YWx1ZT17dGhpcy5zdGF0ZS5zZWFyY2hRdWVyeX0gb25DaGFuZ2U9e05hdmJhckFjdGlvbnMudXBkYXRlU2VhcmNoUXVlcnl9IC8+XG5cdFx0XHRcdCAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPSdpbnB1dC1ncm91cC1idG4nPlxuXHRcdFx0XHQgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9J2J0biBidG4tZGVmYXVsdCcgb25DbGljaz17dGhpcy5oYW5kbGVTZWFyY2guYmluZCh0aGlzKX0+PHNwYW4gY2xhc3NOYW1lPSdnbHlwaGljb24gZ2x5cGhpY29uLXNlYXJjaCc+PC9zcGFuPjwvYnV0dG9uPlxuXHRcdFx0XHQgICAgICAgICAgICAgIDwvc3Bhbj5cblx0XHRcdFx0ICAgICAgICAgICAgPC9kaXY+XG5cdFx0XHRcdFx0XHQ8L2Zvcm0+XG5cdFx0XHRcdFx0XHQ8ZGl2Pk15IENhcnQ8L2Rpdj5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHQ8L25hdj5cblx0XHQpXG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmF2YmFyIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHtMaW5rfSBmcm9tICdyZWFjdC1yb3V0ZXInXG5pbXBvcnQgU2lnblVwU3RvcmUgZnJvbSAnLi4vc3RvcmVzL1NpZ25VcFN0b3JlJ1xuaW1wb3J0IFNpZ25VcEFjdGlvbnMgZnJvbSAnLi4vYWN0aW9ucy9TaWduVXBBY3Rpb25zJ1xuLy8gaW1wb3J0IFRleHRGaWVsZCBmcm9tICdtYXRlcmlhbC11aS9UZXh0RmllbGQnXG5jbGFzcyBTaWduVXAgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnRcbntcblx0Y29uc3RydWN0b3IocHJvcHMpXG5cdHtcblx0XHRzdXBlcihwcm9wcylcblx0XHR0aGlzLnN0YXRlID0gU2lnblVwU3RvcmUuZ2V0U3RhdGUoKVxuXHRcdHRoaXMub25DaGFuZ2UgPSB0aGlzLm9uQ2hhbmdlLmJpbmQodGhpcylcblx0fVxuXG5cdGNvbXBvbmVudERpZE1vdW50KClcblx0e1xuXHRcdFNpZ25VcFN0b3JlLmxpc3Rlbih0aGlzLm9uQ2hhbmdlKVxuXHR9XG5cblx0Y29tcG9uZW50V2lsbFVubW91bnQoKVxuXHR7XG5cdFx0U2lnblVwU3RvcmUudW5saXN0ZW4odGhpcy5vbkNoYW5nZSlcblx0fVxuXG5cdG9uQ2hhbmdlKHN0YXRlKVxuXHR7XG5cdFx0dGhpcy5zZXRTdGF0ZShzdGF0ZSlcblx0fVxuXG5cdGhhbmRsZVN1Ym1pdChlKVxuXHR7XG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpXG5cdFx0dmFyIHVzZXIgPSB7XG5cdFx0XHRcImZuYW1lXCI6IHRoaXMuc3RhdGUuZm5hbWUsXG5cdFx0XHRcImxuYW1lXCI6IHRoaXMuc3RhdGUubG5hbWUsXG5cdFx0XHRcImVtYWlsXCI6IHRoaXMuc3RhdGUuZW1haWwsXG5cdFx0XHRcInBhc3N3b3JkXCI6IHRoaXMuc3RhdGUucGFzc3dvcmQsXG5cdFx0XHRcImFkZHJlc3NcIjogdGhpcy5zdGF0ZS5hZGRyZXNzLFxuXHRcdFx0XCJjaXR5XCI6IHRoaXMuc3RhdGUuY2l0eSxcblx0XHRcdFwic3RcIjogdGhpcy5zdGF0ZS5zdCxcblx0XHRcdFwiemlwXCI6IHRoaXMuc3RhdGUuemlwLFxuXHRcdFx0XCJwaG9uZVwiOiB0aGlzLnN0YXRlLnBob25lXG5cdFx0fVxuXHRcdGNvbnNvbGUubG9nKHVzZXIpXG5cdFx0U2lnblVwQWN0aW9ucy5jcmVhdGVVc2VyKHVzZXIpXG5cdH1cblxuXHRyZW5kZXIoKSAvLyBJbiB0aGUgZnV0dXJlLCBpbnB1dHMgcHJvYmFibHkgY2FuIGIgY29tcG9uZW50c1xuXHR7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxmb3JtIG9uU3VibWl0PXt0aGlzLmhhbmRsZVN1Ym1pdC5iaW5kKHRoaXMpfT5cblx0XHRcdFx0PGlucHV0IHR5cGU9J3RleHQnIGNsYXNzTmFtZT0nZm9ybS1jb250cm9sJyBuYW1lPSdmbmFtZScgb25DaGFuZ2U9e1NpZ25VcEFjdGlvbnMudXBkYXRlVXNlcn0gdmFsdWU9e3RoaXMuc3RhdGUuZm5hbWV9IHBsYWNlaG9sZGVyPSdGaXJzdCBOYW1lJyByZXF1aXJlZC8+XG5cdFx0XHRcdDxpbnB1dCB0eXBlPSd0ZXh0JyBjbGFzc05hbWU9J2Zvcm0tY29udHJvbCcgbmFtZT0nbG5hbWUnIG9uQ2hhbmdlPXtTaWduVXBBY3Rpb25zLnVwZGF0ZVVzZXJ9IHZhbHVlPXt0aGlzLnN0YXRlLmxuYW1lfSBwbGFjZWhvbGRlcj0nTGFzdCBOYW1lJyAvPlxuXHRcdFx0XHQ8aW5wdXQgdHlwZT0nZW1haWwnIGNsYXNzTmFtZT0nZm9ybS1jb250cm9sJyBuYW1lPSdlbWFpbCcgb25DaGFuZ2U9e1NpZ25VcEFjdGlvbnMudXBkYXRlVXNlcn0gdmFsdWU9e3RoaXMuc3RhdGUuZW1haWx9IHBsYWNlaG9sZGVyPSdFbWFpbCcgcmVxdWlyZWQvPlxuXHRcdFx0XHQ8aW5wdXQgdHlwZT0ncGFzc3dvcmQnIGNsYXNzTmFtZT0nZm9ybS1jb250cm9sJyBuYW1lPSdwYXNzd29yZCcgb25DaGFuZ2U9e1NpZ25VcEFjdGlvbnMudXBkYXRlVXNlcn0gdmFsdWU9e3RoaXMuc3RhdGUucGFzc3dvcmR9IHBsYWNlaG9sZGVyPSdQYXNzd29yZCcgcmVxdWlyZWQvPlxuXHRcdFx0XHQ8aW5wdXQgdHlwZT0ndGV4dCcgY2xhc3NOYW1lPSdmb3JtLWNvbnRyb2wnIG5hbWU9J2FkZHJlc3MnIG9uQ2hhbmdlPXtTaWduVXBBY3Rpb25zLnVwZGF0ZVVzZXJ9IHZhbHVlPXt0aGlzLnN0YXRlLmFkZHJlc3N9IHBsYWNlaG9sZGVyPSdBZGRyZXNzJyByZXF1aXJlZC8+XG5cdFx0XHRcdDxpbnB1dCB0eXBlPSd0ZXh0JyBjbGFzc05hbWU9J2Zvcm0tY29udHJvbCcgbmFtZT0nY2l0eScgb25DaGFuZ2U9e1NpZ25VcEFjdGlvbnMudXBkYXRlVXNlcn0gdmFsdWU9e3RoaXMuc3RhdGUuY2l0eX0gcGxhY2Vob2xkZXI9J0NpdHknIHJlcXVpcmVkLz5cblx0XHRcdFx0PHNlbGVjdCBuYW1lPSdzdCcgY2xhc3NOYW1lPSdmb3JtLWNvbnRyb2wnIG9uQ2hhbmdlPXtTaWduVXBBY3Rpb25zLnVwZGF0ZVVzZXJ9PlxuXHRcdFx0XHRcdDxvcHRpb24gdmFsdWU9Jyc+UGxlYXNlIFNlbGVjdCBhIFN0YXRlPC9vcHRpb24+XG5cdFx0XHRcdFx0PG9wdGlvbiB2YWx1ZT1cIkFMXCI+QWxhYmFtYTwvb3B0aW9uPlxuXHRcdFx0XHRcdDxvcHRpb24gdmFsdWU9XCJBS1wiPkFsYXNrYTwvb3B0aW9uPlxuXHRcdFx0XHRcdDxvcHRpb24gdmFsdWU9XCJBWlwiPkFyaXpvbmE8L29wdGlvbj5cblx0XHRcdFx0XHQ8b3B0aW9uIHZhbHVlPVwiQVJcIj5BcmthbnNhczwvb3B0aW9uPlxuXHRcdFx0XHRcdDxvcHRpb24gdmFsdWU9XCJDQVwiPkNhbGlmb3JuaWE8L29wdGlvbj5cblx0XHRcdFx0XHQ8b3B0aW9uIHZhbHVlPVwiQ09cIj5Db2xvcmFkbzwvb3B0aW9uPlxuXHRcdFx0XHRcdDxvcHRpb24gdmFsdWU9XCJDVFwiPkNvbm5lY3RpY3V0PC9vcHRpb24+XG5cdFx0XHRcdFx0PG9wdGlvbiB2YWx1ZT1cIkRFXCI+RGVsYXdhcmU8L29wdGlvbj5cblx0XHRcdFx0XHQ8b3B0aW9uIHZhbHVlPVwiRENcIj5EaXN0cmljdCBPZiBDb2x1bWJpYTwvb3B0aW9uPlxuXHRcdFx0XHRcdDxvcHRpb24gdmFsdWU9XCJGTFwiPkZsb3JpZGE8L29wdGlvbj5cblx0XHRcdFx0XHQ8b3B0aW9uIHZhbHVlPVwiR0FcIj5HZW9yZ2lhPC9vcHRpb24+XG5cdFx0XHRcdFx0PG9wdGlvbiB2YWx1ZT1cIkhJXCI+SGF3YWlpPC9vcHRpb24+XG5cdFx0XHRcdFx0PG9wdGlvbiB2YWx1ZT1cIklEXCI+SWRhaG88L29wdGlvbj5cblx0XHRcdFx0XHQ8b3B0aW9uIHZhbHVlPVwiSUxcIj5JbGxpbm9pczwvb3B0aW9uPlxuXHRcdFx0XHRcdDxvcHRpb24gdmFsdWU9XCJJTlwiPkluZGlhbmE8L29wdGlvbj5cblx0XHRcdFx0XHQ8b3B0aW9uIHZhbHVlPVwiSUFcIj5Jb3dhPC9vcHRpb24+XG5cdFx0XHRcdFx0PG9wdGlvbiB2YWx1ZT1cIktTXCI+S2Fuc2FzPC9vcHRpb24+XG5cdFx0XHRcdFx0PG9wdGlvbiB2YWx1ZT1cIktZXCI+S2VudHVja3k8L29wdGlvbj5cblx0XHRcdFx0XHQ8b3B0aW9uIHZhbHVlPVwiTEFcIj5Mb3Vpc2lhbmE8L29wdGlvbj5cblx0XHRcdFx0XHQ8b3B0aW9uIHZhbHVlPVwiTUVcIj5NYWluZTwvb3B0aW9uPlxuXHRcdFx0XHRcdDxvcHRpb24gdmFsdWU9XCJNRFwiPk1hcnlsYW5kPC9vcHRpb24+XG5cdFx0XHRcdFx0PG9wdGlvbiB2YWx1ZT1cIk1BXCI+TWFzc2FjaHVzZXR0czwvb3B0aW9uPlxuXHRcdFx0XHRcdDxvcHRpb24gdmFsdWU9XCJNSVwiPk1pY2hpZ2FuPC9vcHRpb24+XG5cdFx0XHRcdFx0PG9wdGlvbiB2YWx1ZT1cIk1OXCI+TWlubmVzb3RhPC9vcHRpb24+XG5cdFx0XHRcdFx0PG9wdGlvbiB2YWx1ZT1cIk1TXCI+TWlzc2lzc2lwcGk8L29wdGlvbj5cblx0XHRcdFx0XHQ8b3B0aW9uIHZhbHVlPVwiTU9cIj5NaXNzb3VyaTwvb3B0aW9uPlxuXHRcdFx0XHRcdDxvcHRpb24gdmFsdWU9XCJNVFwiPk1vbnRhbmE8L29wdGlvbj5cblx0XHRcdFx0XHQ8b3B0aW9uIHZhbHVlPVwiTkVcIj5OZWJyYXNrYTwvb3B0aW9uPlxuXHRcdFx0XHRcdDxvcHRpb24gdmFsdWU9XCJOVlwiPk5ldmFkYTwvb3B0aW9uPlxuXHRcdFx0XHRcdDxvcHRpb24gdmFsdWU9XCJOSFwiPk5ldyBIYW1wc2hpcmU8L29wdGlvbj5cblx0XHRcdFx0XHQ8b3B0aW9uIHZhbHVlPVwiTkpcIj5OZXcgSmVyc2V5PC9vcHRpb24+XG5cdFx0XHRcdFx0PG9wdGlvbiB2YWx1ZT1cIk5NXCI+TmV3IE1leGljbzwvb3B0aW9uPlxuXHRcdFx0XHRcdDxvcHRpb24gdmFsdWU9XCJOWVwiPk5ldyBZb3JrPC9vcHRpb24+XG5cdFx0XHRcdFx0PG9wdGlvbiB2YWx1ZT1cIk5DXCI+Tm9ydGggQ2Fyb2xpbmE8L29wdGlvbj5cblx0XHRcdFx0XHQ8b3B0aW9uIHZhbHVlPVwiTkRcIj5Ob3J0aCBEYWtvdGE8L29wdGlvbj5cblx0XHRcdFx0XHQ8b3B0aW9uIHZhbHVlPVwiT0hcIj5PaGlvPC9vcHRpb24+XG5cdFx0XHRcdFx0PG9wdGlvbiB2YWx1ZT1cIk9LXCI+T2tsYWhvbWE8L29wdGlvbj5cblx0XHRcdFx0XHQ8b3B0aW9uIHZhbHVlPVwiT1JcIj5PcmVnb248L29wdGlvbj5cblx0XHRcdFx0XHQ8b3B0aW9uIHZhbHVlPVwiUEFcIj5QZW5uc3lsdmFuaWE8L29wdGlvbj5cblx0XHRcdFx0XHQ8b3B0aW9uIHZhbHVlPVwiUklcIj5SaG9kZSBJc2xhbmQ8L29wdGlvbj5cblx0XHRcdFx0XHQ8b3B0aW9uIHZhbHVlPVwiU0NcIj5Tb3V0aCBDYXJvbGluYTwvb3B0aW9uPlxuXHRcdFx0XHRcdDxvcHRpb24gdmFsdWU9XCJTRFwiPlNvdXRoIERha290YTwvb3B0aW9uPlxuXHRcdFx0XHRcdDxvcHRpb24gdmFsdWU9XCJUTlwiPlRlbm5lc3NlZTwvb3B0aW9uPlxuXHRcdFx0XHRcdDxvcHRpb24gdmFsdWU9XCJUWFwiPlRleGFzPC9vcHRpb24+XG5cdFx0XHRcdFx0PG9wdGlvbiB2YWx1ZT1cIlVUXCI+VXRhaDwvb3B0aW9uPlxuXHRcdFx0XHRcdDxvcHRpb24gdmFsdWU9XCJWVFwiPlZlcm1vbnQ8L29wdGlvbj5cblx0XHRcdFx0XHQ8b3B0aW9uIHZhbHVlPVwiVkFcIj5WaXJnaW5pYTwvb3B0aW9uPlxuXHRcdFx0XHRcdDxvcHRpb24gdmFsdWU9XCJXQVwiPldhc2hpbmd0b248L29wdGlvbj5cblx0XHRcdFx0XHQ8b3B0aW9uIHZhbHVlPVwiV1ZcIj5XZXN0IFZpcmdpbmlhPC9vcHRpb24+XG5cdFx0XHRcdFx0PG9wdGlvbiB2YWx1ZT1cIldJXCI+V2lzY29uc2luPC9vcHRpb24+XG5cdFx0XHRcdFx0PG9wdGlvbiB2YWx1ZT1cIldZXCI+V3lvbWluZzwvb3B0aW9uPlxuXHRcdFx0XHQ8L3NlbGVjdD5cblx0XHRcdFx0PGlucHV0IHR5cGU9J3RleHQnIGNsYXNzTmFtZT0nZm9ybS1jb250cm9sJyBuYW1lPSd6aXAnIG9uQ2hhbmdlPXtTaWduVXBBY3Rpb25zLnVwZGF0ZVVzZXJ9IHZhbHVlPXt0aGlzLnN0YXRlLnppcH0gcGxhY2Vob2xkZXI9J1ppcCBDb2RlJyByZXF1aXJlZC8+XG5cdFx0XHRcdDxpbnB1dCB0eXBlPSd0ZWwnIGNsYXNzTmFtZT0nZm9ybS1jb250cm9sJyBuYW1lPSdwaG9uZScgb25DaGFuZ2U9e1NpZ25VcEFjdGlvbnMudXBkYXRlVXNlcn0gdmFsdWU9e3RoaXMuc3RhdGUucGhvbmV9IHBsYWNlaG9sZGVyPSdQaG9uZSBOdW1iZXInIHJlcXVpcmVkLz5cblx0XHRcdFx0PGJ1dHRvbiB0eXBlPSdzdWJtaXQnIGNsYXNzTmFtZT0nYnRuIGJ0bi1wcmltYXJ5Jz5DcmVhdGUgQWNjb3VudDwvYnV0dG9uPlxuXHRcdFx0PC9mb3JtPlxuXHRcdClcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBTaWduVXAiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgUm91dGVyIGZyb20gJ3JlYWN0LXJvdXRlcidcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nXG5pbXBvcnQgcm91dGVzIGZyb20gJy4vcm91dGVzJ1xuaW1wb3J0IGNyZWF0ZUJyb3dzZXJIaXN0b3J5IGZyb20gJ2hpc3RvcnkvbGliL2NyZWF0ZUJyb3dzZXJIaXN0b3J5J1xuXG5sZXQgaGlzdG9yeSA9IGNyZWF0ZUJyb3dzZXJIaXN0b3J5KClcblxuUmVhY3RET00ucmVuZGVyKDxSb3V0ZXIgaGlzdG9yeT17aGlzdG9yeX0+e3JvdXRlc308L1JvdXRlcj4sIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhcHAnKSkiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQge1JvdXRlfSBmcm9tICdyZWFjdC1yb3V0ZXInXG5pbXBvcnQgQXhpb21TY2kgZnJvbSAnLi9jb21wb25lbnRzL0F4aW9tU2NpJ1xuaW1wb3J0IEhvbWUgZnJvbSAnLi9jb21wb25lbnRzL0hvbWUnXG5pbXBvcnQgU2lnblVwIGZyb20gJy4vY29tcG9uZW50cy9TaWduVXAnXG5pbXBvcnQgTG9naW4gZnJvbSAnLi9jb21wb25lbnRzL0xvZ2luJ1xuXG5leHBvcnQgZGVmYXVsdCAoXG5cdDxSb3V0ZSBjb21wb25lbnQ9e0F4aW9tU2NpfT5cblx0XHQ8Um91dGUgcGF0aD0nLycgY29tcG9uZW50PXtIb21lfSAvPlxuXHRcdDxSb3V0ZSBwYXRoPScvc2lnbnVwJyBjb21wb25lbnQ9e1NpZ25VcH0gLz5cblx0XHQ8Um91dGUgcGF0aD0nL2xvZ2luJyBjb21wb25lbnQ9e0xvZ2lufSAvPlxuXHQ8L1JvdXRlPlxuKSIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCBMb2dpbkFjdGlvbnMgZnJvbSAnLi4vYWN0aW9ucy9Mb2dpbkFjdGlvbnMnXG5pbXBvcnQgYWx0IGZyb20gJy4uL2FsdCdcblxuY2xhc3MgTG9naW5TdG9yZVxue1xuXHRjb25zdHJ1Y3RvcigpXG5cdHtcblx0XHR0aGlzLmJpbmRBY3Rpb25zKExvZ2luQWN0aW9ucylcblx0XHR0aGlzLmVtYWlsID0gJydcblx0XHR0aGlzLnBhc3N3b3JkID0gJydcblx0fVxuXG5cdG9uVXBkYXRlVXNlcihlKVxuXHR7XG5cdFx0dGhpc1tlLnRhcmdldC5uYW1lXSA9IGUudGFyZ2V0LnZhbHVlXG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgYWx0LmNyZWF0ZVN0b3JlKExvZ2luU3RvcmUpIiwiaW1wb3J0IGFsdCBmcm9tICcuLi9hbHQnXG5pbXBvcnQgTmF2YmFyQWN0aW9ucyBmcm9tICcuLi9hY3Rpb25zL05hdmJhckFjdGlvbnMnXG5cbmNsYXNzIE5hdmJhclN0b3JlXG57XG5cdGNvbnN0cnVjdG9yKClcblx0e1xuXHRcdHRoaXMuYmluZEFjdGlvbnMoTmF2YmFyQWN0aW9ucylcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBhbHQuY3JlYXRlU3RvcmUoTmF2YmFyU3RvcmUpIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IFNpZ25VcEFjdGlvbnMgZnJvbSAnLi4vYWN0aW9ucy9TaWduVXBBY3Rpb25zJ1xuaW1wb3J0IGFsdCBmcm9tICcuLi9hbHQnXG5cbmNsYXNzIFNpZ25VcFN0b3JlXG57XG5cdGNvbnN0cnVjdG9yKClcblx0e1xuXHRcdHRoaXMuYmluZEFjdGlvbnMoU2lnblVwQWN0aW9ucylcblx0XHR0aGlzLmVtYWlsID0gJydcblx0XHR0aGlzLmZuYW1lID0gJydcblx0XHR0aGlzLmxuYW1lID0gJydcblx0XHR0aGlzLnBhc3N3b3JkID0gJydcblx0XHR0aGlzLmFkZHJlc3MgPSAnJ1xuXHRcdHRoaXMuY2l0eSA9ICcnXG5cdFx0dGhpcy5zdCA9ICcnXG5cdFx0dGhpcy56aXAgPSAnJ1xuXHRcdHRoaXMucGhvbmUgPSAnJ1xuXHR9XG5cblx0b25VcGRhdGVVc2VyKGUpXG5cdHtcblx0XHR0aGlzW2UudGFyZ2V0Lm5hbWVdID0gZS50YXJnZXQudmFsdWVcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBhbHQuY3JlYXRlU3RvcmUoU2lnblVwU3RvcmUpIiwidmFyIHBTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBvYmplY3RLZXlzID0gcmVxdWlyZSgnLi9saWIva2V5cy5qcycpO1xudmFyIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9saWIvaXNfYXJndW1lbnRzLmpzJyk7XG5cbnZhciBkZWVwRXF1YWwgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhY3R1YWwsIGV4cGVjdGVkLCBvcHRzKSB7XG4gIGlmICghb3B0cykgb3B0cyA9IHt9O1xuICAvLyA3LjEuIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2UgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIERhdGUgJiYgZXhwZWN0ZWQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5nZXRUaW1lKCkgPT09IGV4cGVjdGVkLmdldFRpbWUoKTtcblxuICAvLyA3LjMuIE90aGVyIHBhaXJzIHRoYXQgZG8gbm90IGJvdGggcGFzcyB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcsXG4gIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgPT0uXG4gIH0gZWxzZSBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQgfHwgdHlwZW9mIGFjdHVhbCAhPSAnb2JqZWN0JyAmJiB0eXBlb2YgZXhwZWN0ZWQgIT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gb3B0cy5zdHJpY3QgPyBhY3R1YWwgPT09IGV4cGVjdGVkIDogYWN0dWFsID09IGV4cGVjdGVkO1xuXG4gIC8vIDcuNC4gRm9yIGFsbCBvdGhlciBPYmplY3QgcGFpcnMsIGluY2x1ZGluZyBBcnJheSBvYmplY3RzLCBlcXVpdmFsZW5jZSBpc1xuICAvLyBkZXRlcm1pbmVkIGJ5IGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoYXMgdmVyaWZpZWRcbiAgLy8gd2l0aCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwpLCB0aGUgc2FtZSBzZXQgb2Yga2V5c1xuICAvLyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSwgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5XG4gIC8vIGNvcnJlc3BvbmRpbmcga2V5LCBhbmQgYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LiBOb3RlOiB0aGlzXG4gIC8vIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmpFcXVpdihhY3R1YWwsIGV4cGVjdGVkLCBvcHRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZE9yTnVsbCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKHgpIHtcbiAgaWYgKCF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgeC5sZW5ndGggIT09ICdudW1iZXInKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgeC5jb3B5ICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB4LnNsaWNlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh4Lmxlbmd0aCA+IDAgJiYgdHlwZW9mIHhbMF0gIT09ICdudW1iZXInKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiLCBvcHRzKSB7XG4gIHZhciBpLCBrZXk7XG4gIGlmIChpc1VuZGVmaW5lZE9yTnVsbChhKSB8fCBpc1VuZGVmaW5lZE9yTnVsbChiKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS5cbiAgaWYgKGEucHJvdG90eXBlICE9PSBiLnByb3RvdHlwZSkgcmV0dXJuIGZhbHNlO1xuICAvL35+fkkndmUgbWFuYWdlZCB0byBicmVhayBPYmplY3Qua2V5cyB0aHJvdWdoIHNjcmV3eSBhcmd1bWVudHMgcGFzc2luZy5cbiAgLy8gICBDb252ZXJ0aW5nIHRvIGFycmF5IHNvbHZlcyB0aGUgcHJvYmxlbS5cbiAgaWYgKGlzQXJndW1lbnRzKGEpKSB7XG4gICAgaWYgKCFpc0FyZ3VtZW50cyhiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhID0gcFNsaWNlLmNhbGwoYSk7XG4gICAgYiA9IHBTbGljZS5jYWxsKGIpO1xuICAgIHJldHVybiBkZWVwRXF1YWwoYSwgYiwgb3B0cyk7XG4gIH1cbiAgaWYgKGlzQnVmZmVyKGEpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHRyeSB7XG4gICAgdmFyIGthID0gb2JqZWN0S2V5cyhhKSxcbiAgICAgICAga2IgPSBvYmplY3RLZXlzKGIpO1xuICB9IGNhdGNoIChlKSB7Ly9oYXBwZW5zIHdoZW4gb25lIGlzIGEgc3RyaW5nIGxpdGVyYWwgYW5kIHRoZSBvdGhlciBpc24ndFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGtleXMgaW5jb3Jwb3JhdGVzXG4gIC8vIGhhc093blByb3BlcnR5KVxuICBpZiAoa2EubGVuZ3RoICE9IGtiLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vdGhlIHNhbWUgc2V0IG9mIGtleXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksXG4gIGthLnNvcnQoKTtcbiAga2Iuc29ydCgpO1xuICAvL35+fmNoZWFwIGtleSB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGthW2ldICE9IGtiW2ldKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LCBhbmRcbiAgLy9+fn5wb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAga2V5ID0ga2FbaV07XG4gICAgaWYgKCFkZWVwRXF1YWwoYVtrZXldLCBiW2tleV0sIG9wdHMpKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiBhID09PSB0eXBlb2YgYjtcbn1cbiIsInZhciBzdXBwb3J0c0FyZ3VtZW50c0NsYXNzID0gKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJndW1lbnRzKVxufSkoKSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gc3VwcG9ydHNBcmd1bWVudHNDbGFzcyA/IHN1cHBvcnRlZCA6IHVuc3VwcG9ydGVkO1xuXG5leHBvcnRzLnN1cHBvcnRlZCA9IHN1cHBvcnRlZDtcbmZ1bmN0aW9uIHN1cHBvcnRlZChvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufTtcblxuZXhwb3J0cy51bnN1cHBvcnRlZCA9IHVuc3VwcG9ydGVkO1xuZnVuY3Rpb24gdW5zdXBwb3J0ZWQob2JqZWN0KXtcbiAgcmV0dXJuIG9iamVjdCAmJlxuICAgIHR5cGVvZiBvYmplY3QgPT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2Ygb2JqZWN0Lmxlbmd0aCA9PSAnbnVtYmVyJyAmJlxuICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdjYWxsZWUnKSAmJlxuICAgICFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCAnY2FsbGVlJykgfHxcbiAgICBmYWxzZTtcbn07XG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbidcbiAgPyBPYmplY3Qua2V5cyA6IHNoaW07XG5cbmV4cG9ydHMuc2hpbSA9IHNoaW07XG5mdW5jdGlvbiBzaGltIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gIHJldHVybiBrZXlzO1xufVxuIiwiLyoqXG4gKiBJbmRpY2F0ZXMgdGhhdCBuYXZpZ2F0aW9uIHdhcyBjYXVzZWQgYnkgYSBjYWxsIHRvIGhpc3RvcnkucHVzaC5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIFBVU0ggPSAnUFVTSCc7XG5cbmV4cG9ydHMuUFVTSCA9IFBVU0g7XG4vKipcbiAqIEluZGljYXRlcyB0aGF0IG5hdmlnYXRpb24gd2FzIGNhdXNlZCBieSBhIGNhbGwgdG8gaGlzdG9yeS5yZXBsYWNlLlxuICovXG52YXIgUkVQTEFDRSA9ICdSRVBMQUNFJztcblxuZXhwb3J0cy5SRVBMQUNFID0gUkVQTEFDRTtcbi8qKlxuICogSW5kaWNhdGVzIHRoYXQgbmF2aWdhdGlvbiB3YXMgY2F1c2VkIGJ5IHNvbWUgb3RoZXIgYWN0aW9uIHN1Y2hcbiAqIGFzIHVzaW5nIGEgYnJvd3NlcidzIGJhY2svZm9yd2FyZCBidXR0b25zIGFuZC9vciBtYW51YWxseSBtYW5pcHVsYXRpbmdcbiAqIHRoZSBVUkwgaW4gYSBicm93c2VyJ3MgbG9jYXRpb24gYmFyLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlxuICpcbiAqIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93RXZlbnRIYW5kbGVycy9vbnBvcHN0YXRlXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIFBPUCA9ICdQT1AnO1xuXG5leHBvcnRzLlBPUCA9IFBPUDtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHtcbiAgUFVTSDogUFVTSCxcbiAgUkVQTEFDRTogUkVQTEFDRSxcbiAgUE9QOiBQT1Bcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmxvb3BBc3luYyA9IGxvb3BBc3luYztcblxuZnVuY3Rpb24gbG9vcEFzeW5jKHR1cm5zLCB3b3JrLCBjYWxsYmFjaykge1xuICB2YXIgY3VycmVudFR1cm4gPSAwO1xuICB2YXIgaXNEb25lID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZG9uZSgpIHtcbiAgICBpc0RvbmUgPSB0cnVlO1xuICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiBuZXh0KCkge1xuICAgIGlmIChpc0RvbmUpIHJldHVybjtcblxuICAgIGlmIChjdXJyZW50VHVybiA8IHR1cm5zKSB7XG4gICAgICB3b3JrLmNhbGwodGhpcywgY3VycmVudFR1cm4rKywgbmV4dCwgZG9uZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvbmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBuZXh0KCk7XG59IiwiLyplc2xpbnQtZGlzYWJsZSBuby1lbXB0eSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5zYXZlU3RhdGUgPSBzYXZlU3RhdGU7XG5leHBvcnRzLnJlYWRTdGF0ZSA9IHJlYWRTdGF0ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIEtleVByZWZpeCA9ICdAQEhpc3RvcnkvJztcbnZhciBRdW90YUV4Y2VlZGVkRXJyb3IgPSAnUXVvdGFFeGNlZWRlZEVycm9yJztcbnZhciBTZWN1cml0eUVycm9yID0gJ1NlY3VyaXR5RXJyb3InO1xuXG5mdW5jdGlvbiBjcmVhdGVLZXkoa2V5KSB7XG4gIHJldHVybiBLZXlQcmVmaXggKyBrZXk7XG59XG5cbmZ1bmN0aW9uIHNhdmVTdGF0ZShrZXksIHN0YXRlKSB7XG4gIHRyeSB7XG4gICAgd2luZG93LnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oY3JlYXRlS2V5KGtleSksIEpTT04uc3RyaW5naWZ5KHN0YXRlKSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yLm5hbWUgPT09IFNlY3VyaXR5RXJyb3IpIHtcbiAgICAgIC8vIEJsb2NraW5nIGNvb2tpZXMgaW4gQ2hyb21lL0ZpcmVmb3gvU2FmYXJpIHRocm93cyBTZWN1cml0eUVycm9yIG9uIGFueVxuICAgICAgLy8gYXR0ZW1wdCB0byBhY2Nlc3Mgd2luZG93LnNlc3Npb25TdG9yYWdlLlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKGZhbHNlLCAnW2hpc3RvcnldIFVuYWJsZSB0byBzYXZlIHN0YXRlOyBzZXNzaW9uU3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlIGR1ZSB0byBzZWN1cml0eSBzZXR0aW5ncycpIDogdW5kZWZpbmVkO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVycm9yLm5hbWUgPT09IFF1b3RhRXhjZWVkZWRFcnJvciAmJiB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBTYWZhcmkgXCJwcml2YXRlIG1vZGVcIiB0aHJvd3MgUXVvdGFFeGNlZWRlZEVycm9yLlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKGZhbHNlLCAnW2hpc3RvcnldIFVuYWJsZSB0byBzYXZlIHN0YXRlOyBzZXNzaW9uU3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlIGluIFNhZmFyaSBwcml2YXRlIG1vZGUnKSA6IHVuZGVmaW5lZDtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlYWRTdGF0ZShrZXkpIHtcbiAgdmFyIGpzb24gPSB1bmRlZmluZWQ7XG4gIHRyeSB7XG4gICAganNvbiA9IHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKGNyZWF0ZUtleShrZXkpKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IubmFtZSA9PT0gU2VjdXJpdHlFcnJvcikge1xuICAgICAgLy8gQmxvY2tpbmcgY29va2llcyBpbiBDaHJvbWUvRmlyZWZveC9TYWZhcmkgdGhyb3dzIFNlY3VyaXR5RXJyb3Igb24gYW55XG4gICAgICAvLyBhdHRlbXB0IHRvIGFjY2VzcyB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10oZmFsc2UsICdbaGlzdG9yeV0gVW5hYmxlIHRvIHJlYWQgc3RhdGU7IHNlc3Npb25TdG9yYWdlIGlzIG5vdCBhdmFpbGFibGUgZHVlIHRvIHNlY3VyaXR5IHNldHRpbmdzJykgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGlmIChqc29uKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGpzb24pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBJZ25vcmUgaW52YWxpZCBKU09OLlxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufSIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuYWRkRXZlbnRMaXN0ZW5lciA9IGFkZEV2ZW50TGlzdGVuZXI7XG5leHBvcnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSByZW1vdmVFdmVudExpc3RlbmVyO1xuZXhwb3J0cy5nZXRIYXNoUGF0aCA9IGdldEhhc2hQYXRoO1xuZXhwb3J0cy5yZXBsYWNlSGFzaFBhdGggPSByZXBsYWNlSGFzaFBhdGg7XG5leHBvcnRzLmdldFdpbmRvd1BhdGggPSBnZXRXaW5kb3dQYXRoO1xuZXhwb3J0cy5nbyA9IGdvO1xuZXhwb3J0cy5nZXRVc2VyQ29uZmlybWF0aW9uID0gZ2V0VXNlckNvbmZpcm1hdGlvbjtcbmV4cG9ydHMuc3VwcG9ydHNIaXN0b3J5ID0gc3VwcG9ydHNIaXN0b3J5O1xuZXhwb3J0cy5zdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCA9IHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoO1xuXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKG5vZGUsIGV2ZW50LCBsaXN0ZW5lcikge1xuICBpZiAobm9kZS5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpO1xuICB9IGVsc2Uge1xuICAgIG5vZGUuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudCwgbGlzdGVuZXIpIHtcbiAgaWYgKG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgfSBlbHNlIHtcbiAgICBub2RlLmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEhhc2hQYXRoKCkge1xuICAvLyBXZSBjYW4ndCB1c2Ugd2luZG93LmxvY2F0aW9uLmhhc2ggaGVyZSBiZWNhdXNlIGl0J3Mgbm90XG4gIC8vIGNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzIC0gRmlyZWZveCB3aWxsIHByZS1kZWNvZGUgaXQhXG4gIHJldHVybiB3aW5kb3cubG9jYXRpb24uaHJlZi5zcGxpdCgnIycpWzFdIHx8ICcnO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlSGFzaFBhdGgocGF0aCkge1xuICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZSh3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyB3aW5kb3cubG9jYXRpb24uc2VhcmNoICsgJyMnICsgcGF0aCk7XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvd1BhdGgoKSB7XG4gIHJldHVybiB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyB3aW5kb3cubG9jYXRpb24uc2VhcmNoICsgd2luZG93LmxvY2F0aW9uLmhhc2g7XG59XG5cbmZ1bmN0aW9uIGdvKG4pIHtcbiAgaWYgKG4pIHdpbmRvdy5oaXN0b3J5LmdvKG4pO1xufVxuXG5mdW5jdGlvbiBnZXRVc2VyQ29uZmlybWF0aW9uKG1lc3NhZ2UsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrKHdpbmRvdy5jb25maXJtKG1lc3NhZ2UpKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIEhUTUw1IGhpc3RvcnkgQVBJIGlzIHN1cHBvcnRlZC4gVGFrZW4gZnJvbSBNb2Rlcm5penIuXG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2hpc3RvcnkuanNcbiAqIGNoYW5nZWQgdG8gYXZvaWQgZmFsc2UgbmVnYXRpdmVzIGZvciBXaW5kb3dzIFBob25lczogaHR0cHM6Ly9naXRodWIuY29tL3JhY2t0L3JlYWN0LXJvdXRlci9pc3N1ZXMvNTg2XG4gKi9cblxuZnVuY3Rpb24gc3VwcG9ydHNIaXN0b3J5KCkge1xuICB2YXIgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICBpZiAoKHVhLmluZGV4T2YoJ0FuZHJvaWQgMi4nKSAhPT0gLTEgfHwgdWEuaW5kZXhPZignQW5kcm9pZCA0LjAnKSAhPT0gLTEpICYmIHVhLmluZGV4T2YoJ01vYmlsZSBTYWZhcmknKSAhPT0gLTEgJiYgdWEuaW5kZXhPZignQ2hyb21lJykgPT09IC0xICYmIHVhLmluZGV4T2YoJ1dpbmRvd3MgUGhvbmUnKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gRklYTUU6IFdvcmsgYXJvdW5kIG91ciBicm93c2VyIGhpc3Rvcnkgbm90IHdvcmtpbmcgY29ycmVjdGx5IG9uIENocm9tZVxuICAvLyBpT1M6IGh0dHBzOi8vZ2l0aHViLmNvbS9yYWNrdC9yZWFjdC1yb3V0ZXIvaXNzdWVzLzI1NjVcbiAgaWYgKHVhLmluZGV4T2YoJ0NyaU9TJykgIT09IC0xKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB3aW5kb3cuaGlzdG9yeSAmJiAncHVzaFN0YXRlJyBpbiB3aW5kb3cuaGlzdG9yeTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGZhbHNlIGlmIHVzaW5nIGdvKG4pIHdpdGggaGFzaCBoaXN0b3J5IGNhdXNlcyBhIGZ1bGwgcGFnZSByZWxvYWQuXG4gKi9cblxuZnVuY3Rpb24gc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2goKSB7XG4gIHZhciB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gIHJldHVybiB1YS5pbmRleE9mKCdGaXJlZm94JykgPT09IC0xO1xufSIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBjYW5Vc2VET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuZXhwb3J0cy5jYW5Vc2VET00gPSBjYW5Vc2VET007IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfQWN0aW9ucyA9IHJlcXVpcmUoJy4vQWN0aW9ucycpO1xuXG52YXIgX0V4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgX0RPTVV0aWxzID0gcmVxdWlyZSgnLi9ET01VdGlscycpO1xuXG52YXIgX0RPTVN0YXRlU3RvcmFnZSA9IHJlcXVpcmUoJy4vRE9NU3RhdGVTdG9yYWdlJyk7XG5cbnZhciBfY3JlYXRlRE9NSGlzdG9yeSA9IHJlcXVpcmUoJy4vY3JlYXRlRE9NSGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZURPTUhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlRE9NSGlzdG9yeSk7XG5cbnZhciBfcGFyc2VQYXRoID0gcmVxdWlyZSgnLi9wYXJzZVBhdGgnKTtcblxudmFyIF9wYXJzZVBhdGgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyc2VQYXRoKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgaGlzdG9yeSBvYmplY3QgdGhhdCB1c2VzIEhUTUw1J3MgaGlzdG9yeSBBUElcbiAqIChwdXNoU3RhdGUsIHJlcGxhY2VTdGF0ZSwgYW5kIHRoZSBwb3BzdGF0ZSBldmVudCkgdG8gbWFuYWdlIGhpc3RvcnkuXG4gKiBUaGlzIGlzIHRoZSByZWNvbW1lbmRlZCBtZXRob2Qgb2YgbWFuYWdpbmcgaGlzdG9yeSBpbiBicm93c2VycyBiZWNhdXNlXG4gKiBpdCBwcm92aWRlcyB0aGUgY2xlYW5lc3QgVVJMcy5cbiAqXG4gKiBOb3RlOiBJbiBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IHRoZSBIVE1MNSBoaXN0b3J5IEFQSSBmdWxsXG4gKiBwYWdlIHJlbG9hZHMgd2lsbCBiZSB1c2VkIHRvIHByZXNlcnZlIFVSTHMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJIaXN0b3J5KCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICFfRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF9pbnZhcmlhbnQyWydkZWZhdWx0J10oZmFsc2UsICdCcm93c2VyIGhpc3RvcnkgbmVlZHMgYSBET00nKSA6IF9pbnZhcmlhbnQyWydkZWZhdWx0J10oZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gIHZhciBmb3JjZVJlZnJlc2ggPSBvcHRpb25zLmZvcmNlUmVmcmVzaDtcblxuICB2YXIgaXNTdXBwb3J0ZWQgPSBfRE9NVXRpbHMuc3VwcG9ydHNIaXN0b3J5KCk7XG4gIHZhciB1c2VSZWZyZXNoID0gIWlzU3VwcG9ydGVkIHx8IGZvcmNlUmVmcmVzaDtcblxuICBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24oaGlzdG9yeVN0YXRlKSB7XG4gICAgaGlzdG9yeVN0YXRlID0gaGlzdG9yeVN0YXRlIHx8IHdpbmRvdy5oaXN0b3J5LnN0YXRlIHx8IHt9O1xuXG4gICAgdmFyIHBhdGggPSBfRE9NVXRpbHMuZ2V0V2luZG93UGF0aCgpO1xuICAgIHZhciBfaGlzdG9yeVN0YXRlID0gaGlzdG9yeVN0YXRlO1xuICAgIHZhciBrZXkgPSBfaGlzdG9yeVN0YXRlLmtleTtcblxuICAgIHZhciBzdGF0ZSA9IHVuZGVmaW5lZDtcbiAgICBpZiAoa2V5KSB7XG4gICAgICBzdGF0ZSA9IF9ET01TdGF0ZVN0b3JhZ2UucmVhZFN0YXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlID0gbnVsbDtcbiAgICAgIGtleSA9IGhpc3RvcnkuY3JlYXRlS2V5KCk7XG5cbiAgICAgIGlmIChpc1N1cHBvcnRlZCkgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKF9leHRlbmRzKHt9LCBoaXN0b3J5U3RhdGUsIHsga2V5OiBrZXkgfSksIG51bGwsIHBhdGgpO1xuICAgIH1cblxuICAgIHZhciBsb2NhdGlvbiA9IF9wYXJzZVBhdGgyWydkZWZhdWx0J10ocGF0aCk7XG5cbiAgICByZXR1cm4gaGlzdG9yeS5jcmVhdGVMb2NhdGlvbihfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIHsgc3RhdGU6IHN0YXRlIH0pLCB1bmRlZmluZWQsIGtleSk7XG4gIH1cblxuICBmdW5jdGlvbiBzdGFydFBvcFN0YXRlTGlzdGVuZXIoX3JlZikge1xuICAgIHZhciB0cmFuc2l0aW9uVG8gPSBfcmVmLnRyYW5zaXRpb25UbztcblxuICAgIGZ1bmN0aW9uIHBvcFN0YXRlTGlzdGVuZXIoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5zdGF0ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47IC8vIElnbm9yZSBleHRyYW5lb3VzIHBvcHN0YXRlIGV2ZW50cyBpbiBXZWJLaXQuXG5cbiAgICAgIHRyYW5zaXRpb25UbyhnZXRDdXJyZW50TG9jYXRpb24oZXZlbnQuc3RhdGUpKTtcbiAgICB9XG5cbiAgICBfRE9NVXRpbHMuYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csICdwb3BzdGF0ZScsIHBvcFN0YXRlTGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIF9ET01VdGlscy5yZW1vdmVFdmVudExpc3RlbmVyKHdpbmRvdywgJ3BvcHN0YXRlJywgcG9wU3RhdGVMaXN0ZW5lcik7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmlzaFRyYW5zaXRpb24obG9jYXRpb24pIHtcbiAgICB2YXIgYmFzZW5hbWUgPSBsb2NhdGlvbi5iYXNlbmFtZTtcbiAgICB2YXIgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZTtcbiAgICB2YXIgc2VhcmNoID0gbG9jYXRpb24uc2VhcmNoO1xuICAgIHZhciBoYXNoID0gbG9jYXRpb24uaGFzaDtcbiAgICB2YXIgc3RhdGUgPSBsb2NhdGlvbi5zdGF0ZTtcbiAgICB2YXIgYWN0aW9uID0gbG9jYXRpb24uYWN0aW9uO1xuICAgIHZhciBrZXkgPSBsb2NhdGlvbi5rZXk7XG5cbiAgICBpZiAoYWN0aW9uID09PSBfQWN0aW9ucy5QT1ApIHJldHVybjsgLy8gTm90aGluZyB0byBkby5cblxuICAgIF9ET01TdGF0ZVN0b3JhZ2Uuc2F2ZVN0YXRlKGtleSwgc3RhdGUpO1xuXG4gICAgdmFyIHBhdGggPSAoYmFzZW5hbWUgfHwgJycpICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xuICAgIHZhciBoaXN0b3J5U3RhdGUgPSB7XG4gICAgICBrZXk6IGtleVxuICAgIH07XG5cbiAgICBpZiAoYWN0aW9uID09PSBfQWN0aW9ucy5QVVNIKSB7XG4gICAgICBpZiAodXNlUmVmcmVzaCkge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHBhdGg7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gUHJldmVudCBsb2NhdGlvbiB1cGRhdGUuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShoaXN0b3J5U3RhdGUsIG51bGwsIHBhdGgpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJFUExBQ0VcbiAgICAgIGlmICh1c2VSZWZyZXNoKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKHBhdGgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIFByZXZlbnQgbG9jYXRpb24gdXBkYXRlLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoaGlzdG9yeVN0YXRlLCBudWxsLCBwYXRoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBoaXN0b3J5ID0gX2NyZWF0ZURPTUhpc3RvcnkyWydkZWZhdWx0J10oX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICBnZXRDdXJyZW50TG9jYXRpb246IGdldEN1cnJlbnRMb2NhdGlvbixcbiAgICBmaW5pc2hUcmFuc2l0aW9uOiBmaW5pc2hUcmFuc2l0aW9uLFxuICAgIHNhdmVTdGF0ZTogX0RPTVN0YXRlU3RvcmFnZS5zYXZlU3RhdGVcbiAgfSkpO1xuXG4gIHZhciBsaXN0ZW5lckNvdW50ID0gMCxcbiAgICAgIHN0b3BQb3BTdGF0ZUxpc3RlbmVyID0gdW5kZWZpbmVkO1xuXG4gIGZ1bmN0aW9uIGxpc3RlbkJlZm9yZShsaXN0ZW5lcikge1xuICAgIGlmICgrK2xpc3RlbmVyQ291bnQgPT09IDEpIHN0b3BQb3BTdGF0ZUxpc3RlbmVyID0gc3RhcnRQb3BTdGF0ZUxpc3RlbmVyKGhpc3RvcnkpO1xuXG4gICAgdmFyIHVubGlzdGVuID0gaGlzdG9yeS5saXN0ZW5CZWZvcmUobGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHVubGlzdGVuKCk7XG5cbiAgICAgIGlmICgtLWxpc3RlbmVyQ291bnQgPT09IDApIHN0b3BQb3BTdGF0ZUxpc3RlbmVyKCk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIGlmICgrK2xpc3RlbmVyQ291bnQgPT09IDEpIHN0b3BQb3BTdGF0ZUxpc3RlbmVyID0gc3RhcnRQb3BTdGF0ZUxpc3RlbmVyKGhpc3RvcnkpO1xuXG4gICAgdmFyIHVubGlzdGVuID0gaGlzdG9yeS5saXN0ZW4obGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHVubGlzdGVuKCk7XG5cbiAgICAgIGlmICgtLWxpc3RlbmVyQ291bnQgPT09IDApIHN0b3BQb3BTdGF0ZUxpc3RlbmVyKCk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgZnVuY3Rpb24gcmVnaXN0ZXJUcmFuc2l0aW9uSG9vayhob29rKSB7XG4gICAgaWYgKCsrbGlzdGVuZXJDb3VudCA9PT0gMSkgc3RvcFBvcFN0YXRlTGlzdGVuZXIgPSBzdGFydFBvcFN0YXRlTGlzdGVuZXIoaGlzdG9yeSk7XG5cbiAgICBoaXN0b3J5LnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2soaG9vayk7XG4gIH1cblxuICAvLyBkZXByZWNhdGVkXG4gIGZ1bmN0aW9uIHVucmVnaXN0ZXJUcmFuc2l0aW9uSG9vayhob29rKSB7XG4gICAgaGlzdG9yeS51bnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2soaG9vayk7XG5cbiAgICBpZiAoLS1saXN0ZW5lckNvdW50ID09PSAwKSBzdG9wUG9wU3RhdGVMaXN0ZW5lcigpO1xuICB9XG5cbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBoaXN0b3J5LCB7XG4gICAgbGlzdGVuQmVmb3JlOiBsaXN0ZW5CZWZvcmUsXG4gICAgbGlzdGVuOiBsaXN0ZW4sXG4gICAgcmVnaXN0ZXJUcmFuc2l0aW9uSG9vazogcmVnaXN0ZXJUcmFuc2l0aW9uSG9vayxcbiAgICB1bnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2s6IHVucmVnaXN0ZXJUcmFuc2l0aW9uSG9va1xuICB9KTtcbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gY3JlYXRlQnJvd3Nlckhpc3Rvcnk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9FeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIF9ET01VdGlscyA9IHJlcXVpcmUoJy4vRE9NVXRpbHMnKTtcblxudmFyIF9jcmVhdGVIaXN0b3J5ID0gcmVxdWlyZSgnLi9jcmVhdGVIaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlSGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVIaXN0b3J5KTtcblxuZnVuY3Rpb24gY3JlYXRlRE9NSGlzdG9yeShvcHRpb25zKSB7XG4gIHZhciBoaXN0b3J5ID0gX2NyZWF0ZUhpc3RvcnkyWydkZWZhdWx0J10oX2V4dGVuZHMoe1xuICAgIGdldFVzZXJDb25maXJtYXRpb246IF9ET01VdGlscy5nZXRVc2VyQ29uZmlybWF0aW9uXG4gIH0sIG9wdGlvbnMsIHtcbiAgICBnbzogX0RPTVV0aWxzLmdvXG4gIH0pKTtcblxuICBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICAhX0V4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlLCAnRE9NIGhpc3RvcnkgbmVlZHMgYSBET00nKSA6IF9pbnZhcmlhbnQyWydkZWZhdWx0J10oZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIGhpc3RvcnkubGlzdGVuKGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgaGlzdG9yeSwge1xuICAgIGxpc3RlbjogbGlzdGVuXG4gIH0pO1xufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBjcmVhdGVET01IaXN0b3J5O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiLy9pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJ1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfZGVlcEVxdWFsID0gcmVxdWlyZSgnZGVlcC1lcXVhbCcpO1xuXG52YXIgX2RlZXBFcXVhbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWVwRXF1YWwpO1xuXG52YXIgX0FzeW5jVXRpbHMgPSByZXF1aXJlKCcuL0FzeW5jVXRpbHMnKTtcblxudmFyIF9BY3Rpb25zID0gcmVxdWlyZSgnLi9BY3Rpb25zJyk7XG5cbnZhciBfY3JlYXRlTG9jYXRpb24yID0gcmVxdWlyZSgnLi9jcmVhdGVMb2NhdGlvbicpO1xuXG52YXIgX2NyZWF0ZUxvY2F0aW9uMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUxvY2F0aW9uMik7XG5cbnZhciBfcnVuVHJhbnNpdGlvbkhvb2sgPSByZXF1aXJlKCcuL3J1blRyYW5zaXRpb25Ib29rJyk7XG5cbnZhciBfcnVuVHJhbnNpdGlvbkhvb2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcnVuVHJhbnNpdGlvbkhvb2spO1xuXG52YXIgX3BhcnNlUGF0aCA9IHJlcXVpcmUoJy4vcGFyc2VQYXRoJyk7XG5cbnZhciBfcGFyc2VQYXRoMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcnNlUGF0aCk7XG5cbnZhciBfZGVwcmVjYXRlID0gcmVxdWlyZSgnLi9kZXByZWNhdGUnKTtcblxudmFyIF9kZXByZWNhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVwcmVjYXRlKTtcblxuZnVuY3Rpb24gY3JlYXRlUmFuZG9tS2V5KGxlbmd0aCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIGxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIGxvY2F0aW9uc0FyZUVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEucGF0aG5hbWUgPT09IGIucGF0aG5hbWUgJiYgYS5zZWFyY2ggPT09IGIuc2VhcmNoICYmXG4gIC8vYS5hY3Rpb24gPT09IGIuYWN0aW9uICYmIC8vIERpZmZlcmVudCBhY3Rpb24gIT09IGxvY2F0aW9uIGNoYW5nZS5cbiAgYS5rZXkgPT09IGIua2V5ICYmIF9kZWVwRXF1YWwyWydkZWZhdWx0J10oYS5zdGF0ZSwgYi5zdGF0ZSk7XG59XG5cbnZhciBEZWZhdWx0S2V5TGVuZ3RoID0gNjtcblxuZnVuY3Rpb24gY3JlYXRlSGlzdG9yeSgpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcbiAgdmFyIGdldEN1cnJlbnRMb2NhdGlvbiA9IG9wdGlvbnMuZ2V0Q3VycmVudExvY2F0aW9uO1xuICB2YXIgZmluaXNoVHJhbnNpdGlvbiA9IG9wdGlvbnMuZmluaXNoVHJhbnNpdGlvbjtcbiAgdmFyIHNhdmVTdGF0ZSA9IG9wdGlvbnMuc2F2ZVN0YXRlO1xuICB2YXIgZ28gPSBvcHRpb25zLmdvO1xuICB2YXIga2V5TGVuZ3RoID0gb3B0aW9ucy5rZXlMZW5ndGg7XG4gIHZhciBnZXRVc2VyQ29uZmlybWF0aW9uID0gb3B0aW9ucy5nZXRVc2VyQ29uZmlybWF0aW9uO1xuXG4gIGlmICh0eXBlb2Yga2V5TGVuZ3RoICE9PSAnbnVtYmVyJykga2V5TGVuZ3RoID0gRGVmYXVsdEtleUxlbmd0aDtcblxuICB2YXIgdHJhbnNpdGlvbkhvb2tzID0gW107XG5cbiAgZnVuY3Rpb24gbGlzdGVuQmVmb3JlKGhvb2spIHtcbiAgICB0cmFuc2l0aW9uSG9va3MucHVzaChob29rKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB0cmFuc2l0aW9uSG9va3MgPSB0cmFuc2l0aW9uSG9va3MuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtICE9PSBob29rO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBhbGxLZXlzID0gW107XG4gIHZhciBjaGFuZ2VMaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIGxvY2F0aW9uID0gdW5kZWZpbmVkO1xuXG4gIGZ1bmN0aW9uIGdldEN1cnJlbnQoKSB7XG4gICAgaWYgKHBlbmRpbmdMb2NhdGlvbiAmJiBwZW5kaW5nTG9jYXRpb24uYWN0aW9uID09PSBfQWN0aW9ucy5QT1ApIHtcbiAgICAgIHJldHVybiBhbGxLZXlzLmluZGV4T2YocGVuZGluZ0xvY2F0aW9uLmtleSk7XG4gICAgfSBlbHNlIGlmIChsb2NhdGlvbikge1xuICAgICAgcmV0dXJuIGFsbEtleXMuaW5kZXhPZihsb2NhdGlvbi5rZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTG9jYXRpb24obmV3TG9jYXRpb24pIHtcbiAgICB2YXIgY3VycmVudCA9IGdldEN1cnJlbnQoKTtcblxuICAgIGxvY2F0aW9uID0gbmV3TG9jYXRpb247XG5cbiAgICBpZiAobG9jYXRpb24uYWN0aW9uID09PSBfQWN0aW9ucy5QVVNIKSB7XG4gICAgICBhbGxLZXlzID0gW10uY29uY2F0KGFsbEtleXMuc2xpY2UoMCwgY3VycmVudCArIDEpLCBbbG9jYXRpb24ua2V5XSk7XG4gICAgfSBlbHNlIGlmIChsb2NhdGlvbi5hY3Rpb24gPT09IF9BY3Rpb25zLlJFUExBQ0UpIHtcbiAgICAgIGFsbEtleXNbY3VycmVudF0gPSBsb2NhdGlvbi5rZXk7XG4gICAgfVxuXG4gICAgY2hhbmdlTGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICBsaXN0ZW5lcihsb2NhdGlvbik7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICBjaGFuZ2VMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICBpZiAobG9jYXRpb24pIHtcbiAgICAgIGxpc3RlbmVyKGxvY2F0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9sb2NhdGlvbiA9IGdldEN1cnJlbnRMb2NhdGlvbigpO1xuICAgICAgYWxsS2V5cyA9IFtfbG9jYXRpb24ua2V5XTtcbiAgICAgIHVwZGF0ZUxvY2F0aW9uKF9sb2NhdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNoYW5nZUxpc3RlbmVycyA9IGNoYW5nZUxpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gIT09IGxpc3RlbmVyO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgX0FzeW5jVXRpbHMubG9vcEFzeW5jKHRyYW5zaXRpb25Ib29rcy5sZW5ndGgsIGZ1bmN0aW9uIChpbmRleCwgbmV4dCwgZG9uZSkge1xuICAgICAgX3J1blRyYW5zaXRpb25Ib29rMlsnZGVmYXVsdCddKHRyYW5zaXRpb25Ib29rc1tpbmRleF0sIGxvY2F0aW9uLCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICAgIGRvbmUocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICBpZiAoZ2V0VXNlckNvbmZpcm1hdGlvbiAmJiB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZ2V0VXNlckNvbmZpcm1hdGlvbihtZXNzYWdlLCBmdW5jdGlvbiAob2spIHtcbiAgICAgICAgICBjYWxsYmFjayhvayAhPT0gZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKG1lc3NhZ2UgIT09IGZhbHNlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHZhciBwZW5kaW5nTG9jYXRpb24gPSB1bmRlZmluZWQ7XG5cbiAgZnVuY3Rpb24gdHJhbnNpdGlvblRvKG5leHRMb2NhdGlvbikge1xuICAgIGlmIChsb2NhdGlvbiAmJiBsb2NhdGlvbnNBcmVFcXVhbChsb2NhdGlvbiwgbmV4dExvY2F0aW9uKSkgcmV0dXJuOyAvLyBOb3RoaW5nIHRvIGRvLlxuXG4gICAgcGVuZGluZ0xvY2F0aW9uID0gbmV4dExvY2F0aW9uO1xuXG4gICAgY29uZmlybVRyYW5zaXRpb25UbyhuZXh0TG9jYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKHBlbmRpbmdMb2NhdGlvbiAhPT0gbmV4dExvY2F0aW9uKSByZXR1cm47IC8vIFRyYW5zaXRpb24gd2FzIGludGVycnVwdGVkLlxuXG4gICAgICBpZiAob2spIHtcbiAgICAgICAgLy8gdHJlYXQgUFVTSCB0byBjdXJyZW50IHBhdGggbGlrZSBSRVBMQUNFIHRvIGJlIGNvbnNpc3RlbnQgd2l0aCBicm93c2Vyc1xuICAgICAgICBpZiAobmV4dExvY2F0aW9uLmFjdGlvbiA9PT0gX0FjdGlvbnMuUFVTSCkge1xuICAgICAgICAgIHZhciBwcmV2UGF0aCA9IGNyZWF0ZVBhdGgobG9jYXRpb24pO1xuICAgICAgICAgIHZhciBuZXh0UGF0aCA9IGNyZWF0ZVBhdGgobmV4dExvY2F0aW9uKTtcblxuICAgICAgICAgIGlmIChuZXh0UGF0aCA9PT0gcHJldlBhdGgpIG5leHRMb2NhdGlvbi5hY3Rpb24gPSBfQWN0aW9ucy5SRVBMQUNFO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpbmlzaFRyYW5zaXRpb24obmV4dExvY2F0aW9uKSAhPT0gZmFsc2UpIHVwZGF0ZUxvY2F0aW9uKG5leHRMb2NhdGlvbik7XG4gICAgICB9IGVsc2UgaWYgKGxvY2F0aW9uICYmIG5leHRMb2NhdGlvbi5hY3Rpb24gPT09IF9BY3Rpb25zLlBPUCkge1xuICAgICAgICB2YXIgcHJldkluZGV4ID0gYWxsS2V5cy5pbmRleE9mKGxvY2F0aW9uLmtleSk7XG4gICAgICAgIHZhciBuZXh0SW5kZXggPSBhbGxLZXlzLmluZGV4T2YobmV4dExvY2F0aW9uLmtleSk7XG5cbiAgICAgICAgaWYgKHByZXZJbmRleCAhPT0gLTEgJiYgbmV4dEluZGV4ICE9PSAtMSkgZ28ocHJldkluZGV4IC0gbmV4dEluZGV4KTsgLy8gUmVzdG9yZSB0aGUgVVJMLlxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaChsb2NhdGlvbikge1xuICAgIHRyYW5zaXRpb25UbyhjcmVhdGVMb2NhdGlvbihsb2NhdGlvbiwgX0FjdGlvbnMuUFVTSCwgY3JlYXRlS2V5KCkpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcGxhY2UobG9jYXRpb24pIHtcbiAgICB0cmFuc2l0aW9uVG8oY3JlYXRlTG9jYXRpb24obG9jYXRpb24sIF9BY3Rpb25zLlJFUExBQ0UsIGNyZWF0ZUtleSgpKSk7XG4gIH1cblxuICBmdW5jdGlvbiBnb0JhY2soKSB7XG4gICAgZ28oLTEpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ29Gb3J3YXJkKCkge1xuICAgIGdvKDEpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICAgIHJldHVybiBjcmVhdGVSYW5kb21LZXkoa2V5TGVuZ3RoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVBhdGgobG9jYXRpb24pIHtcbiAgICBpZiAobG9jYXRpb24gPT0gbnVsbCB8fCB0eXBlb2YgbG9jYXRpb24gPT09ICdzdHJpbmcnKSByZXR1cm4gbG9jYXRpb247XG5cbiAgICB2YXIgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZTtcbiAgICB2YXIgc2VhcmNoID0gbG9jYXRpb24uc2VhcmNoO1xuICAgIHZhciBoYXNoID0gbG9jYXRpb24uaGFzaDtcblxuICAgIHZhciByZXN1bHQgPSBwYXRobmFtZTtcblxuICAgIGlmIChzZWFyY2gpIHJlc3VsdCArPSBzZWFyY2g7XG5cbiAgICBpZiAoaGFzaCkgcmVzdWx0ICs9IGhhc2g7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSHJlZihsb2NhdGlvbikge1xuICAgIHJldHVybiBjcmVhdGVQYXRoKGxvY2F0aW9uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uLCBhY3Rpb24pIHtcbiAgICB2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gY3JlYXRlS2V5KCkgOiBhcmd1bWVudHNbMl07XG5cbiAgICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgIC8vd2FybmluZyhcbiAgICAgIC8vICBmYWxzZSxcbiAgICAgIC8vICAnVGhlIHN0YXRlICgybmQpIGFyZ3VtZW50IHRvIGhpc3RvcnkuY3JlYXRlTG9jYXRpb24gaXMgZGVwcmVjYXRlZDsgdXNlIGEgJyArXG4gICAgICAvLyAgJ2xvY2F0aW9uIGRlc2NyaXB0b3IgaW5zdGVhZCdcbiAgICAgIC8vKVxuXG4gICAgICBpZiAodHlwZW9mIGxvY2F0aW9uID09PSAnc3RyaW5nJykgbG9jYXRpb24gPSBfcGFyc2VQYXRoMlsnZGVmYXVsdCddKGxvY2F0aW9uKTtcblxuICAgICAgbG9jYXRpb24gPSBfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIHsgc3RhdGU6IGFjdGlvbiB9KTtcblxuICAgICAgYWN0aW9uID0ga2V5O1xuICAgICAga2V5ID0gYXJndW1lbnRzWzNdIHx8IGNyZWF0ZUtleSgpO1xuICAgIH1cblxuICAgIHJldHVybiBfY3JlYXRlTG9jYXRpb24zWydkZWZhdWx0J10obG9jYXRpb24sIGFjdGlvbiwga2V5KTtcbiAgfVxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgZnVuY3Rpb24gc2V0U3RhdGUoc3RhdGUpIHtcbiAgICBpZiAobG9jYXRpb24pIHtcbiAgICAgIHVwZGF0ZUxvY2F0aW9uU3RhdGUobG9jYXRpb24sIHN0YXRlKTtcbiAgICAgIHVwZGF0ZUxvY2F0aW9uKGxvY2F0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXBkYXRlTG9jYXRpb25TdGF0ZShnZXRDdXJyZW50TG9jYXRpb24oKSwgc3RhdGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUxvY2F0aW9uU3RhdGUobG9jYXRpb24sIHN0YXRlKSB7XG4gICAgbG9jYXRpb24uc3RhdGUgPSBfZXh0ZW5kcyh7fSwgbG9jYXRpb24uc3RhdGUsIHN0YXRlKTtcbiAgICBzYXZlU3RhdGUobG9jYXRpb24ua2V5LCBsb2NhdGlvbi5zdGF0ZSk7XG4gIH1cblxuICAvLyBkZXByZWNhdGVkXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyVHJhbnNpdGlvbkhvb2soaG9vaykge1xuICAgIGlmICh0cmFuc2l0aW9uSG9va3MuaW5kZXhPZihob29rKSA9PT0gLTEpIHRyYW5zaXRpb25Ib29rcy5wdXNoKGhvb2spO1xuICB9XG5cbiAgLy8gZGVwcmVjYXRlZFxuICBmdW5jdGlvbiB1bnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2soaG9vaykge1xuICAgIHRyYW5zaXRpb25Ib29rcyA9IHRyYW5zaXRpb25Ib29rcy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtICE9PSBob29rO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gZGVwcmVjYXRlZFxuICBmdW5jdGlvbiBwdXNoU3RhdGUoc3RhdGUsIHBhdGgpIHtcbiAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSBwYXRoID0gX3BhcnNlUGF0aDJbJ2RlZmF1bHQnXShwYXRoKTtcblxuICAgIHB1c2goX2V4dGVuZHMoeyBzdGF0ZTogc3RhdGUgfSwgcGF0aCkpO1xuICB9XG5cbiAgLy8gZGVwcmVjYXRlZFxuICBmdW5jdGlvbiByZXBsYWNlU3RhdGUoc3RhdGUsIHBhdGgpIHtcbiAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSBwYXRoID0gX3BhcnNlUGF0aDJbJ2RlZmF1bHQnXShwYXRoKTtcblxuICAgIHJlcGxhY2UoX2V4dGVuZHMoeyBzdGF0ZTogc3RhdGUgfSwgcGF0aCkpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBsaXN0ZW5CZWZvcmU6IGxpc3RlbkJlZm9yZSxcbiAgICBsaXN0ZW46IGxpc3RlbixcbiAgICB0cmFuc2l0aW9uVG86IHRyYW5zaXRpb25UbyxcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGdvQmFjazogZ29CYWNrLFxuICAgIGdvRm9yd2FyZDogZ29Gb3J3YXJkLFxuICAgIGNyZWF0ZUtleTogY3JlYXRlS2V5LFxuICAgIGNyZWF0ZVBhdGg6IGNyZWF0ZVBhdGgsXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBjcmVhdGVMb2NhdGlvbjogY3JlYXRlTG9jYXRpb24sXG5cbiAgICBzZXRTdGF0ZTogX2RlcHJlY2F0ZTJbJ2RlZmF1bHQnXShzZXRTdGF0ZSwgJ3NldFN0YXRlIGlzIGRlcHJlY2F0ZWQ7IHVzZSBsb2NhdGlvbi5rZXkgdG8gc2F2ZSBzdGF0ZSBpbnN0ZWFkJyksXG4gICAgcmVnaXN0ZXJUcmFuc2l0aW9uSG9vazogX2RlcHJlY2F0ZTJbJ2RlZmF1bHQnXShyZWdpc3RlclRyYW5zaXRpb25Ib29rLCAncmVnaXN0ZXJUcmFuc2l0aW9uSG9vayBpcyBkZXByZWNhdGVkOyB1c2UgbGlzdGVuQmVmb3JlIGluc3RlYWQnKSxcbiAgICB1bnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2s6IF9kZXByZWNhdGUyWydkZWZhdWx0J10odW5yZWdpc3RlclRyYW5zaXRpb25Ib29rLCAndW5yZWdpc3RlclRyYW5zaXRpb25Ib29rIGlzIGRlcHJlY2F0ZWQ7IHVzZSB0aGUgY2FsbGJhY2sgcmV0dXJuZWQgZnJvbSBsaXN0ZW5CZWZvcmUgaW5zdGVhZCcpLFxuICAgIHB1c2hTdGF0ZTogX2RlcHJlY2F0ZTJbJ2RlZmF1bHQnXShwdXNoU3RhdGUsICdwdXNoU3RhdGUgaXMgZGVwcmVjYXRlZDsgdXNlIHB1c2ggaW5zdGVhZCcpLFxuICAgIHJlcGxhY2VTdGF0ZTogX2RlcHJlY2F0ZTJbJ2RlZmF1bHQnXShyZXBsYWNlU3RhdGUsICdyZXBsYWNlU3RhdGUgaXMgZGVwcmVjYXRlZDsgdXNlIHJlcGxhY2UgaW5zdGVhZCcpXG4gIH07XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGNyZWF0ZUhpc3Rvcnk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIvL2ltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9BY3Rpb25zID0gcmVxdWlyZSgnLi9BY3Rpb25zJyk7XG5cbnZhciBfcGFyc2VQYXRoID0gcmVxdWlyZSgnLi9wYXJzZVBhdGgnKTtcblxudmFyIF9wYXJzZVBhdGgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyc2VQYXRoKTtcblxuZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24oKSB7XG4gIHZhciBsb2NhdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/ICcvJyA6IGFyZ3VtZW50c1swXTtcbiAgdmFyIGFjdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IF9BY3Rpb25zLlBPUCA6IGFyZ3VtZW50c1sxXTtcbiAgdmFyIGtleSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBhcmd1bWVudHNbMl07XG5cbiAgdmFyIF9mb3VydGhBcmcgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDMgfHwgYXJndW1lbnRzWzNdID09PSB1bmRlZmluZWQgPyBudWxsIDogYXJndW1lbnRzWzNdO1xuXG4gIGlmICh0eXBlb2YgbG9jYXRpb24gPT09ICdzdHJpbmcnKSBsb2NhdGlvbiA9IF9wYXJzZVBhdGgyWydkZWZhdWx0J10obG9jYXRpb24pO1xuXG4gIGlmICh0eXBlb2YgYWN0aW9uID09PSAnb2JqZWN0Jykge1xuICAgIC8vd2FybmluZyhcbiAgICAvLyAgZmFsc2UsXG4gICAgLy8gICdUaGUgc3RhdGUgKDJuZCkgYXJndW1lbnQgdG8gY3JlYXRlTG9jYXRpb24gaXMgZGVwcmVjYXRlZDsgdXNlIGEgJyArXG4gICAgLy8gICdsb2NhdGlvbiBkZXNjcmlwdG9yIGluc3RlYWQnXG4gICAgLy8pXG5cbiAgICBsb2NhdGlvbiA9IF9leHRlbmRzKHt9LCBsb2NhdGlvbiwgeyBzdGF0ZTogYWN0aW9uIH0pO1xuXG4gICAgYWN0aW9uID0ga2V5IHx8IF9BY3Rpb25zLlBPUDtcbiAgICBrZXkgPSBfZm91cnRoQXJnO1xuICB9XG5cbiAgdmFyIHBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWUgfHwgJy8nO1xuICB2YXIgc2VhcmNoID0gbG9jYXRpb24uc2VhcmNoIHx8ICcnO1xuICB2YXIgaGFzaCA9IGxvY2F0aW9uLmhhc2ggfHwgJyc7XG4gIHZhciBzdGF0ZSA9IGxvY2F0aW9uLnN0YXRlIHx8IG51bGw7XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZTogcGF0aG5hbWUsXG4gICAgc2VhcmNoOiBzZWFyY2gsXG4gICAgaGFzaDogaGFzaCxcbiAgICBzdGF0ZTogc3RhdGUsXG4gICAgYWN0aW9uOiBhY3Rpb24sXG4gICAga2V5OiBrZXlcbiAgfTtcbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gY3JlYXRlTG9jYXRpb247XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIvL2ltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnXG5cblwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZnVuY3Rpb24gZGVwcmVjYXRlKGZuKSB7XG4gIHJldHVybiBmbjtcbiAgLy9yZXR1cm4gZnVuY3Rpb24gKCkge1xuICAvLyAgd2FybmluZyhmYWxzZSwgJ1toaXN0b3J5XSAnICsgbWVzc2FnZSlcbiAgLy8gIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gIC8vfVxufVxuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGRlcHJlY2F0ZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5mdW5jdGlvbiBleHRyYWN0UGF0aChzdHJpbmcpIHtcbiAgdmFyIG1hdGNoID0gc3RyaW5nLm1hdGNoKC9eaHR0cHM/OlxcL1xcL1teXFwvXSovKTtcblxuICBpZiAobWF0Y2ggPT0gbnVsbCkgcmV0dXJuIHN0cmluZztcblxuICByZXR1cm4gc3RyaW5nLnN1YnN0cmluZyhtYXRjaFswXS5sZW5ndGgpO1xufVxuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGV4dHJhY3RQYXRoO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfZXh0cmFjdFBhdGggPSByZXF1aXJlKCcuL2V4dHJhY3RQYXRoJyk7XG5cbnZhciBfZXh0cmFjdFBhdGgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXh0cmFjdFBhdGgpO1xuXG5mdW5jdGlvbiBwYXJzZVBhdGgocGF0aCkge1xuICB2YXIgcGF0aG5hbWUgPSBfZXh0cmFjdFBhdGgyWydkZWZhdWx0J10ocGF0aCk7XG4gIHZhciBzZWFyY2ggPSAnJztcbiAgdmFyIGhhc2ggPSAnJztcblxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10ocGF0aCA9PT0gcGF0aG5hbWUsICdBIHBhdGggbXVzdCBiZSBwYXRobmFtZSArIHNlYXJjaCArIGhhc2ggb25seSwgbm90IGEgZnVsbHkgcXVhbGlmaWVkIFVSTCBsaWtlIFwiJXNcIicsIHBhdGgpIDogdW5kZWZpbmVkO1xuXG4gIHZhciBoYXNoSW5kZXggPSBwYXRobmFtZS5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoSW5kZXggIT09IC0xKSB7XG4gICAgaGFzaCA9IHBhdGhuYW1lLnN1YnN0cmluZyhoYXNoSW5kZXgpO1xuICAgIHBhdGhuYW1lID0gcGF0aG5hbWUuc3Vic3RyaW5nKDAsIGhhc2hJbmRleCk7XG4gIH1cblxuICB2YXIgc2VhcmNoSW5kZXggPSBwYXRobmFtZS5pbmRleE9mKCc/Jyk7XG4gIGlmIChzZWFyY2hJbmRleCAhPT0gLTEpIHtcbiAgICBzZWFyY2ggPSBwYXRobmFtZS5zdWJzdHJpbmcoc2VhcmNoSW5kZXgpO1xuICAgIHBhdGhuYW1lID0gcGF0aG5hbWUuc3Vic3RyaW5nKDAsIHNlYXJjaEluZGV4KTtcbiAgfVxuXG4gIGlmIChwYXRobmFtZSA9PT0gJycpIHBhdGhuYW1lID0gJy8nO1xuXG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWU6IHBhdGhuYW1lLFxuICAgIHNlYXJjaDogc2VhcmNoLFxuICAgIGhhc2g6IGhhc2hcbiAgfTtcbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gcGFyc2VQYXRoO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBydW5UcmFuc2l0aW9uSG9vayhob29rLCBsb2NhdGlvbiwgY2FsbGJhY2spIHtcbiAgdmFyIHJlc3VsdCA9IGhvb2sobG9jYXRpb24sIGNhbGxiYWNrKTtcblxuICBpZiAoaG9vay5sZW5ndGggPCAyKSB7XG4gICAgLy8gQXNzdW1lIHRoZSBob29rIHJ1bnMgc3luY2hyb25vdXNseSBhbmQgYXV0b21hdGljYWxseVxuICAgIC8vIGNhbGwgdGhlIGNhbGxiYWNrIHdpdGggdGhlIHJldHVybiB2YWx1ZS5cbiAgICBjYWxsYmFjayhyZXN1bHQpO1xuICB9IGVsc2Uge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShyZXN1bHQgPT09IHVuZGVmaW5lZCwgJ1lvdSBzaG91bGQgbm90IFwicmV0dXJuXCIgaW4gYSB0cmFuc2l0aW9uIGhvb2sgd2l0aCBhIGNhbGxiYWNrIGFyZ3VtZW50OyBjYWxsIHRoZSBjYWxsYmFjayBpbnN0ZWFkJykgOiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gcnVuVHJhbnNpdGlvbkhvb2s7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciBpbnZhcmlhbnQgPSBmdW5jdGlvbihjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICtcbiAgICAgICAgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJ1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107IH0pXG4gICAgICApO1xuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuIiwiLyohXG4gKiBMby1EYXNoIHYwLjkuMiA8aHR0cDovL2xvZGFzaC5jb20+XG4gKiAoYykgMjAxMiBKb2huLURhdmlkIERhbHRvbiA8aHR0cDovL2FsbHlvdWNhbmxlZXQuY29tLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS40LjIgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnPlxuICogKGMpIDIwMDktMjAxMiBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgSW5jLlxuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG47KGZ1bmN0aW9uKHdpbmRvdywgdW5kZWZpbmVkKSB7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYCAqL1xuICB2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBhbmQgdXNlIGl0IGFzIGB3aW5kb3dgICovXG4gIHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG4gIGlmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCkge1xuICAgIHdpbmRvdyA9IGZyZWVHbG9iYWw7XG4gIH1cblxuICAvKiogVXNlZCBmb3IgYXJyYXkgYW5kIG9iamVjdCBtZXRob2QgcmVmZXJlbmNlcyAqL1xuICB2YXIgYXJyYXlSZWYgPSBbXSxcbiAgICAgIC8vIGF2b2lkIGEgQ2xvc3VyZSBDb21waWxlciBidWcgYnkgY3JlYXRpdmVseSBjcmVhdGluZyBhbiBvYmplY3RcbiAgICAgIG9iamVjdFJlZiA9IG5ldyBmdW5jdGlvbigpe307XG5cbiAgLyoqIFVzZWQgdG8gZ2VuZXJhdGUgdW5pcXVlIElEcyAqL1xuICB2YXIgaWRDb3VudGVyID0gMDtcblxuICAvKiogVXNlZCBpbnRlcm5hbGx5IHRvIGluZGljYXRlIHZhcmlvdXMgdGhpbmdzICovXG4gIHZhciBpbmRpY2F0b3JPYmplY3QgPSBvYmplY3RSZWY7XG5cbiAgLyoqIFVzZWQgYnkgYGNhY2hlZENvbnRhaW5zYCBhcyB0aGUgZGVmYXVsdCBzaXplIHdoZW4gb3B0aW1pemF0aW9ucyBhcmUgZW5hYmxlZCBmb3IgbGFyZ2UgYXJyYXlzICovXG4gIHZhciBsYXJnZUFycmF5U2l6ZSA9IDMwO1xuXG4gIC8qKiBVc2VkIHRvIHJlc3RvcmUgdGhlIG9yaWdpbmFsIGBfYCByZWZlcmVuY2UgaW4gYG5vQ29uZmxpY3RgICovXG4gIHZhciBvbGREYXNoID0gd2luZG93Ll87XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IHRlbXBsYXRlIGRlbGltaXRlciB2YWx1ZXMgdGhhdCByZXF1aXJlIGEgd2l0aC1zdGF0ZW1lbnQgKi9cbiAgdmFyIHJlQ29tcGxleERlbGltaXRlciA9IC9bLT8rPSF+KiUmXjw+fHsoXFwvXXxcXFtcXER8XFxiKD86ZGVsZXRlfGlufGluc3RhbmNlb2Z8bmV3fHR5cGVvZnx2b2lkKVxcYi87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggSFRNTCBlbnRpdGllcyAqL1xuICB2YXIgcmVFc2NhcGVkSHRtbCA9IC8mKD86YW1wfGx0fGd0fHF1b3R8I3gyNyk7L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggZW1wdHkgc3RyaW5nIGxpdGVyYWxzIGluIGNvbXBpbGVkIHRlbXBsYXRlIHNvdXJjZSAqL1xuICB2YXIgcmVFbXB0eVN0cmluZ0xlYWRpbmcgPSAvXFxiX19wIFxcKz0gJyc7L2csXG4gICAgICByZUVtcHR5U3RyaW5nTWlkZGxlID0gL1xcYihfX3AgXFwrPSkgJycgXFwrL2csXG4gICAgICByZUVtcHR5U3RyaW5nVHJhaWxpbmcgPSAvKF9fZVxcKC4qP1xcKXxcXGJfX3RcXCkpIFxcK1xcbicnOy9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHJlZ2V4cCBmbGFncyBmcm9tIHRoZWlyIGNvZXJjZWQgc3RyaW5nIHZhbHVlcyAqL1xuICB2YXIgcmVGbGFncyA9IC9cXHcqJC87XG5cbiAgLyoqIFVzZWQgdG8gaW5zZXJ0IHRoZSBkYXRhIG9iamVjdCB2YXJpYWJsZSBpbnRvIGNvbXBpbGVkIHRlbXBsYXRlIHNvdXJjZSAqL1xuICB2YXIgcmVJbnNlcnRWYXJpYWJsZSA9IC8oPzpfX2V8X190ID0gKVxcKFxccyooPyFbXFxkXFxzXCInXXx0aGlzXFwuKS9nO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUgKi9cbiAgdmFyIHJlTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gICAgKG9iamVjdFJlZi52YWx1ZU9mICsgJycpXG4gICAgICAucmVwbGFjZSgvWy4qKz9ePSE6JHt9KCl8W1xcXVxcL1xcXFxdL2csICdcXFxcJCYnKVxuICAgICAgLnJlcGxhY2UoL3ZhbHVlT2Z8Zm9yIFteXFxdXSsvZywgJy4rPycpICsgJyQnXG4gICk7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gbWF0Y2ggRVM2IHRlbXBsYXRlIGRlbGltaXRlcnNcbiAgICogaHR0cDovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtNy44LjZcbiAgICovXG4gIHZhciByZUVzVGVtcGxhdGUgPSAvXFwkXFx7KCg/Oig/PVxcXFw/KVxcXFw/W1xcc1xcU10pKj8pfS9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIFwiaW50ZXJwb2xhdGVcIiB0ZW1wbGF0ZSBkZWxpbWl0ZXJzICovXG4gIHZhciByZUludGVycG9sYXRlID0gLzwlPShbXFxzXFxTXSs/KSU+L2c7XG5cbiAgLyoqIFVzZWQgdG8gZW5zdXJlIGNhcHR1cmluZyBvcmRlciBvZiB0ZW1wbGF0ZSBkZWxpbWl0ZXJzICovXG4gIHZhciByZU5vTWF0Y2ggPSAvKCReKS87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggSFRNTCBjaGFyYWN0ZXJzICovXG4gIHZhciByZVVuZXNjYXBlZEh0bWwgPSAvWyY8PlwiJ10vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCB1bmVzY2FwZWQgY2hhcmFjdGVycyBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMgKi9cbiAgdmFyIHJlVW5lc2NhcGVkU3RyaW5nID0gL1snXFxuXFxyXFx0XFx1MjAyOFxcdTIwMjlcXFxcXS9nO1xuXG4gIC8qKiBVc2VkIHRvIGZpeCB0aGUgSlNjcmlwdCBbW0RvbnRFbnVtXV0gYnVnICovXG4gIHZhciBzaGFkb3dlZCA9IFtcbiAgICAnY29uc3RydWN0b3InLCAnaGFzT3duUHJvcGVydHknLCAnaXNQcm90b3R5cGVPZicsICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG4gICAgJ3RvTG9jYWxlU3RyaW5nJywgJ3RvU3RyaW5nJywgJ3ZhbHVlT2YnXG4gIF07XG5cbiAgLyoqIFVzZWQgdG8gbWFrZSB0ZW1wbGF0ZSBzb3VyY2VVUkxzIGVhc2llciB0byBpZGVudGlmeSAqL1xuICB2YXIgdGVtcGxhdGVDb3VudGVyID0gMDtcblxuICAvKiogTmF0aXZlIG1ldGhvZCBzaG9ydGN1dHMgKi9cbiAgdmFyIGNlaWwgPSBNYXRoLmNlaWwsXG4gICAgICBjb25jYXQgPSBhcnJheVJlZi5jb25jYXQsXG4gICAgICBmbG9vciA9IE1hdGguZmxvb3IsXG4gICAgICBnZXRQcm90b3R5cGVPZiA9IHJlTmF0aXZlLnRlc3QoZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YpICYmIGdldFByb3RvdHlwZU9mLFxuICAgICAgaGFzT3duUHJvcGVydHkgPSBvYmplY3RSZWYuaGFzT3duUHJvcGVydHksXG4gICAgICBwdXNoID0gYXJyYXlSZWYucHVzaCxcbiAgICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UmVmLnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICAgICAgc2xpY2UgPSBhcnJheVJlZi5zbGljZSxcbiAgICAgIHRvU3RyaW5nID0gb2JqZWN0UmVmLnRvU3RyaW5nO1xuXG4gIC8qIE5hdGl2ZSBtZXRob2Qgc2hvcnRjdXRzIGZvciBtZXRob2RzIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzICovXG4gIHZhciBuYXRpdmVCaW5kID0gcmVOYXRpdmUudGVzdChuYXRpdmVCaW5kID0gc2xpY2UuYmluZCkgJiYgbmF0aXZlQmluZCxcbiAgICAgIG5hdGl2ZUlzQXJyYXkgPSByZU5hdGl2ZS50ZXN0KG5hdGl2ZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KSAmJiBuYXRpdmVJc0FycmF5LFxuICAgICAgbmF0aXZlSXNGaW5pdGUgPSB3aW5kb3cuaXNGaW5pdGUsXG4gICAgICBuYXRpdmVJc05hTiA9IHdpbmRvdy5pc05hTixcbiAgICAgIG5hdGl2ZUtleXMgPSByZU5hdGl2ZS50ZXN0KG5hdGl2ZUtleXMgPSBPYmplY3Qua2V5cykgJiYgbmF0aXZlS2V5cyxcbiAgICAgIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgICAgbmF0aXZlTWluID0gTWF0aC5taW4sXG4gICAgICBuYXRpdmVSYW5kb20gPSBNYXRoLnJhbmRvbTtcblxuICAvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHNob3J0Y3V0cyAqL1xuICB2YXIgYXJnc0NsYXNzID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgICBhcnJheUNsYXNzID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICAgIGJvb2xDbGFzcyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICAgIGRhdGVDbGFzcyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICAgIGZ1bmNDbGFzcyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgICBudW1iZXJDbGFzcyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgICAgb2JqZWN0Q2xhc3MgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICAgIHJlZ2V4cENsYXNzID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgICBzdHJpbmdDbGFzcyA9ICdbb2JqZWN0IFN0cmluZ10nO1xuXG4gIC8qKlxuICAgKiBEZXRlY3QgdGhlIEpTY3JpcHQgW1tEb250RW51bV1dIGJ1ZzpcbiAgICpcbiAgICogSW4gSUUgPCA5IGFuIG9iamVjdHMgb3duIHByb3BlcnRpZXMsIHNoYWRvd2luZyBub24tZW51bWVyYWJsZSBvbmVzLCBhcmVcbiAgICogbWFkZSBub24tZW51bWVyYWJsZSBhcyB3ZWxsLlxuICAgKi9cbiAgdmFyIGhhc0RvbnRFbnVtQnVnO1xuXG4gIC8qKiBEZXRlY3QgaWYgb3duIHByb3BlcnRpZXMgYXJlIGl0ZXJhdGVkIGFmdGVyIGluaGVyaXRlZCBwcm9wZXJ0aWVzIChJRSA8IDkpICovXG4gIHZhciBpdGVyYXRlc093bkxhc3Q7XG5cbiAgLyoqXG4gICAqIERldGVjdCBpZiBgQXJyYXkjc2hpZnRgIGFuZCBgQXJyYXkjc3BsaWNlYCBhdWdtZW50IGFycmF5LWxpa2Ugb2JqZWN0c1xuICAgKiBpbmNvcnJlY3RseTpcbiAgICpcbiAgICogRmlyZWZveCA8IDEwLCBJRSBjb21wYXRpYmlsaXR5IG1vZGUsIGFuZCBJRSA8IDkgaGF2ZSBidWdneSBBcnJheSBgc2hpZnQoKWBcbiAgICogYW5kIGBzcGxpY2UoKWAgZnVuY3Rpb25zIHRoYXQgZmFpbCB0byByZW1vdmUgdGhlIGxhc3QgZWxlbWVudCwgYHZhbHVlWzBdYCxcbiAgICogb2YgYXJyYXktbGlrZSBvYmplY3RzIGV2ZW4gdGhvdWdoIHRoZSBgbGVuZ3RoYCBwcm9wZXJ0eSBpcyBzZXQgdG8gYDBgLlxuICAgKiBUaGUgYHNoaWZ0KClgIG1ldGhvZCBpcyBidWdneSBpbiBJRSA4IGNvbXBhdGliaWxpdHkgbW9kZSwgd2hpbGUgYHNwbGljZSgpYFxuICAgKiBpcyBidWdneSByZWdhcmRsZXNzIG9mIG1vZGUgaW4gSUUgPCA5IGFuZCBidWdneSBpbiBjb21wYXRpYmlsaXR5IG1vZGUgaW4gSUUgOS5cbiAgICovXG4gIHZhciBoYXNPYmplY3RTcGxpY2VCdWcgPSAoaGFzT2JqZWN0U3BsaWNlQnVnID0geyAnMCc6IDEsICdsZW5ndGgnOiAxIH0sXG4gICAgYXJyYXlSZWYuc3BsaWNlLmNhbGwoaGFzT2JqZWN0U3BsaWNlQnVnLCAwLCAxKSwgaGFzT2JqZWN0U3BsaWNlQnVnWzBdKTtcblxuICAvKiogRGV0ZWN0IGlmIGFuIGBhcmd1bWVudHNgIG9iamVjdCdzIGluZGV4ZXMgYXJlIG5vbi1lbnVtZXJhYmxlIChJRSA8IDkpICovXG4gIHZhciBub0FyZ3NFbnVtID0gdHJ1ZTtcblxuICAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHByb3BzID0gW107XG4gICAgZnVuY3Rpb24gY3RvcigpIHsgdGhpcy54ID0gMTsgfVxuICAgIGN0b3IucHJvdG90eXBlID0geyAndmFsdWVPZic6IDEsICd5JzogMSB9O1xuICAgIGZvciAodmFyIHByb3AgaW4gbmV3IGN0b3IpIHsgcHJvcHMucHVzaChwcm9wKTsgfVxuICAgIGZvciAocHJvcCBpbiBhcmd1bWVudHMpIHsgbm9BcmdzRW51bSA9ICFwcm9wOyB9XG5cbiAgICBoYXNEb250RW51bUJ1ZyA9ICEvdmFsdWVPZi8udGVzdChwcm9wcyk7XG4gICAgaXRlcmF0ZXNPd25MYXN0ID0gcHJvcHNbMF0gIT0gJ3gnO1xuICB9KDEpKTtcblxuICAvKiogRGV0ZWN0IGlmIGFuIGBhcmd1bWVudHNgIG9iamVjdCdzIFtbQ2xhc3NdXSBpcyB1bnJlc29sdmFibGUgKEZpcmVmb3ggPCA0LCBJRSA8IDkpICovXG4gIHZhciBub0FyZ3NDbGFzcyA9ICFpc0FyZ3VtZW50cyhhcmd1bWVudHMpO1xuXG4gIC8qKiBEZXRlY3QgaWYgYEFycmF5I3NsaWNlYCBjYW5ub3QgYmUgdXNlZCB0byBjb252ZXJ0IHN0cmluZ3MgdG8gYXJyYXlzIChPcGVyYSA8IDEwLjUyKSAqL1xuICB2YXIgbm9BcnJheVNsaWNlT25TdHJpbmdzID0gc2xpY2UuY2FsbCgneCcpWzBdICE9ICd4JztcblxuICAvKipcbiAgICogRGV0ZWN0IGxhY2sgb2Ygc3VwcG9ydCBmb3IgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIGJ5IGluZGV4OlxuICAgKlxuICAgKiBJRSA8IDggY2FuJ3QgYWNjZXNzIGNoYXJhY3RlcnMgYnkgaW5kZXggYW5kIElFIDggY2FuIG9ubHkgYWNjZXNzXG4gICAqIGNoYXJhY3RlcnMgYnkgaW5kZXggb24gc3RyaW5nIGxpdGVyYWxzLlxuICAgKi9cbiAgdmFyIG5vQ2hhckJ5SW5kZXggPSAoJ3gnWzBdICsgT2JqZWN0KCd4JylbMF0pICE9ICd4eCc7XG5cbiAgLyoqXG4gICAqIERldGVjdCBpZiBhIG5vZGUncyBbW0NsYXNzXV0gaXMgdW5yZXNvbHZhYmxlIChJRSA8IDkpXG4gICAqIGFuZCB0aGF0IHRoZSBKUyBlbmdpbmUgd29uJ3QgZXJyb3Igd2hlbiBhdHRlbXB0aW5nIHRvIGNvZXJjZSBhbiBvYmplY3QgdG9cbiAgICogYSBzdHJpbmcgd2l0aG91dCBhIGB0b1N0cmluZ2AgcHJvcGVydHkgdmFsdWUgb2YgYHR5cGVvZmAgXCJmdW5jdGlvblwiLlxuICAgKi9cbiAgdHJ5IHtcbiAgICB2YXIgbm9Ob2RlQ2xhc3MgPSAoeyAndG9TdHJpbmcnOiAwIH0gKyAnJywgdG9TdHJpbmcuY2FsbCh3aW5kb3cuZG9jdW1lbnQgfHwgMCkgPT0gb2JqZWN0Q2xhc3MpO1xuICB9IGNhdGNoKGUpIHsgfVxuXG4gIC8qIERldGVjdCBpZiBgRnVuY3Rpb24jYmluZGAgZXhpc3RzIGFuZCBpcyBpbmZlcnJlZCB0byBiZSBmYXN0IChhbGwgYnV0IFY4KSAqL1xuICB2YXIgaXNCaW5kRmFzdCA9IG5hdGl2ZUJpbmQgJiYgL1xcbnxPcGVyYS8udGVzdChuYXRpdmVCaW5kICsgdG9TdHJpbmcuY2FsbCh3aW5kb3cub3BlcmEpKTtcblxuICAvKiBEZXRlY3QgaWYgYE9iamVjdC5rZXlzYCBleGlzdHMgYW5kIGlzIGluZmVycmVkIHRvIGJlIGZhc3QgKElFLCBPcGVyYSwgVjgpICovXG4gIHZhciBpc0tleXNGYXN0ID0gbmF0aXZlS2V5cyAmJiAvXi4rJHx0cnVlLy50ZXN0KG5hdGl2ZUtleXMgKyAhIXdpbmRvdy5hdHRhY2hFdmVudCk7XG5cbiAgLyoqXG4gICAqIERldGVjdCBpZiBzb3VyY2VVUkwgc3ludGF4IGlzIHVzYWJsZSB3aXRob3V0IGVycm9yaW5nOlxuICAgKlxuICAgKiBUaGUgSlMgZW5naW5lIGluIEFkb2JlIHByb2R1Y3RzLCBsaWtlIEluRGVzaWduLCB3aWxsIHRocm93IGEgc3ludGF4IGVycm9yXG4gICAqIHdoZW4gaXQgZW5jb3VudGVycyBhIHNpbmdsZSBsaW5lIGNvbW1lbnQgYmVnaW5uaW5nIHdpdGggdGhlIGBAYCBzeW1ib2wuXG4gICAqXG4gICAqIFRoZSBKUyBlbmdpbmUgaW4gTmFyd2hhbCB3aWxsIGdlbmVyYXRlIHRoZSBmdW5jdGlvbiBgZnVuY3Rpb24gYW5vbnltb3VzKCl7Ly99YFxuICAgKiBhbmQgdGhyb3cgYSBzeW50YXggZXJyb3IuXG4gICAqXG4gICAqIEF2b2lkIGNvbW1lbnRzIGJlZ2lubmluZyBgQGAgc3ltYm9scyBpbiBJRSBiZWNhdXNlIHRoZXkgYXJlIHBhcnQgb2YgaXRzXG4gICAqIG5vbi1zdGFuZGFyZCBjb25kaXRpb25hbCBjb21waWxhdGlvbiBzdXBwb3J0LlxuICAgKiBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvMTIxaHp0azModj12cy45NCkuYXNweFxuICAgKi9cbiAgdHJ5IHtcbiAgICB2YXIgdXNlU291cmNlVVJMID0gKEZ1bmN0aW9uKCcvL0AnKSgpLCAhd2luZG93LmF0dGFjaEV2ZW50KTtcbiAgfSBjYXRjaChlKSB7IH1cblxuICAvKiogVXNlZCB0byBpZGVudGlmeSBvYmplY3QgY2xhc3NpZmljYXRpb25zIHRoYXQgYF8uY2xvbmVgIHN1cHBvcnRzICovXG4gIHZhciBjbG9uZWFibGVDbGFzc2VzID0ge307XG4gIGNsb25lYWJsZUNsYXNzZXNbYXJnc0NsYXNzXSA9IGNsb25lYWJsZUNsYXNzZXNbZnVuY0NsYXNzXSA9IGZhbHNlO1xuICBjbG9uZWFibGVDbGFzc2VzW2FycmF5Q2xhc3NdID0gY2xvbmVhYmxlQ2xhc3Nlc1tib29sQ2xhc3NdID0gY2xvbmVhYmxlQ2xhc3Nlc1tkYXRlQ2xhc3NdID1cbiAgY2xvbmVhYmxlQ2xhc3Nlc1tudW1iZXJDbGFzc10gPSBjbG9uZWFibGVDbGFzc2VzW29iamVjdENsYXNzXSA9IGNsb25lYWJsZUNsYXNzZXNbcmVnZXhwQ2xhc3NdID1cbiAgY2xvbmVhYmxlQ2xhc3Nlc1tzdHJpbmdDbGFzc10gPSB0cnVlO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVybWluZSBpZiB2YWx1ZXMgYXJlIG9mIHRoZSBsYW5ndWFnZSB0eXBlIE9iamVjdCAqL1xuICB2YXIgb2JqZWN0VHlwZXMgPSB7XG4gICAgJ2Jvb2xlYW4nOiBmYWxzZSxcbiAgICAnZnVuY3Rpb24nOiB0cnVlLFxuICAgICdvYmplY3QnOiB0cnVlLFxuICAgICdudW1iZXInOiBmYWxzZSxcbiAgICAnc3RyaW5nJzogZmFsc2UsXG4gICAgJ3VuZGVmaW5lZCc6IGZhbHNlXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMgKi9cbiAgdmFyIHN0cmluZ0VzY2FwZXMgPSB7XG4gICAgJ1xcXFwnOiAnXFxcXCcsXG4gICAgXCInXCI6IFwiJ1wiLFxuICAgICdcXG4nOiAnbicsXG4gICAgJ1xccic6ICdyJyxcbiAgICAnXFx0JzogJ3QnLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogVGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAbmFtZSBfXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAY2F0ZWdvcnkgQ2hhaW5pbmdcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAgaW4gYSBgbG9kYXNoYCBpbnN0YW5jZS5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhIGBsb2Rhc2hgIGluc3RhbmNlLlxuICAgKi9cbiAgZnVuY3Rpb24gbG9kYXNoKHZhbHVlKSB7XG4gICAgLy8gZXhpdCBlYXJseSBpZiBhbHJlYWR5IHdyYXBwZWRcbiAgICBpZiAodmFsdWUgJiYgdmFsdWUuX193cmFwcGVkX18pIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgLy8gYWxsb3cgaW52b2tpbmcgYGxvZGFzaGAgd2l0aG91dCB0aGUgYG5ld2Agb3BlcmF0b3JcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgbG9kYXNoKSkge1xuICAgICAgcmV0dXJuIG5ldyBsb2Rhc2godmFsdWUpO1xuICAgIH1cbiAgICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQnkgZGVmYXVsdCwgdGhlIHRlbXBsYXRlIGRlbGltaXRlcnMgdXNlZCBieSBMby1EYXNoIGFyZSBzaW1pbGFyIHRvIHRob3NlIGluXG4gICAqIGVtYmVkZGVkIFJ1YnkgKEVSQikuIENoYW5nZSB0aGUgZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZVxuICAgKiBkZWxpbWl0ZXJzLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEB0eXBlIE9iamVjdFxuICAgKi9cbiAgbG9kYXNoLnRlbXBsYXRlU2V0dGluZ3MgPSB7XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGJlIEhUTUwtZXNjYXBlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICogQHR5cGUgUmVnRXhwXG4gICAgICovXG4gICAgJ2VzY2FwZSc6IC88JS0oW1xcc1xcU10rPyklPi9nLFxuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBkZXRlY3QgY29kZSB0byBiZSBldmFsdWF0ZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAqIEB0eXBlIFJlZ0V4cFxuICAgICAqL1xuICAgICdldmFsdWF0ZSc6IC88JShbXFxzXFxTXSs/KSU+L2csXG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGluamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICogQHR5cGUgUmVnRXhwXG4gICAgICovXG4gICAgJ2ludGVycG9sYXRlJzogcmVJbnRlcnBvbGF0ZSxcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gcmVmZXJlbmNlIHRoZSBkYXRhIG9iamVjdCBpbiB0aGUgdGVtcGxhdGUgdGV4dC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICovXG4gICAgJ3ZhcmlhYmxlJzogJydcbiAgfTtcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogVGhlIHRlbXBsYXRlIHVzZWQgdG8gY3JlYXRlIGl0ZXJhdG9yIGZ1bmN0aW9ucy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmVjdH0gZGF0YSBUaGUgZGF0YSBvYmplY3QgdXNlZCB0byBwb3B1bGF0ZSB0aGUgdGV4dC5cbiAgICogQHJldHVybnMge1N0cmluZ30gUmV0dXJucyB0aGUgaW50ZXJwb2xhdGVkIHRleHQuXG4gICAqL1xuICB2YXIgaXRlcmF0b3JUZW1wbGF0ZSA9IHRlbXBsYXRlKFxuICAgIC8vIGNvbmRpdGlvbmFsIHN0cmljdCBtb2RlXG4gICAgJzwlIGlmIChvYmoudXNlU3RyaWN0KSB7ICU+XFwndXNlIHN0cmljdFxcJztcXG48JSB9ICU+JyArXG5cbiAgICAvLyB0aGUgYGl0ZXJhdGVlYCBtYXkgYmUgcmVhc3NpZ25lZCBieSB0aGUgYHRvcGAgc25pcHBldFxuICAgICd2YXIgaW5kZXgsIHZhbHVlLCBpdGVyYXRlZSA9IDwlPSBmaXJzdEFyZyAlPiwgJyArXG4gICAgLy8gYXNzaWduIHRoZSBgcmVzdWx0YCB2YXJpYWJsZSBhbiBpbml0aWFsIHZhbHVlXG4gICAgJ3Jlc3VsdCA9IDwlPSBmaXJzdEFyZyAlPjtcXG4nICtcbiAgICAvLyBleGl0IGVhcmx5IGlmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBmYWxzZXlcbiAgICAnaWYgKCE8JT0gZmlyc3RBcmcgJT4pIHJldHVybiByZXN1bHQ7XFxuJyArXG4gICAgLy8gYWRkIGNvZGUgYmVmb3JlIHRoZSBpdGVyYXRpb24gYnJhbmNoZXNcbiAgICAnPCU9IHRvcCAlPjtcXG4nICtcblxuICAgIC8vIGFycmF5LWxpa2UgaXRlcmF0aW9uOlxuICAgICc8JSBpZiAoYXJyYXlMb29wKSB7ICU+JyArXG4gICAgJ3ZhciBsZW5ndGggPSBpdGVyYXRlZS5sZW5ndGg7IGluZGV4ID0gLTE7XFxuJyArXG4gICAgJ2lmICh0eXBlb2YgbGVuZ3RoID09IFxcJ251bWJlclxcJykgeycgK1xuXG4gICAgLy8gYWRkIHN1cHBvcnQgZm9yIGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyBieSBpbmRleCBpZiBuZWVkZWRcbiAgICAnICA8JSBpZiAobm9DaGFyQnlJbmRleCkgeyAlPlxcbicgK1xuICAgICcgIGlmIChpc1N0cmluZyhpdGVyYXRlZSkpIHtcXG4nICtcbiAgICAnICAgIGl0ZXJhdGVlID0gaXRlcmF0ZWUuc3BsaXQoXFwnXFwnKVxcbicgK1xuICAgICcgIH0nICtcbiAgICAnICA8JSB9ICU+XFxuJyArXG5cbiAgICAvLyBpdGVyYXRlIG92ZXIgdGhlIGFycmF5LWxpa2UgdmFsdWVcbiAgICAnICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xcbicgK1xuICAgICcgICAgdmFsdWUgPSBpdGVyYXRlZVtpbmRleF07XFxuJyArXG4gICAgJyAgICA8JT0gYXJyYXlMb29wICU+XFxuJyArXG4gICAgJyAgfVxcbicgK1xuICAgICd9XFxuJyArXG4gICAgJ2Vsc2UgeycgK1xuXG4gICAgLy8gb2JqZWN0IGl0ZXJhdGlvbjpcbiAgICAvLyBhZGQgc3VwcG9ydCBmb3IgaXRlcmF0aW5nIG92ZXIgYGFyZ3VtZW50c2Agb2JqZWN0cyBpZiBuZWVkZWRcbiAgICAnICA8JSAgfSBlbHNlIGlmIChub0FyZ3NFbnVtKSB7ICU+XFxuJyArXG4gICAgJyAgdmFyIGxlbmd0aCA9IGl0ZXJhdGVlLmxlbmd0aDsgaW5kZXggPSAtMTtcXG4nICtcbiAgICAnICBpZiAobGVuZ3RoICYmIGlzQXJndW1lbnRzKGl0ZXJhdGVlKSkge1xcbicgK1xuICAgICcgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcXG4nICtcbiAgICAnICAgICAgdmFsdWUgPSBpdGVyYXRlZVtpbmRleCArPSBcXCdcXCddO1xcbicgK1xuICAgICcgICAgICA8JT0gb2JqZWN0TG9vcCAlPlxcbicgK1xuICAgICcgICAgfVxcbicgK1xuICAgICcgIH0gZWxzZSB7JyArXG4gICAgJyAgPCUgfSAlPicgK1xuXG4gICAgLy8gRmlyZWZveCA8IDMuNiwgT3BlcmEgPiA5LjUwIC0gT3BlcmEgPCAxMS42MCwgYW5kIFNhZmFyaSA8IDUuMVxuICAgIC8vIChpZiB0aGUgcHJvdG90eXBlIG9yIGEgcHJvcGVydHkgb24gdGhlIHByb3RvdHlwZSBoYXMgYmVlbiBzZXQpXG4gICAgLy8gaW5jb3JyZWN0bHkgc2V0cyBhIGZ1bmN0aW9uJ3MgYHByb3RvdHlwZWAgcHJvcGVydHkgW1tFbnVtZXJhYmxlXV1cbiAgICAvLyB2YWx1ZSB0byBgdHJ1ZWAuIEJlY2F1c2Ugb2YgdGhpcyBMby1EYXNoIHN0YW5kYXJkaXplcyBvbiBza2lwcGluZ1xuICAgIC8vIHRoZSB0aGUgYHByb3RvdHlwZWAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIHJlZ2FyZGxlc3Mgb2YgaXRzXG4gICAgLy8gW1tFbnVtZXJhYmxlXV0gdmFsdWUuXG4gICAgJyAgPCUgaWYgKCFoYXNEb250RW51bUJ1ZykgeyAlPlxcbicgK1xuICAgICcgIHZhciBza2lwUHJvdG8gPSB0eXBlb2YgaXRlcmF0ZWUgPT0gXFwnZnVuY3Rpb25cXCcgJiYgXFxuJyArXG4gICAgJyAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGl0ZXJhdGVlLCBcXCdwcm90b3R5cGVcXCcpO1xcbicgK1xuICAgICcgIDwlIH0gJT4nICtcblxuICAgIC8vIGl0ZXJhdGUgb3duIHByb3BlcnRpZXMgdXNpbmcgYE9iamVjdC5rZXlzYCBpZiBpdCdzIGZhc3RcbiAgICAnICA8JSBpZiAoaXNLZXlzRmFzdCAmJiB1c2VIYXMpIHsgJT5cXG4nICtcbiAgICAnICB2YXIgb3duSW5kZXggPSAtMSxcXG4nICtcbiAgICAnICAgICAgb3duUHJvcHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgaXRlcmF0ZWVdID8gbmF0aXZlS2V5cyhpdGVyYXRlZSkgOiBbXSxcXG4nICtcbiAgICAnICAgICAgbGVuZ3RoID0gb3duUHJvcHMubGVuZ3RoO1xcblxcbicgK1xuICAgICcgIHdoaWxlICgrK293bkluZGV4IDwgbGVuZ3RoKSB7XFxuJyArXG4gICAgJyAgICBpbmRleCA9IG93blByb3BzW293bkluZGV4XTtcXG4nICtcbiAgICAnICAgIDwlIGlmICghaGFzRG9udEVudW1CdWcpIHsgJT5pZiAoIShza2lwUHJvdG8gJiYgaW5kZXggPT0gXFwncHJvdG90eXBlXFwnKSkge1xcbiAgPCUgfSAlPicgK1xuICAgICcgICAgdmFsdWUgPSBpdGVyYXRlZVtpbmRleF07XFxuJyArXG4gICAgJyAgICA8JT0gb2JqZWN0TG9vcCAlPlxcbicgK1xuICAgICcgICAgPCUgaWYgKCFoYXNEb250RW51bUJ1ZykgeyAlPn1cXG48JSB9ICU+JyArXG4gICAgJyAgfScgK1xuXG4gICAgLy8gZWxzZSB1c2luZyBhIGZvci1pbiBsb29wXG4gICAgJyAgPCUgfSBlbHNlIHsgJT5cXG4nICtcbiAgICAnICBmb3IgKGluZGV4IGluIGl0ZXJhdGVlKSB7PCUnICtcbiAgICAnICAgIGlmICghaGFzRG9udEVudW1CdWcgfHwgdXNlSGFzKSB7ICU+XFxuICAgIGlmICg8JScgK1xuICAgICcgICAgICBpZiAoIWhhc0RvbnRFbnVtQnVnKSB7ICU+IShza2lwUHJvdG8gJiYgaW5kZXggPT0gXFwncHJvdG90eXBlXFwnKTwlIH0nICtcbiAgICAnICAgICAgaWYgKCFoYXNEb250RW51bUJ1ZyAmJiB1c2VIYXMpIHsgJT4gJiYgPCUgfScgK1xuICAgICcgICAgICBpZiAodXNlSGFzKSB7ICU+aGFzT3duUHJvcGVydHkuY2FsbChpdGVyYXRlZSwgaW5kZXgpPCUgfScgK1xuICAgICcgICAgJT4pIHsnICtcbiAgICAnICAgIDwlIH0gJT5cXG4nICtcbiAgICAnICAgIHZhbHVlID0gaXRlcmF0ZWVbaW5kZXhdO1xcbicgK1xuICAgICcgICAgPCU9IG9iamVjdExvb3AgJT47JyArXG4gICAgJyAgICA8JSBpZiAoIWhhc0RvbnRFbnVtQnVnIHx8IHVzZUhhcykgeyAlPlxcbiAgICB9PCUgfSAlPlxcbicgK1xuICAgICcgIH0nICtcbiAgICAnICA8JSB9ICU+JyArXG5cbiAgICAvLyBCZWNhdXNlIElFIDwgOSBjYW4ndCBzZXQgdGhlIGBbW0VudW1lcmFibGVdXWAgYXR0cmlidXRlIG9mIGFuXG4gICAgLy8gZXhpc3RpbmcgcHJvcGVydHkgYW5kIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IG9mIGEgcHJvdG90eXBlXG4gICAgLy8gZGVmYXVsdHMgdG8gbm9uLWVudW1lcmFibGUsIExvLURhc2ggc2tpcHMgdGhlIGBjb25zdHJ1Y3RvcmBcbiAgICAvLyBwcm9wZXJ0eSB3aGVuIGl0IGluZmVycyBpdCdzIGl0ZXJhdGluZyBvdmVyIGEgYHByb3RvdHlwZWAgb2JqZWN0LlxuICAgICcgIDwlIGlmIChoYXNEb250RW51bUJ1ZykgeyAlPlxcblxcbicgK1xuICAgICcgIHZhciBjdG9yID0gaXRlcmF0ZWUuY29uc3RydWN0b3I7XFxuJyArXG4gICAgJyAgICA8JSBmb3IgKHZhciBrID0gMDsgayA8IDc7IGsrKykgeyAlPlxcbicgK1xuICAgICcgIGluZGV4ID0gXFwnPCU9IHNoYWRvd2VkW2tdICU+XFwnO1xcbicgK1xuICAgICcgIGlmICg8JScgK1xuICAgICcgICAgICBpZiAoc2hhZG93ZWRba10gPT0gXFwnY29uc3RydWN0b3JcXCcpIHsnICtcbiAgICAnICAgICAgICAlPiEoY3RvciAmJiBjdG9yLnByb3RvdHlwZSA9PT0gaXRlcmF0ZWUpICYmIDwlJyArXG4gICAgJyAgICAgIH0gJT5oYXNPd25Qcm9wZXJ0eS5jYWxsKGl0ZXJhdGVlLCBpbmRleCkpIHtcXG4nICtcbiAgICAnICAgIHZhbHVlID0gaXRlcmF0ZWVbaW5kZXhdO1xcbicgK1xuICAgICcgICAgPCU9IG9iamVjdExvb3AgJT5cXG4nICtcbiAgICAnICB9JyArXG4gICAgJyAgICA8JSB9ICU+JyArXG4gICAgJyAgPCUgfSAlPicgK1xuICAgICcgIDwlIGlmIChhcnJheUxvb3AgfHwgbm9BcmdzRW51bSkgeyAlPlxcbn08JSB9ICU+XFxuJyArXG5cbiAgICAvLyBhZGQgY29kZSB0byB0aGUgYm90dG9tIG9mIHRoZSBpdGVyYXRpb24gZnVuY3Rpb25cbiAgICAnPCU9IGJvdHRvbSAlPjtcXG4nICtcbiAgICAvLyBmaW5hbGx5LCByZXR1cm4gdGhlIGByZXN1bHRgXG4gICAgJ3JldHVybiByZXN1bHQnXG4gICk7XG5cbiAgLyoqXG4gICAqIFJldXNhYmxlIGl0ZXJhdG9yIG9wdGlvbnMgc2hhcmVkIGJ5IGBmb3JFYWNoYCwgYGZvckluYCwgYW5kIGBmb3JPd25gLlxuICAgKi9cbiAgdmFyIGZvckVhY2hJdGVyYXRvck9wdGlvbnMgPSB7XG4gICAgJ2FyZ3MnOiAnY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcnLFxuICAgICd0b3AnOiAnY2FsbGJhY2sgPSBjcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZyknLFxuICAgICdhcnJheUxvb3AnOiAnaWYgKGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikgPT09IGZhbHNlKSByZXR1cm4gcmVzdWx0JyxcbiAgICAnb2JqZWN0TG9vcCc6ICdpZiAoY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSA9PT0gZmFsc2UpIHJldHVybiByZXN1bHQnXG4gIH07XG5cbiAgLyoqIFJldXNhYmxlIGl0ZXJhdG9yIG9wdGlvbnMgZm9yIGBkZWZhdWx0c2AsIGFuZCBgZXh0ZW5kYCAqL1xuICB2YXIgZXh0ZW5kSXRlcmF0b3JPcHRpb25zID0ge1xuICAgICd1c2VIYXMnOiBmYWxzZSxcbiAgICAnYXJncyc6ICdvYmplY3QnLFxuICAgICd0b3AnOlxuICAgICAgJ2ZvciAodmFyIGFyZ3NJbmRleCA9IDEsIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBhcmdzSW5kZXggPCBhcmdzTGVuZ3RoOyBhcmdzSW5kZXgrKykge1xcbicgK1xuICAgICAgJyAgaWYgKGl0ZXJhdGVlID0gYXJndW1lbnRzW2FyZ3NJbmRleF0pIHsnLFxuICAgICdvYmplY3RMb29wJzogJ3Jlc3VsdFtpbmRleF0gPSB2YWx1ZScsXG4gICAgJ2JvdHRvbSc6ICcgIH1cXG59J1xuICB9O1xuXG4gIC8qKiBSZXVzYWJsZSBpdGVyYXRvciBvcHRpb25zIGZvciBgZm9ySW5gIGFuZCBgZm9yT3duYCAqL1xuICB2YXIgZm9yT3duSXRlcmF0b3JPcHRpb25zID0ge1xuICAgICdhcnJheUxvb3AnOiBudWxsXG4gIH07XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBvcHRpbWl6ZWQgdG8gc2VhcmNoIGxhcmdlIGFycmF5cyBmb3IgYSBnaXZlbiBgdmFsdWVgLFxuICAgKiBzdGFydGluZyBhdCBgZnJvbUluZGV4YCwgdXNpbmcgc3RyaWN0IGVxdWFsaXR5IGZvciBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtsYXJnZVNpemU9MzBdIFRoZSBsZW5ndGggYXQgd2hpY2ggYW4gYXJyYXkgaXMgY29uc2lkZXJlZCBsYXJnZS5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGNhY2hlZENvbnRhaW5zKGFycmF5LCBmcm9tSW5kZXgsIGxhcmdlU2l6ZSkge1xuICAgIGZyb21JbmRleCB8fCAoZnJvbUluZGV4ID0gMCk7XG5cbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICBpc0xhcmdlID0gKGxlbmd0aCAtIGZyb21JbmRleCkgPj0gKGxhcmdlU2l6ZSB8fCBsYXJnZUFycmF5U2l6ZSk7XG5cbiAgICBpZiAoaXNMYXJnZSkge1xuICAgICAgdmFyIGNhY2hlID0ge30sXG4gICAgICAgICAgaW5kZXggPSBmcm9tSW5kZXggLSAxO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAvLyBtYW51YWxseSBjb2VyY2UgYHZhbHVlYCB0byBhIHN0cmluZyBiZWNhdXNlIGBoYXNPd25Qcm9wZXJ0eWAsIGluIHNvbWVcbiAgICAgICAgLy8gb2xkZXIgdmVyc2lvbnMgb2YgRmlyZWZveCwgY29lcmNlcyBvYmplY3RzIGluY29ycmVjdGx5XG4gICAgICAgIHZhciBrZXkgPSBhcnJheVtpbmRleF0gKyAnJztcbiAgICAgICAgKGhhc093blByb3BlcnR5LmNhbGwoY2FjaGUsIGtleSkgPyBjYWNoZVtrZXldIDogKGNhY2hlW2tleV0gPSBbXSkpLnB1c2goYXJyYXlbaW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAoaXNMYXJnZSkge1xuICAgICAgICB2YXIga2V5ID0gdmFsdWUgKyAnJztcbiAgICAgICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoY2FjaGUsIGtleSkgJiYgaW5kZXhPZihjYWNoZVtrZXldLCB2YWx1ZSkgPiAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSA+IC0xO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLm1heGAgYW5kIGBfLm1pbmAgYXMgdGhlIGRlZmF1bHQgYGNhbGxiYWNrYCB3aGVuIGEgZ2l2ZW5cbiAgICogYGNvbGxlY3Rpb25gIGlzIGEgc3RyaW5nIHZhbHVlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIGNoYXJhY3RlciB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIHRoZSBjb2RlIHVuaXQgb2YgZ2l2ZW4gY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gY2hhckF0Q2FsbGJhY2sodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUuY2hhckNvZGVBdCgwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBzb3J0QnlgIHRvIGNvbXBhcmUgdHJhbnNmb3JtZWQgYGNvbGxlY3Rpb25gIHZhbHVlcywgc3RhYmxlIHNvcnRpbmdcbiAgICogdGhlbSBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBvYmplY3QgdG8gY29tcGFyZSB0byBgYmAuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gY29tcGFyZSB0byBgYWAuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIG9mIGAxYCBvciBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gY29tcGFyZUFzY2VuZGluZyhhLCBiKSB7XG4gICAgdmFyIGFpID0gYS5pbmRleCxcbiAgICAgICAgYmkgPSBiLmluZGV4O1xuXG4gICAgYSA9IGEuY3JpdGVyaWE7XG4gICAgYiA9IGIuY3JpdGVyaWE7XG5cbiAgICAvLyBlbnN1cmUgYSBzdGFibGUgc29ydCBpbiBWOCBhbmQgb3RoZXIgZW5naW5lc1xuICAgIC8vIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTkwXG4gICAgaWYgKGEgIT09IGIpIHtcbiAgICAgIGlmIChhID4gYiB8fCBhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICBpZiAoYSA8IGIgfHwgYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFpIDwgYmkgPyAtMSA6IDE7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2BcbiAgICogYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHByZXBlbmRzIGFueSBgcGFydGFpbEFyZ3NgIHRvIHRoZSBhcmd1bWVudHMgcGFzc2VkXG4gICAqIHRvIHRoZSBib3VuZCBmdW5jdGlvbi5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd9IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJpbmQgb3IgdGhlIG1ldGhvZCBuYW1lLlxuICAgKiBAcGFyYW0ge01peGVkfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbEFyZ3MgQW4gYXJyYXkgb2YgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUJvdW5kKGZ1bmMsIHRoaXNBcmcsIHBhcnRpYWxBcmdzKSB7XG4gICAgdmFyIGlzRnVuYyA9IGlzRnVuY3Rpb24oZnVuYyksXG4gICAgICAgIGlzUGFydGlhbCA9ICFwYXJ0aWFsQXJncyxcbiAgICAgICAgbWV0aG9kTmFtZSA9IGZ1bmM7XG5cbiAgICAvLyBqdWdnbGUgYXJndW1lbnRzXG4gICAgaWYgKGlzUGFydGlhbCkge1xuICAgICAgcGFydGlhbEFyZ3MgPSB0aGlzQXJnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJvdW5kKCkge1xuICAgICAgLy8gYEZ1bmN0aW9uI2JpbmRgIHNwZWNcbiAgICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjMuNC41XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICB0aGlzQmluZGluZyA9IGlzUGFydGlhbCA/IHRoaXMgOiB0aGlzQXJnO1xuXG4gICAgICBpZiAoIWlzRnVuYykge1xuICAgICAgICBmdW5jID0gdGhpc0FyZ1ttZXRob2ROYW1lXTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJ0aWFsQXJncy5sZW5ndGgpIHtcbiAgICAgICAgYXJncyA9IGFyZ3MubGVuZ3RoXG4gICAgICAgICAgPyBwYXJ0aWFsQXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmdzKSlcbiAgICAgICAgICA6IHBhcnRpYWxBcmdzO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICAvLyBnZXQgYGZ1bmNgIGluc3RhbmNlIGlmIGBib3VuZGAgaXMgaW52b2tlZCBpbiBhIGBuZXdgIGV4cHJlc3Npb25cbiAgICAgICAgbm9vcC5wcm90b3R5cGUgPSBmdW5jLnByb3RvdHlwZTtcbiAgICAgICAgdGhpc0JpbmRpbmcgPSBuZXcgbm9vcDtcblxuICAgICAgICAvLyBtaW1pYyB0aGUgY29uc3RydWN0b3IncyBgcmV0dXJuYCBiZWhhdmlvclxuICAgICAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxMy4yLjJcbiAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gaXNPYmplY3QocmVzdWx0KVxuICAgICAgICAgID8gcmVzdWx0XG4gICAgICAgICAgOiB0aGlzQmluZGluZ1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gYm91bmQ7XG4gIH1cblxuICAvKipcbiAgICogUHJvZHVjZXMgYW4gaXRlcmF0aW9uIGNhbGxiYWNrIGJvdW5kIHRvIGFuIG9wdGlvbmFsIGB0aGlzQXJnYC4gSWYgYGZ1bmNgIGlzXG4gICAqIGEgcHJvcGVydHkgbmFtZSwgdGhlIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBmb3IgYSBnaXZlbiBlbGVtZW50LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ30gW2Z1bmM9aWRlbnRpdHl8cHJvcGVydHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyXG4gICAqIGl0ZXJhdGlvbiBvciBwcm9wZXJ0eSBuYW1lIHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge01peGVkfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBhIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlQ2FsbGJhY2soZnVuYywgdGhpc0FyZykge1xuICAgIGlmICghZnVuYykge1xuICAgICAgcmV0dXJuIGlkZW50aXR5O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0W2Z1bmNdO1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXNBcmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgdmFsdWUsIGluZGV4LCBvYmplY3QpO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBjb21waWxlZCBpdGVyYXRpb24gZnVuY3Rpb25zLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMxLCBvcHRpb25zMiwgLi4uXSBUaGUgY29tcGlsZSBvcHRpb25zIG9iamVjdChzKS5cbiAgICogIHVzZUhhcyAtIEEgYm9vbGVhbiB0byBzcGVjaWZ5IHVzaW5nIGBoYXNPd25Qcm9wZXJ0eWAgY2hlY2tzIGluIHRoZSBvYmplY3QgbG9vcC5cbiAgICogIGFyZ3MgLSBBIHN0cmluZyBvZiBjb21tYSBzZXBhcmF0ZWQgYXJndW1lbnRzIHRoZSBpdGVyYXRpb24gZnVuY3Rpb24gd2lsbCBhY2NlcHQuXG4gICAqICB0b3AgLSBBIHN0cmluZyBvZiBjb2RlIHRvIGV4ZWN1dGUgYmVmb3JlIHRoZSBpdGVyYXRpb24gYnJhbmNoZXMuXG4gICAqICBhcnJheUxvb3AgLSBBIHN0cmluZyBvZiBjb2RlIHRvIGV4ZWN1dGUgaW4gdGhlIGFycmF5IGxvb3AuXG4gICAqICBvYmplY3RMb29wIC0gQSBzdHJpbmcgb2YgY29kZSB0byBleGVjdXRlIGluIHRoZSBvYmplY3QgbG9vcC5cbiAgICogIGJvdHRvbSAtIEEgc3RyaW5nIG9mIGNvZGUgdG8gZXhlY3V0ZSBhZnRlciB0aGUgaXRlcmF0aW9uIGJyYW5jaGVzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlSXRlcmF0b3IoKSB7XG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICAnYXJyYXlMb29wJzogJycsXG4gICAgICAnYm90dG9tJzogJycsXG4gICAgICAnaGFzRG9udEVudW1CdWcnOiBoYXNEb250RW51bUJ1ZyxcbiAgICAgICdpc0tleXNGYXN0JzogaXNLZXlzRmFzdCxcbiAgICAgICdvYmplY3RMb29wJzogJycsXG4gICAgICAnbm9BcmdzRW51bSc6IG5vQXJnc0VudW0sXG4gICAgICAnbm9DaGFyQnlJbmRleCc6IG5vQ2hhckJ5SW5kZXgsXG4gICAgICAnc2hhZG93ZWQnOiBzaGFkb3dlZCxcbiAgICAgICd0b3AnOiAnJyxcbiAgICAgICd1c2VIYXMnOiB0cnVlXG4gICAgfTtcblxuICAgIC8vIG1lcmdlIG9wdGlvbnMgaW50byBhIHRlbXBsYXRlIGRhdGEgb2JqZWN0XG4gICAgZm9yICh2YXIgb2JqZWN0LCBpbmRleCA9IDA7IG9iamVjdCA9IGFyZ3VtZW50c1tpbmRleF07IGluZGV4KyspIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgZGF0YVtrZXldID0gb2JqZWN0W2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBhcmdzID0gZGF0YS5hcmdzO1xuICAgIGRhdGEuZmlyc3RBcmcgPSAvXlteLF0rLy5leGVjKGFyZ3MpWzBdO1xuXG4gICAgLy8gY3JlYXRlIHRoZSBmdW5jdGlvbiBmYWN0b3J5XG4gICAgdmFyIGZhY3RvcnkgPSBGdW5jdGlvbihcbiAgICAgICAgJ2NyZWF0ZUNhbGxiYWNrLCBoYXNPd25Qcm9wZXJ0eSwgaXNBcmd1bWVudHMsIGlzU3RyaW5nLCBvYmplY3RUeXBlcywgJyArXG4gICAgICAgICduYXRpdmVLZXlzLCBwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG4gICAgICAncmV0dXJuIGZ1bmN0aW9uKCcgKyBhcmdzICsgJykge1xcbicgKyBpdGVyYXRvclRlbXBsYXRlKGRhdGEpICsgJ1xcbn0nXG4gICAgKTtcbiAgICAvLyByZXR1cm4gdGhlIGNvbXBpbGVkIGZ1bmN0aW9uXG4gICAgcmV0dXJuIGZhY3RvcnkoXG4gICAgICBjcmVhdGVDYWxsYmFjaywgaGFzT3duUHJvcGVydHksIGlzQXJndW1lbnRzLCBpc1N0cmluZywgb2JqZWN0VHlwZXMsXG4gICAgICBuYXRpdmVLZXlzLCBwcm9wZXJ0eUlzRW51bWVyYWJsZVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgdGVtcGxhdGVgIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWRcbiAgICogc3RyaW5nIGxpdGVyYWxzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWF0Y2ggVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAgICogQHJldHVybnMge1N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAqL1xuICBmdW5jdGlvbiBlc2NhcGVTdHJpbmdDaGFyKG1hdGNoKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIHN0cmluZ0VzY2FwZXNbbWF0Y2hdO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYGVzY2FwZWAgdG8gY29udmVydCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtYXRjaCBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIGVzY2FwZUh0bWxDaGFyKG1hdGNoKSB7XG4gICAgcmV0dXJuIGh0bWxFc2NhcGVzW21hdGNoXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIG5vLW9wZXJhdGlvbiBmdW5jdGlvbi5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIG5vb3AoKSB7XG4gICAgLy8gbm8gb3BlcmF0aW9uIHBlcmZvcm1lZFxuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYHVuZXNjYXBlYCB0byBjb252ZXJ0IEhUTUwgZW50aXRpZXMgdG8gY2hhcmFjdGVycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1hdGNoIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byB1bmVzY2FwZS5cbiAgICogQHJldHVybnMge1N0cmluZ30gUmV0dXJucyB0aGUgdW5lc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIHVuZXNjYXBlSHRtbENoYXIobWF0Y2gpIHtcbiAgICByZXR1cm4gaHRtbFVuZXNjYXBlc1ttYXRjaF07XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAoZnVuY3Rpb24oKSB7IHJldHVybiBfLmlzQXJndW1lbnRzKGFyZ3VtZW50cyk7IH0pKDEsIDIsIDMpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICovXG4gIGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IGFyZ3NDbGFzcztcbiAgfVxuICAvLyBmYWxsYmFjayBmb3IgYnJvd3NlcnMgdGhhdCBjYW4ndCBkZXRlY3QgYGFyZ3VtZW50c2Agb2JqZWN0cyBieSBbW0NsYXNzXV1cbiAgaWYgKG5vQXJnc0NsYXNzKSB7XG4gICAgaXNBcmd1bWVudHMgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID8gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpIDogZmFsc2U7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlcyBvdmVyIGBvYmplY3RgJ3Mgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLCBleGVjdXRpbmdcbiAgICogdGhlIGBjYWxsYmFja2AgZm9yIGVhY2ggcHJvcGVydHkuIFRoZSBgY2FsbGJhY2tgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmRcbiAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBrZXksIG9iamVjdCkuIENhbGxiYWNrcyBtYXkgZXhpdCBpdGVyYXRpb25cbiAgICogZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7TWl4ZWR9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogZnVuY3Rpb24gRG9nKG5hbWUpIHtcbiAgICogICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgKiB9XG4gICAqXG4gICAqIERvZy5wcm90b3R5cGUuYmFyayA9IGZ1bmN0aW9uKCkge1xuICAgKiAgIGFsZXJ0KCdXb29mLCB3b29mIScpO1xuICAgKiB9O1xuICAgKlxuICAgKiBfLmZvckluKG5ldyBEb2coJ0RhZ255JyksIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICogICBhbGVydChrZXkpO1xuICAgKiB9KTtcbiAgICogLy8gPT4gYWxlcnRzICduYW1lJyBhbmQgJ2JhcmsnIChvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICovXG4gIHZhciBmb3JJbiA9IGNyZWF0ZUl0ZXJhdG9yKGZvckVhY2hJdGVyYXRvck9wdGlvbnMsIGZvck93bkl0ZXJhdG9yT3B0aW9ucywge1xuICAgICd1c2VIYXMnOiBmYWxzZVxuICB9KTtcblxuICAvKipcbiAgICogSXRlcmF0ZXMgb3ZlciBgb2JqZWN0YCdzIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMsIGV4ZWN1dGluZyB0aGUgYGNhbGxiYWNrYFxuICAgKiBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGBjYWxsYmFja2AgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICogYXJndW1lbnRzOyAodmFsdWUsIGtleSwgb2JqZWN0KS4gQ2FsbGJhY2tzIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5XG4gICAqIHJldHVybmluZyBgZmFsc2VgLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHtNaXhlZH0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmZvck93bih7ICcwJzogJ3plcm8nLCAnMSc6ICdvbmUnLCAnbGVuZ3RoJzogMiB9LCBmdW5jdGlvbihudW0sIGtleSkge1xuICAgKiAgIGFsZXJ0KGtleSk7XG4gICAqIH0pO1xuICAgKiAvLyA9PiBhbGVydHMgJzAnLCAnMScsIGFuZCAnbGVuZ3RoJyAob3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAqL1xuICB2YXIgZm9yT3duID0gY3JlYXRlSXRlcmF0b3IoZm9yRWFjaEl0ZXJhdG9yT3B0aW9ucywgZm9yT3duSXRlcmF0b3JPcHRpb25zKTtcblxuICAvKipcbiAgICogQSBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbiBvZiBgaXNQbGFpbk9iamVjdGAgdGhhdCBjaGVja3MgaWYgYSBnaXZlbiBgdmFsdWVgXG4gICAqIGlzIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3RvciwgYXNzdW1pbmcgb2JqZWN0cyBjcmVhdGVkXG4gICAqIGJ5IHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3RvciBoYXZlIG5vIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMgYW5kIHRoYXRcbiAgICogdGhlcmUgYXJlIG5vIGBPYmplY3QucHJvdG90eXBlYCBleHRlbnNpb25zLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBzaGltSXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgIC8vIGF2b2lkIG5vbi1vYmplY3RzIGFuZCBmYWxzZSBwb3NpdGl2ZXMgZm9yIGBhcmd1bWVudHNgIG9iamVjdHNcbiAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgaWYgKCEodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIElFIDwgOSBwcmVzZW50cyBET00gbm9kZXMgYXMgYE9iamVjdGAgb2JqZWN0cyBleGNlcHQgdGhleSBoYXZlIGB0b1N0cmluZ2BcbiAgICAvLyBtZXRob2RzIHRoYXQgYXJlIGB0eXBlb2ZgIFwic3RyaW5nXCIgYW5kIHN0aWxsIGNhbiBjb2VyY2Ugbm9kZXMgdG8gc3RyaW5ncy5cbiAgICAvLyBBbHNvIGNoZWNrIHRoYXQgdGhlIGNvbnN0cnVjdG9yIGlzIGBPYmplY3RgIChpLmUuIGBPYmplY3QgaW5zdGFuY2VvZiBPYmplY3RgKVxuICAgIHZhciBjdG9yID0gdmFsdWUuY29uc3RydWN0b3I7XG4gICAgaWYgKCghbm9Ob2RlQ2xhc3MgfHwgISh0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgKHZhbHVlICsgJycpID09ICdzdHJpbmcnKSkgJiZcbiAgICAgICAgKCFpc0Z1bmN0aW9uKGN0b3IpIHx8IGN0b3IgaW5zdGFuY2VvZiBjdG9yKSkge1xuICAgICAgLy8gSUUgPCA5IGl0ZXJhdGVzIGluaGVyaXRlZCBwcm9wZXJ0aWVzIGJlZm9yZSBvd24gcHJvcGVydGllcy4gSWYgdGhlIGZpcnN0XG4gICAgICAvLyBpdGVyYXRlZCBwcm9wZXJ0eSBpcyBhbiBvYmplY3QncyBvd24gcHJvcGVydHkgdGhlbiB0aGVyZSBhcmUgbm8gaW5oZXJpdGVkXG4gICAgICAvLyBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gICAgICBpZiAoaXRlcmF0ZXNPd25MYXN0KSB7XG4gICAgICAgIGZvckluKHZhbHVlLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgICByZXN1bHQgPSAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBJbiBtb3N0IGVudmlyb25tZW50cyBhbiBvYmplY3QncyBvd24gcHJvcGVydGllcyBhcmUgaXRlcmF0ZWQgYmVmb3JlXG4gICAgICAvLyBpdHMgaW5oZXJpdGVkIHByb3BlcnRpZXMuIElmIHRoZSBsYXN0IGl0ZXJhdGVkIHByb3BlcnR5IGlzIGFuIG9iamVjdCdzXG4gICAgICAvLyBvd24gcHJvcGVydHkgdGhlbiB0aGVyZSBhcmUgbm8gaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICAgIGZvckluKHZhbHVlLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIHJlc3VsdCA9IGtleTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gZmFsc2UgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgcmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGZhbGxiYWNrIGltcGxlbWVudGF0aW9uIG9mIGBPYmplY3Qua2V5c2AgdGhhdCBwcm9kdWNlcyBhbiBhcnJheSBvZiB0aGVcbiAgICogZ2l2ZW4gb2JqZWN0J3Mgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAqL1xuICBmdW5jdGlvbiBzaGltS2V5cyhvYmplY3QpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gY29udmVydCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXM6XG4gICAqXG4gICAqIFRob3VnaCB0aGUgYD5gIGNoYXJhY3RlciBpcyBlc2NhcGVkIGZvciBzeW1tZXRyeSwgY2hhcmFjdGVycyBsaWtlIGA+YCBhbmQgYC9gXG4gICAqIGRvbid0IHJlcXVpcmUgZXNjYXBpbmcgaW4gSFRNTCBhbmQgaGF2ZSBubyBzcGVjaWFsIG1lYW5pbmcgdW5sZXNzIHRoZXkncmUgcGFydFxuICAgKiBvZiBhIHRhZyBvciBhbiB1bnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUuXG4gICAqIGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2FtYmlndW91cy1hbXBlcnNhbmRzICh1bmRlciBcInNlbWktcmVsYXRlZCBmdW4gZmFjdFwiKVxuICAgKi9cbiAgdmFyIGh0bWxFc2NhcGVzID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjeDI3OydcbiAgfTtcblxuICAvKiogVXNlZCB0byBjb252ZXJ0IEhUTUwgZW50aXRpZXMgdG8gY2hhcmFjdGVycyAqL1xuICB2YXIgaHRtbFVuZXNjYXBlcyA9IGludmVydChodG1sRXNjYXBlcyk7XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdmFsdWVgLiBJZiBgZGVlcGAgaXMgYHRydWVgLCBhbGwgbmVzdGVkIG9iamVjdHMgd2lsbFxuICAgKiBhbHNvIGJlIGNsb25lZCBvdGhlcndpc2UgdGhleSB3aWxsIGJlIGFzc2lnbmVkIGJ5IHJlZmVyZW5jZS4gRnVuY3Rpb25zLCBET01cbiAgICogbm9kZXMsIGBhcmd1bWVudHNgIG9iamVjdHMsIGFuZCBvYmplY3RzIGNyZWF0ZWQgYnkgY29uc3RydWN0b3JzIG90aGVyIHRoYW5cbiAgICogYE9iamVjdGAgYXJlICoqbm90KiogY2xvbmVkLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAgICogQHBhcmFtIHtCb29sZWFufSBkZWVwIEEgZmxhZyB0byBpbmRpY2F0ZSBhIGRlZXAgY2xvbmUuXG4gICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBJbnRlcm5hbGx5IHVzZWQgdG8gYWxsb3cgdGhpcyBtZXRob2QgdG8gd29yayB3aXRoXG4gICAqICBvdGhlcnMgbGlrZSBgXy5tYXBgIHdpdGhvdXQgdXNpbmcgdGhlaXIgY2FsbGJhY2sgYGluZGV4YCBhcmd1bWVudCBmb3IgYGRlZXBgLlxuICAgKiBAcGFyYW0tIHtBcnJheX0gW3N0YWNrQT1bXV0gSW50ZXJuYWxseSB1c2VkIHRvIHRyYWNrIHRyYXZlcnNlZCBzb3VyY2Ugb2JqZWN0cy5cbiAgICogQHBhcmFtLSB7QXJyYXl9IFtzdGFja0I9W11dIEludGVybmFsbHkgdXNlZCB0byBhc3NvY2lhdGUgY2xvbmVzIHdpdGggdGhlaXJcbiAgICogIHNvdXJjZSBjb3VudGVycGFydHMuXG4gICAqIEByZXR1cm5zIHtNaXhlZH0gUmV0dXJucyB0aGUgY2xvbmVkIGB2YWx1ZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBzdG9vZ2VzID0gW1xuICAgKiAgIHsgJ25hbWUnOiAnbW9lJywgJ2FnZSc6IDQwIH0sXG4gICAqICAgeyAnbmFtZSc6ICdsYXJyeScsICdhZ2UnOiA1MCB9LFxuICAgKiAgIHsgJ25hbWUnOiAnY3VybHknLCAnYWdlJzogNjAgfVxuICAgKiBdO1xuICAgKlxuICAgKiBfLmNsb25lKHsgJ25hbWUnOiAnbW9lJyB9KTtcbiAgICogLy8gPT4geyAnbmFtZSc6ICdtb2UnIH1cbiAgICpcbiAgICogdmFyIHNoYWxsb3cgPSBfLmNsb25lKHN0b29nZXMpO1xuICAgKiBzaGFsbG93WzBdID09PSBzdG9vZ2VzWzBdO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIHZhciBkZWVwID0gXy5jbG9uZShzdG9vZ2VzLCB0cnVlKTtcbiAgICogc2hhbGxvd1swXSA9PT0gc3Rvb2dlc1swXTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICovXG4gIGZ1bmN0aW9uIGNsb25lKHZhbHVlLCBkZWVwLCBndWFyZCwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoZ3VhcmQpIHtcbiAgICAgIGRlZXAgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gaW5zcGVjdCBbW0NsYXNzXV1cbiAgICB2YXIgaXNPYmogPSBpc09iamVjdCh2YWx1ZSk7XG4gICAgaWYgKGlzT2JqKSB7XG4gICAgICAvLyBkb24ndCBjbG9uZSBgYXJndW1lbnRzYCBvYmplY3RzLCBmdW5jdGlvbnMsIG9yIG5vbi1vYmplY3QgT2JqZWN0c1xuICAgICAgdmFyIGNsYXNzTmFtZSA9IHRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgaWYgKCFjbG9uZWFibGVDbGFzc2VzW2NsYXNzTmFtZV0gfHwgKG5vQXJnc0NsYXNzICYmIGlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIGlzQXJyID0gY2xhc3NOYW1lID09IGFycmF5Q2xhc3M7XG4gICAgICBpc09iaiA9IGlzQXJyIHx8IChjbGFzc05hbWUgPT0gb2JqZWN0Q2xhc3MgPyBpc1BsYWluT2JqZWN0KHZhbHVlKSA6IGlzT2JqKTtcbiAgICB9XG4gICAgLy8gc2hhbGxvdyBjbG9uZVxuICAgIGlmICghaXNPYmogfHwgIWRlZXApIHtcbiAgICAgIC8vIGRvbid0IGNsb25lIGZ1bmN0aW9uc1xuICAgICAgcmV0dXJuIGlzT2JqXG4gICAgICAgID8gKGlzQXJyID8gc2xpY2UuY2FsbCh2YWx1ZSkgOiBleHRlbmQoe30sIHZhbHVlKSlcbiAgICAgICAgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgY3RvciA9IHZhbHVlLmNvbnN0cnVjdG9yO1xuICAgIHN3aXRjaCAoY2xhc3NOYW1lKSB7XG4gICAgICBjYXNlIGJvb2xDbGFzczpcbiAgICAgIGNhc2UgZGF0ZUNsYXNzOlxuICAgICAgICByZXR1cm4gbmV3IGN0b3IoK3ZhbHVlKTtcblxuICAgICAgY2FzZSBudW1iZXJDbGFzczpcbiAgICAgIGNhc2Ugc3RyaW5nQ2xhc3M6XG4gICAgICAgIHJldHVybiBuZXcgY3Rvcih2YWx1ZSk7XG5cbiAgICAgIGNhc2UgcmVnZXhwQ2xhc3M6XG4gICAgICAgIHJldHVybiBjdG9yKHZhbHVlLnNvdXJjZSwgcmVGbGFncy5leGVjKHZhbHVlKSk7XG4gICAgfVxuICAgIC8vIGNoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gY29ycmVzcG9uZGluZyBjbG9uZVxuICAgIHN0YWNrQSB8fCAoc3RhY2tBID0gW10pO1xuICAgIHN0YWNrQiB8fCAoc3RhY2tCID0gW10pO1xuXG4gICAgdmFyIGxlbmd0aCA9IHN0YWNrQS5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBpZiAoc3RhY2tBW2xlbmd0aF0gPT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrQltsZW5ndGhdO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBpbml0IGNsb25lZCBvYmplY3RcbiAgICB2YXIgcmVzdWx0ID0gaXNBcnIgPyBjdG9yKHZhbHVlLmxlbmd0aCkgOiB7fTtcblxuICAgIC8vIGFkZCB0aGUgc291cmNlIHZhbHVlIHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0c1xuICAgIC8vIGFuZCBhc3NvY2lhdGUgaXQgd2l0aCBpdHMgY2xvbmVcbiAgICBzdGFja0EucHVzaCh2YWx1ZSk7XG4gICAgc3RhY2tCLnB1c2gocmVzdWx0KTtcblxuICAgIC8vIHJlY3Vyc2l2ZWx5IHBvcHVsYXRlIGNsb25lIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cylcbiAgICAoaXNBcnIgPyBmb3JFYWNoIDogZm9yT3duKSh2YWx1ZSwgZnVuY3Rpb24ob2JqVmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBjbG9uZShvYmpWYWx1ZSwgZGVlcCwgbnVsbCwgc3RhY2tBLCBzdGFja0IpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NpZ25zIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiB0aGUgZGVmYXVsdCBvYmplY3QocykgdG8gdGhlIGBkZXN0aW5hdGlvbmBcbiAgICogb2JqZWN0IGZvciBhbGwgYGRlc3RpbmF0aW9uYCBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byBgbnVsbGAvYHVuZGVmaW5lZGAuXG4gICAqIE9uY2UgYSBwcm9wZXJ0eSBpcyBzZXQsIGFkZGl0aW9uYWwgZGVmYXVsdHMgb2YgdGhlIHNhbWUgcHJvcGVydHkgd2lsbCBiZVxuICAgKiBpZ25vcmVkLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtkZWZhdWx0MSwgZGVmYXVsdDIsIC4uLl0gVGhlIGRlZmF1bHQgb2JqZWN0cy5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgaWNlQ3JlYW0gPSB7ICdmbGF2b3InOiAnY2hvY29sYXRlJyB9O1xuICAgKiBfLmRlZmF1bHRzKGljZUNyZWFtLCB7ICdmbGF2b3InOiAndmFuaWxsYScsICdzcHJpbmtsZXMnOiAncmFpbmJvdycgfSk7XG4gICAqIC8vID0+IHsgJ2ZsYXZvcic6ICdjaG9jb2xhdGUnLCAnc3ByaW5rbGVzJzogJ3JhaW5ib3cnIH1cbiAgICovXG4gIHZhciBkZWZhdWx0cyA9IGNyZWF0ZUl0ZXJhdG9yKGV4dGVuZEl0ZXJhdG9yT3B0aW9ucywge1xuICAgICdvYmplY3RMb29wJzogJ2lmIChyZXN1bHRbaW5kZXhdID09IG51bGwpICcgKyBleHRlbmRJdGVyYXRvck9wdGlvbnMub2JqZWN0TG9vcFxuICB9KTtcblxuICAvKipcbiAgICogQXNzaWducyBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgdGhlIHNvdXJjZSBvYmplY3QocykgdG8gdGhlIGBkZXN0aW5hdGlvbmBcbiAgICogb2JqZWN0LiBTdWJzZXF1ZW50IHNvdXJjZXMgd2lsbCBvdmVyd3JpdGUgcHJvcGVyeSBhc3NpZ25tZW50cyBvZiBwcmV2aW91c1xuICAgKiBzb3VyY2VzLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtzb3VyY2UxLCBzb3VyY2UyLCAuLi5dIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmV4dGVuZCh7ICduYW1lJzogJ21vZScgfSwgeyAnYWdlJzogNDAgfSk7XG4gICAqIC8vID0+IHsgJ25hbWUnOiAnbW9lJywgJ2FnZSc6IDQwIH1cbiAgICovXG4gIHZhciBleHRlbmQgPSBjcmVhdGVJdGVyYXRvcihleHRlbmRJdGVyYXRvck9wdGlvbnMpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc29ydGVkIGFycmF5IG9mIGFsbCBlbnVtZXJhYmxlIHByb3BlcnRpZXMsIG93biBhbmQgaW5oZXJpdGVkLFxuICAgKiBvZiBgb2JqZWN0YCB0aGF0IGhhdmUgZnVuY3Rpb24gdmFsdWVzLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBhbGlhcyBtZXRob2RzXG4gICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgdGhhdCBoYXZlIGZ1bmN0aW9uIHZhbHVlcy5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5mdW5jdGlvbnMoXyk7XG4gICAqIC8vID0+IFsnYWxsJywgJ2FueScsICdiaW5kJywgJ2JpbmRBbGwnLCAnY2xvbmUnLCAnY29tcGFjdCcsICdjb21wb3NlJywgLi4uXVxuICAgKi9cbiAgZnVuY3Rpb24gZnVuY3Rpb25zKG9iamVjdCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3JJbihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQuc29ydCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgc3BlY2lmaWVkIG9iamVjdCBgcHJvcGVydHlgIGV4aXN0cyBhbmQgaXMgYSBkaXJlY3QgcHJvcGVydHksXG4gICAqIGluc3RlYWQgb2YgYW4gaW5oZXJpdGVkIHByb3BlcnR5LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IFRoZSBwcm9wZXJ0eSB0byBjaGVjayBmb3IuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBrZXkgaXMgYSBkaXJlY3QgcHJvcGVydHksIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5oYXMoeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sICdiJyk7XG4gICAqIC8vID0+IHRydWVcbiAgICovXG4gIGZ1bmN0aW9uIGhhcyhvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIG9iamVjdCA/IGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgOiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgaW52ZXJ0ZWQga2V5cyBhbmQgdmFsdWVzIG9mIHRoZSBnaXZlbiBgb2JqZWN0YC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW52ZXJ0LlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjcmVhdGVkIGludmVydGVkIG9iamVjdC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogIF8uaW52ZXJ0KHsgJ2ZpcnN0JzogJ01vZScsICdzZWNvbmQnOiAnTGFycnknLCAndGhpcmQnOiAnQ3VybHknIH0pO1xuICAgKiAvLyA9PiB7ICdNb2UnOiAnZmlyc3QnLCAnTGFycnknOiAnc2Vjb25kJywgJ0N1cmx5JzogJ3RoaXJkJyB9IChvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICovXG4gIGZ1bmN0aW9uIGludmVydChvYmplY3QpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0W3ZhbHVlXSA9IGtleTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIChmdW5jdGlvbigpIHsgcmV0dXJuIF8uaXNBcnJheShhcmd1bWVudHMpOyB9KSgpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKi9cbiAgdmFyIGlzQXJyYXkgPSBuYXRpdmVJc0FycmF5IHx8IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IGFycmF5Q2xhc3M7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYm9vbGVhbiAoYHRydWVgIG9yIGBmYWxzZWApIHZhbHVlLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgYm9vbGVhbiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmlzQm9vbGVhbihudWxsKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICovXG4gIGZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYm9vbENsYXNzO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZGF0ZS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIGRhdGUsIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc0RhdGUobmV3IERhdGUpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqL1xuICBmdW5jdGlvbiBpc0RhdGUodmFsdWUpIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gZGF0ZUNsYXNzO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgRE9NIGVsZW1lbnQuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSBET00gZWxlbWVudCwgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmlzRWxlbWVudChkb2N1bWVudC5ib2R5KTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNFbGVtZW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID8gdmFsdWUubm9kZVR5cGUgPT09IDEgOiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBlbXB0eS4gQXJyYXlzLCBzdHJpbmdzLCBvciBgYXJndW1lbnRzYCBvYmplY3RzIHdpdGggYVxuICAgKiBsZW5ndGggb2YgYDBgIGFuZCBvYmplY3RzIHdpdGggbm8gb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBhcmUgY29uc2lkZXJlZFxuICAgKiBcImVtcHR5XCIuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8U3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGVtcHR5LCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaXNFbXB0eShbMSwgMiwgM10pO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBfLmlzRW1wdHkoe30pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNFbXB0eSgnJyk7XG4gICAqIC8vID0+IHRydWVcbiAgICovXG4gIGZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbCh2YWx1ZSksXG4gICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblxuICAgIGlmICgoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MgfHwgY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzIHx8XG4gICAgICAgIGNsYXNzTmFtZSA9PSBhcmdzQ2xhc3MgfHwgKG5vQXJnc0NsYXNzICYmIGlzQXJndW1lbnRzKHZhbHVlKSkpIHx8XG4gICAgICAgIChjbGFzc05hbWUgPT0gb2JqZWN0Q2xhc3MgJiYgdHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyAmJiBpc0Z1bmN0aW9uKHZhbHVlLnNwbGljZSkpKSB7XG4gICAgICByZXR1cm4gIWxlbmd0aDtcbiAgICB9XG4gICAgZm9yT3duKHZhbHVlLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAocmVzdWx0ID0gZmFsc2UpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZVxuICAgKiBlcXVpdmFsZW50IHRvIGVhY2ggb3RoZXIuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICogQHBhcmFtIHtNaXhlZH0gYSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICogQHBhcmFtIHtNaXhlZH0gYiBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICogQHBhcmFtLSB7T2JqZWN0fSBbc3RhY2tBPVtdXSBJbnRlcm5hbGx5IHVzZWQgdHJhY2sgdHJhdmVyc2VkIGBhYCBvYmplY3RzLlxuICAgKiBAcGFyYW0tIHtPYmplY3R9IFtzdGFja0I9W11dIEludGVybmFsbHkgdXNlZCB0cmFjayB0cmF2ZXJzZWQgYGJgIG9iamVjdHMuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXV2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIG1vZSA9IHsgJ25hbWUnOiAnbW9lJywgJ2x1Y2t5TnVtYmVycyc6IFsxMywgMjcsIDM0XSB9O1xuICAgKiB2YXIgY2xvbmUgPSB7ICduYW1lJzogJ21vZScsICdsdWNreU51bWJlcnMnOiBbMTMsIDI3LCAzNF0gfTtcbiAgICpcbiAgICogbW9lID09IGNsb25lO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBfLmlzRXF1YWwobW9lLCBjbG9uZSk7XG4gICAqIC8vID0+IHRydWVcbiAgICovXG4gIGZ1bmN0aW9uIGlzRXF1YWwoYSwgYiwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAvLyBleGl0IGVhcmx5IGZvciBpZGVudGljYWwgdmFsdWVzXG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgIC8vIHRyZWF0IGArMGAgdnMuIGAtMGAgYXMgbm90IGVxdWFsXG4gICAgICByZXR1cm4gYSAhPT0gMCB8fCAoMSAvIGEgPT0gMSAvIGIpO1xuICAgIH1cbiAgICAvLyBhIHN0cmljdCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGBudWxsID09IHVuZGVmaW5lZGBcbiAgICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgfVxuICAgIC8vIGNvbXBhcmUgW1tDbGFzc11dIG5hbWVzXG4gICAgdmFyIGNsYXNzTmFtZSA9IHRvU3RyaW5nLmNhbGwoYSk7XG4gICAgaWYgKGNsYXNzTmFtZSAhPSB0b1N0cmluZy5jYWxsKGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN3aXRjaCAoY2xhc3NOYW1lKSB7XG4gICAgICBjYXNlIGJvb2xDbGFzczpcbiAgICAgIGNhc2UgZGF0ZUNsYXNzOlxuICAgICAgICAvLyBjb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWJlcnMsIGRhdGVzIHRvIG1pbGxpc2Vjb25kcyBhbmQgYm9vbGVhbnNcbiAgICAgICAgLy8gdG8gYDFgIG9yIGAwYCwgdHJlYXRpbmcgaW52YWxpZCBkYXRlcyBjb2VyY2VkIHRvIGBOYU5gIGFzIG5vdCBlcXVhbFxuICAgICAgICByZXR1cm4gK2EgPT0gK2I7XG5cbiAgICAgIGNhc2UgbnVtYmVyQ2xhc3M6XG4gICAgICAgIC8vIHRyZWF0IGBOYU5gIHZzLiBgTmFOYCBhcyBlcXVhbFxuICAgICAgICByZXR1cm4gYSAhPSArYVxuICAgICAgICAgID8gYiAhPSArYlxuICAgICAgICAgIC8vIGJ1dCB0cmVhdCBgKzBgIHZzLiBgLTBgIGFzIG5vdCBlcXVhbFxuICAgICAgICAgIDogKGEgPT0gMCA/ICgxIC8gYSA9PSAxIC8gYikgOiBhID09ICtiKTtcblxuICAgICAgY2FzZSByZWdleHBDbGFzczpcbiAgICAgIGNhc2Ugc3RyaW5nQ2xhc3M6XG4gICAgICAgIC8vIGNvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgKGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjEwLjYuNClcbiAgICAgICAgLy8gdHJlYXQgc3RyaW5nIHByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IGluc3RhbmNlcyBhcyBlcXVhbFxuICAgICAgICByZXR1cm4gYSA9PSBiICsgJyc7XG4gICAgfVxuICAgIC8vIGV4aXQgZWFybHksIGluIG9sZGVyIGJyb3dzZXJzLCBpZiBgYWAgaXMgYXJyYXktbGlrZSBidXQgbm90IGBiYFxuICAgIHZhciBpc0FyciA9IGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzIHx8IGNsYXNzTmFtZSA9PSBhcmdzQ2xhc3M7XG4gICAgaWYgKG5vQXJnc0NsYXNzICYmICFpc0FyciAmJiAoaXNBcnIgPSBpc0FyZ3VtZW50cyhhKSkgJiYgIWlzQXJndW1lbnRzKGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghaXNBcnIpIHtcbiAgICAgIC8vIHVud3JhcCBhbnkgYGxvZGFzaGAgd3JhcHBlZCB2YWx1ZXNcbiAgICAgIGlmIChhLl9fd3JhcHBlZF9fIHx8IGIuX193cmFwcGVkX18pIHtcbiAgICAgICAgcmV0dXJuIGlzRXF1YWwoYS5fX3dyYXBwZWRfXyB8fCBhLCBiLl9fd3JhcHBlZF9fIHx8IGIpO1xuICAgICAgfVxuICAgICAgLy8gZXhpdCBmb3IgZnVuY3Rpb25zIGFuZCBET00gbm9kZXNcbiAgICAgIGlmIChjbGFzc05hbWUgIT0gb2JqZWN0Q2xhc3MgfHwgKG5vTm9kZUNsYXNzICYmIChcbiAgICAgICAgICAodHlwZW9mIGEudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgKGEgKyAnJykgPT0gJ3N0cmluZycpIHx8XG4gICAgICAgICAgKHR5cGVvZiBiLnRvU3RyaW5nICE9ICdmdW5jdGlvbicgJiYgdHlwZW9mIChiICsgJycpID09ICdzdHJpbmcnKSkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBjdG9yQSA9IGEuY29uc3RydWN0b3IsXG4gICAgICAgICAgY3RvckIgPSBiLmNvbnN0cnVjdG9yO1xuXG4gICAgICAvLyBub24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbFxuICAgICAgaWYgKGN0b3JBICE9IGN0b3JCICYmICEoXG4gICAgICAgICAgICBpc0Z1bmN0aW9uKGN0b3JBKSAmJiBjdG9yQSBpbnN0YW5jZW9mIGN0b3JBICYmXG4gICAgICAgICAgICBpc0Z1bmN0aW9uKGN0b3JCKSAmJiBjdG9yQiBpbnN0YW5jZW9mIGN0b3JCXG4gICAgICAgICAgKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGFzc3VtZSBjeWNsaWMgc3RydWN0dXJlcyBhcmUgZXF1YWxcbiAgICAvLyB0aGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljIHN0cnVjdHVyZXMgaXMgYWRhcHRlZCBmcm9tIEVTIDUuMVxuICAgIC8vIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AgKGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjEyLjMpXG4gICAgc3RhY2tBIHx8IChzdGFja0EgPSBbXSk7XG4gICAgc3RhY2tCIHx8IChzdGFja0IgPSBbXSk7XG5cbiAgICB2YXIgbGVuZ3RoID0gc3RhY2tBLmxlbmd0aDtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGlmIChzdGFja0FbbGVuZ3RoXSA9PSBhKSB7XG4gICAgICAgIHJldHVybiBzdGFja0JbbGVuZ3RoXSA9PSBiO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICByZXN1bHQgPSB0cnVlLFxuICAgICAgICBzaXplID0gMDtcblxuICAgIC8vIGFkZCBgYWAgYW5kIGBiYCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHNcbiAgICBzdGFja0EucHVzaChhKTtcbiAgICBzdGFja0IucHVzaChiKTtcblxuICAgIC8vIHJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cylcbiAgICBpZiAoaXNBcnIpIHtcbiAgICAgIC8vIGNvbXBhcmUgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5XG4gICAgICBzaXplID0gYS5sZW5ndGg7XG4gICAgICByZXN1bHQgPSBzaXplID09IGIubGVuZ3RoO1xuXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIC8vIGRlZXAgY29tcGFyZSB0aGUgY29udGVudHMsIGlnbm9yaW5nIG5vbi1udW1lcmljIHByb3BlcnRpZXNcbiAgICAgICAgd2hpbGUgKHNpemUtLSkge1xuICAgICAgICAgIGlmICghKHJlc3VsdCA9IGlzRXF1YWwoYVtzaXplXSwgYltzaXplXSwgc3RhY2tBLCBzdGFja0IpKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBkZWVwIGNvbXBhcmUgb2JqZWN0c1xuICAgIGZvciAodmFyIGtleSBpbiBhKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChhLCBrZXkpKSB7XG4gICAgICAgIC8vIGNvdW50IHRoZSBudW1iZXIgb2YgcHJvcGVydGllcy5cbiAgICAgICAgc2l6ZSsrO1xuICAgICAgICAvLyBkZWVwIGNvbXBhcmUgZWFjaCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgICAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXkpICYmIGlzRXF1YWwoYVtrZXldLCBiW2tleV0sIHN0YWNrQSwgc3RhY2tCKSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZW5zdXJlIGJvdGggb2JqZWN0cyBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBwcm9wZXJ0aWVzXG4gICAgZm9yIChrZXkgaW4gYikge1xuICAgICAgLy8gVGhlIEpTIGVuZ2luZSBpbiBBZG9iZSBwcm9kdWN0cywgbGlrZSBJbkRlc2lnbiwgaGFzIGEgYnVnIHRoYXQgY2F1c2VzXG4gICAgICAvLyBgIXNpemUtLWAgdG8gdGhyb3cgYW4gZXJyb3Igc28gaXQgbXVzdCBiZSB3cmFwcGVkIGluIHBhcmVudGhlc2VzLlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2RvY3VtZW50Y2xvdWQvdW5kZXJzY29yZS9pc3N1ZXMvMzU1XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXkpICYmICEoc2l6ZS0tKSkge1xuICAgICAgICAvLyBgc2l6ZWAgd2lsbCBiZSBgLTFgIGlmIGBiYCBoYXMgbW9yZSBwcm9wZXJ0aWVzIHRoYW4gYGFgXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaGFuZGxlIEpTY3JpcHQgW1tEb250RW51bV1dIGJ1Z1xuICAgIGlmIChoYXNEb250RW51bUJ1Zykge1xuICAgICAgd2hpbGUgKCsraW5kZXggPCA3KSB7XG4gICAgICAgIGtleSA9IHNoYWRvd2VkW2luZGV4XTtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoYSwga2V5KSAmJlxuICAgICAgICAgICAgIShoYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGtleSkgJiYgaXNFcXVhbChhW2tleV0sIGJba2V5XSwgc3RhY2tBLCBzdGFja0IpKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcywgb3IgY2FuIGJlIGNvZXJjZWQgdG8sIGEgZmluaXRlIG51bWJlci5cbiAgICpcbiAgICogTm90ZTogVGhpcyBpcyBub3QgdGhlIHNhbWUgYXMgbmF0aXZlIGBpc0Zpbml0ZWAsIHdoaWNoIHdpbGwgcmV0dXJuIHRydWUgZm9yXG4gICAqIGJvb2xlYW5zIGFuZCBlbXB0eSBzdHJpbmdzLiBTZWUgaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMS4yLjUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSBmaW5pdGUgbnVtYmVyLCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaXNGaW5pdGUoLTEwMSk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc0Zpbml0ZSgnMTAnKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzRmluaXRlKHRydWUpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBfLmlzRmluaXRlKCcnKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICpcbiAgICogXy5pc0Zpbml0ZShJbmZpbml0eSk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqL1xuICBmdW5jdGlvbiBpc0Zpbml0ZSh2YWx1ZSkge1xuICAgIHJldHVybiBuYXRpdmVJc0Zpbml0ZSh2YWx1ZSkgJiYgIW5hdGl2ZUlzTmFOKHBhcnNlRmxvYXQodmFsdWUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc0Z1bmN0aW9uKF8pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqL1xuICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nO1xuICB9XG4gIC8vIGZhbGxiYWNrIGZvciBvbGRlciB2ZXJzaW9ucyBvZiBDaHJvbWUgYW5kIFNhZmFyaVxuICBpZiAoaXNGdW5jdGlvbigveC8pKSB7XG4gICAgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gZnVuY0NsYXNzO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIGxhbmd1YWdlIHR5cGUgb2YgT2JqZWN0LlxuICAgKiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc09iamVjdCh7fSk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNPYmplY3QoMSk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqL1xuICBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIC8vIGNoZWNrIGlmIHRoZSB2YWx1ZSBpcyB0aGUgRUNNQVNjcmlwdCBsYW5ndWFnZSB0eXBlIG9mIE9iamVjdFxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDhcbiAgICAvLyBhbmQgYXZvaWQgYSBWOCBidWdcbiAgICAvLyBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxXG4gICAgcmV0dXJuIHZhbHVlID8gb2JqZWN0VHlwZXNbdHlwZW9mIHZhbHVlXSA6IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBOYU5gLlxuICAgKlxuICAgKiBOb3RlOiBUaGlzIGlzIG5vdCB0aGUgc2FtZSBhcyBuYXRpdmUgYGlzTmFOYCwgd2hpY2ggd2lsbCByZXR1cm4gdHJ1ZSBmb3JcbiAgICogYHVuZGVmaW5lZGAgYW5kIG90aGVyIHZhbHVlcy4gU2VlIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjEuMi40LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaXNOYU4oTmFOKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzTmFOKG5ldyBOdW1iZXIoTmFOKSk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogaXNOYU4odW5kZWZpbmVkKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzTmFOKHVuZGVmaW5lZCk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqL1xuICBmdW5jdGlvbiBpc05hTih2YWx1ZSkge1xuICAgIC8vIGBOYU5gIGFzIGEgcHJpbWl0aXZlIGlzIHRoZSBvbmx5IHZhbHVlIHRoYXQgaXMgbm90IGVxdWFsIHRvIGl0c2VsZlxuICAgIC8vIChwZXJmb3JtIHRoZSBbW0NsYXNzXV0gY2hlY2sgZmlyc3QgdG8gYXZvaWQgZXJyb3JzIHdpdGggc29tZSBob3N0IG9iamVjdHMgaW4gSUUpXG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IG51bWJlckNsYXNzICYmIHZhbHVlICE9ICt2YWx1ZVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBudWxsYC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBgbnVsbGAsIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc051bGwobnVsbCk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc051bGwodW5kZWZpbmVkKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICovXG4gIGZ1bmN0aW9uIGlzTnVsbCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIG51bWJlci5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmlzTnVtYmVyKDguNCAqIDUpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqL1xuICBmdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBudW1iZXJDbGFzcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBnaXZlbiBgdmFsdWVgIGlzIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGZ1bmN0aW9uIFN0b29nZShuYW1lLCBhZ2UpIHtcbiAgICogICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgKiAgIHRoaXMuYWdlID0gYWdlO1xuICAgKiB9XG4gICAqXG4gICAqIF8uaXNQbGFpbk9iamVjdChuZXcgU3Rvb2dlKCdtb2UnLCA0MCkpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICpcbiAgICogXy5pc1BsYWluT2JqZWN0KHsgJ25hbWUnOiAnbW9lJywgJ2FnZSc6IDQwIH0pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqL1xuICB2YXIgaXNQbGFpbk9iamVjdCA9ICFnZXRQcm90b3R5cGVPZiA/IHNoaW1Jc1BsYWluT2JqZWN0IDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAoISh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZixcbiAgICAgICAgb2JqUHJvdG8gPSB0eXBlb2YgdmFsdWVPZiA9PSAnZnVuY3Rpb24nICYmIChvYmpQcm90byA9IGdldFByb3RvdHlwZU9mKHZhbHVlT2YpKSAmJiBnZXRQcm90b3R5cGVPZihvYmpQcm90byk7XG5cbiAgICByZXR1cm4gb2JqUHJvdG9cbiAgICAgID8gdmFsdWUgPT0gb2JqUHJvdG8gfHwgKGdldFByb3RvdHlwZU9mKHZhbHVlKSA9PSBvYmpQcm90byAmJiAhaXNBcmd1bWVudHModmFsdWUpKVxuICAgICAgOiBzaGltSXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcmVndWxhciBleHByZXNzaW9uLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgcmVndWxhciBleHByZXNzaW9uLCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaXNSZWdFeHAoL21vZS8pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqL1xuICBmdW5jdGlvbiBpc1JlZ0V4cCh2YWx1ZSkge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSByZWdleHBDbGFzcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHN0cmluZy5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIHN0cmluZywgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmlzU3RyaW5nKCdtb2UnKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3RyaW5nQ2xhc3M7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAsIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc1VuZGVmaW5lZCh2b2lkIDApO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqL1xuICBmdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXJyYXkgY29tcG9zZWQgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8ua2V5cyh7ICdvbmUnOiAxLCAndHdvJzogMiwgJ3RocmVlJzogMyB9KTtcbiAgICogLy8gPT4gWydvbmUnLCAndHdvJywgJ3RocmVlJ10gKG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgKi9cbiAgdmFyIGtleXMgPSAhbmF0aXZlS2V5cyA/IHNoaW1LZXlzIDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgLy8gYXZvaWQgaXRlcmF0aW5nIG92ZXIgdGhlIGBwcm90b3R5cGVgIHByb3BlcnR5XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT0gJ2Z1bmN0aW9uJyAmJiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgJ3Byb3RvdHlwZScpXG4gICAgICA/IHNoaW1LZXlzKG9iamVjdClcbiAgICAgIDogKGlzT2JqZWN0KG9iamVjdCkgPyBuYXRpdmVLZXlzKG9iamVjdCkgOiBbXSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1lcmdlcyBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgdGhlIHNvdXJjZSBvYmplY3QocykgaW50byB0aGUgYGRlc3RpbmF0aW9uYFxuICAgKiBvYmplY3QuIFN1YnNlcXVlbnQgc291cmNlcyB3aWxsIG92ZXJ3cml0ZSBwcm9wZXJ5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzXG4gICAqIHNvdXJjZXMuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3NvdXJjZTEsIHNvdXJjZTIsIC4uLl0gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgKiBAcGFyYW0tIHtPYmplY3R9IFtpbmRpY2F0b3JdIEludGVybmFsbHkgdXNlZCB0byBpbmRpY2F0ZSB0aGF0IHRoZSBgc3RhY2tgXG4gICAqICBhcmd1bWVudCBpcyBhbiBhcnJheSBvZiB0cmF2ZXJzZWQgb2JqZWN0cyBpbnN0ZWFkIG9mIGFub3RoZXIgc291cmNlIG9iamVjdC5cbiAgICogQHBhcmFtLSB7QXJyYXl9IFtzdGFja0E9W11dIEludGVybmFsbHkgdXNlZCB0byB0cmFjayB0cmF2ZXJzZWQgc291cmNlIG9iamVjdHMuXG4gICAqIEBwYXJhbS0ge0FycmF5fSBbc3RhY2tCPVtdXSBJbnRlcm5hbGx5IHVzZWQgdG8gYXNzb2NpYXRlIHZhbHVlcyB3aXRoIHRoZWlyXG4gICAqICBzb3VyY2UgY291bnRlcnBhcnRzLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBzdG9vZ2VzID0gW1xuICAgKiAgIHsgJ25hbWUnOiAnbW9lJyB9LFxuICAgKiAgIHsgJ25hbWUnOiAnbGFycnknIH1cbiAgICogXTtcbiAgICpcbiAgICogdmFyIGFnZXMgPSBbXG4gICAqICAgeyAnYWdlJzogNDAgfSxcbiAgICogICB7ICdhZ2UnOiA1MCB9XG4gICAqIF07XG4gICAqXG4gICAqIF8ubWVyZ2Uoc3Rvb2dlcywgYWdlcyk7XG4gICAqIC8vID0+IFt7ICduYW1lJzogJ21vZScsICdhZ2UnOiA0MCB9LCB7ICduYW1lJzogJ2xhcnJ5JywgJ2FnZSc6IDUwIH1dXG4gICAqL1xuICBmdW5jdGlvbiBtZXJnZShvYmplY3QsIHNvdXJjZSwgaW5kaWNhdG9yKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgbGVuZ3RoID0gMixcbiAgICAgICAgc3RhY2tBID0gYXJnc1szXSxcbiAgICAgICAgc3RhY2tCID0gYXJnc1s0XTtcblxuICAgIGlmIChpbmRpY2F0b3IgIT09IG9iamVjdFJlZikge1xuICAgICAgc3RhY2tBID0gW107XG4gICAgICBzdGFja0IgPSBbXTtcbiAgICAgIGxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuICAgIH1cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgZm9yT3duKGFyZ3NbaW5kZXhdLCBmdW5jdGlvbihzb3VyY2UsIGtleSkge1xuICAgICAgICB2YXIgZm91bmQsIGlzQXJyLCB2YWx1ZTtcbiAgICAgICAgaWYgKHNvdXJjZSAmJiAoKGlzQXJyID0gaXNBcnJheShzb3VyY2UpKSB8fCBpc1BsYWluT2JqZWN0KHNvdXJjZSkpKSB7XG4gICAgICAgICAgLy8gYXZvaWQgbWVyZ2luZyBwcmV2aW91c2x5IG1lcmdlZCBjeWNsaWMgc291cmNlc1xuICAgICAgICAgIHZhciBzdGFja0xlbmd0aCA9IHN0YWNrQS5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKHN0YWNrTGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIGZvdW5kID0gc3RhY2tBW3N0YWNrTGVuZ3RoXSA9PSBzb3VyY2U7XG4gICAgICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgb2JqZWN0W2tleV0gPSBzdGFja0Jbc3RhY2tMZW5ndGhdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGFkZCBgc291cmNlYCBhbmQgYXNzb2NpYXRlZCBgdmFsdWVgIHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0c1xuICAgICAgICAgICAgc3RhY2tBLnB1c2goc291cmNlKTtcbiAgICAgICAgICAgIHN0YWNrQi5wdXNoKHZhbHVlID0gKHZhbHVlID0gb2JqZWN0W2tleV0sIGlzQXJyKVxuICAgICAgICAgICAgICA/IChpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW10pXG4gICAgICAgICAgICAgIDogKGlzUGxhaW5PYmplY3QodmFsdWUpID8gdmFsdWUgOiB7fSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAvLyByZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKVxuICAgICAgICAgICAgb2JqZWN0W2tleV0gPSBtZXJnZSh2YWx1ZSwgc291cmNlLCBvYmplY3RSZWYsIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICBvYmplY3Rba2V5XSA9IHNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYG9iamVjdGAgZXhjbHVkaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICogUHJvcGVydHkgbmFtZXMgbWF5IGJlIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cyBvciBhcyBhcnJheXMgb2ZcbiAgICogcHJvcGVydHkgbmFtZXMuIElmIGBjYWxsYmFja2AgaXMgcGFzc2VkLCBpdCB3aWxsIGJlIGV4ZWN1dGVkIGZvciBlYWNoIHByb3BlcnR5XG4gICAqIGluIHRoZSBgb2JqZWN0YCwgb21pdHRpbmcgdGhlIHByb3BlcnRpZXMgYGNhbGxiYWNrYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZVxuICAgKiBgY2FsbGJhY2tgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd9IGNhbGxiYWNrfFtwcm9wMSwgcHJvcDIsIC4uLl0gVGhlIHByb3BlcnRpZXMgdG8gb21pdFxuICAgKiAgb3IgdGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0ge01peGVkfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IHdpdGhvdXQgdGhlIG9taXR0ZWQgcHJvcGVydGllcy5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5vbWl0KHsgJ25hbWUnOiAnbW9lJywgJ2FnZSc6IDQwLCAndXNlcmlkJzogJ21vZTEnIH0sICd1c2VyaWQnKTtcbiAgICogLy8gPT4geyAnbmFtZSc6ICdtb2UnLCAnYWdlJzogNDAgfVxuICAgKlxuICAgKiBfLm9taXQoeyAnbmFtZSc6ICdtb2UnLCAnX2hpbnQnOiAna251Y2tsZWhlYWQnLCAnX3NlZWQnOiAnOTZjNGViJyB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAqICAgcmV0dXJuIGtleS5jaGFyQXQoMCkgPT0gJ18nO1xuICAgKiB9KTtcbiAgICogLy8gPT4geyAnbmFtZSc6ICdtb2UnIH1cbiAgICovXG4gIGZ1bmN0aW9uIG9taXQob2JqZWN0LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIHZhciBpc0Z1bmMgPSB0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICBpZiAoaXNGdW5jKSB7XG4gICAgICBjYWxsYmFjayA9IGNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHByb3BzID0gY29uY2F0LmFwcGx5KGFycmF5UmVmLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBmb3JJbihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgaWYgKGlzRnVuY1xuICAgICAgICAgICAgPyAhY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0KVxuICAgICAgICAgICAgOiBpbmRleE9mKHByb3BzLCBrZXksIDEpIDwgMFxuICAgICAgICAgICkge1xuICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHR3byBkaW1lbnNpb25hbCBhcnJheSBvZiB0aGUgZ2l2ZW4gb2JqZWN0J3Mga2V5LXZhbHVlIHBhaXJzLFxuICAgKiBpLmUuIGBbW2tleTEsIHZhbHVlMV0sIFtrZXkyLCB2YWx1ZTJdXWAuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBuZXcgYXJyYXkgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLnBhaXJzKHsgJ21vZSc6IDMwLCAnbGFycnknOiA0MCwgJ2N1cmx5JzogNTAgfSk7XG4gICAqIC8vID0+IFtbJ21vZScsIDMwXSwgWydsYXJyeScsIDQwXSwgWydjdXJseScsIDUwXV0gKG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgKi9cbiAgZnVuY3Rpb24gcGFpcnMob2JqZWN0KSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc2hhbGxvdyBjbG9uZSBvZiBgb2JqZWN0YCBjb21wb3NlZCBvZiB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAqIFByb3BlcnR5IG5hbWVzIG1heSBiZSBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMgb3IgYXMgYXJyYXlzIG9mXG4gICAqIHByb3BlcnR5IG5hbWVzLiBJZiBgY2FsbGJhY2tgIGlzIHBhc3NlZCwgaXQgd2lsbCBiZSBleGVjdXRlZCBmb3IgZWFjaCBwcm9wZXJ0eVxuICAgKiBpbiB0aGUgYG9iamVjdGAsIHBpY2tpbmcgdGhlIHByb3BlcnRpZXMgYGNhbGxiYWNrYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZVxuICAgKiBgY2FsbGJhY2tgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd9IGNhbGxiYWNrfFtwcm9wMSwgcHJvcDIsIC4uLl0gVGhlIHByb3BlcnRpZXMgdG8gcGlja1xuICAgKiAgb3IgdGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0ge01peGVkfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBwaWNrZWQgcHJvcGVydGllcy5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5waWNrKHsgJ25hbWUnOiAnbW9lJywgJ2FnZSc6IDQwLCAndXNlcmlkJzogJ21vZTEnIH0sICduYW1lJywgJ2FnZScpO1xuICAgKiAvLyA9PiB7ICduYW1lJzogJ21vZScsICdhZ2UnOiA0MCB9XG4gICAqXG4gICAqIF8ucGljayh7ICduYW1lJzogJ21vZScsICdfaGludCc6ICdrbnVja2xlaGVhZCcsICdfc2VlZCc6ICc5NmM0ZWInIH0sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICogICByZXR1cm4ga2V5LmNoYXJBdCgwKSAhPSAnXyc7XG4gICAqIH0pO1xuICAgKiAvLyA9PiB7ICduYW1lJzogJ21vZScgfVxuICAgKi9cbiAgZnVuY3Rpb24gcGljayhvYmplY3QsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICBwcm9wcyA9IGNvbmNhdC5hcHBseShhcnJheVJlZiwgYXJndW1lbnRzKSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayA9IGNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnKTtcbiAgICAgIGZvckluKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QpKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhcnJheSBjb21wb3NlZCBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLnZhbHVlcyh7ICdvbmUnOiAxLCAndHdvJzogMiwgJ3RocmVlJzogMyB9KTtcbiAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAqL1xuICBmdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBnaXZlbiBgdGFyZ2V0YCBlbGVtZW50IGlzIHByZXNlbnQgaW4gYSBgY29sbGVjdGlvbmAgdXNpbmcgc3RyaWN0XG4gICAqIGVxdWFsaXR5IGZvciBjb21wYXJpc29ucywgaS5lLiBgPT09YC4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0IGlzIHVzZWRcbiAgICogYXMgdGhlIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGFsaWFzIGluY2x1ZGVcbiAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fFN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHRhcmdldCBUaGUgdmFsdWUgdG8gY2hlY2sgZm9yLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHRhcmdldGAgZWxlbWVudCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmNvbnRhaW5zKFsxLCAyLCAzXSwgMSk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5jb250YWlucyhbMSwgMiwgM10sIDEsIDIpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBfLmNvbnRhaW5zKHsgJ25hbWUnOiAnbW9lJywgJ2FnZSc6IDQwIH0sICdtb2UnKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmNvbnRhaW5zKCdjdXJseScsICd1cicpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqL1xuICBmdW5jdGlvbiBjb250YWlucyhjb2xsZWN0aW9uLCB0YXJnZXQsIGZyb21JbmRleCkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuXG4gICAgZnJvbUluZGV4ID0gKGZyb21JbmRleCA8IDAgPyBuYXRpdmVNYXgoMCwgbGVuZ3RoICsgZnJvbUluZGV4KSA6IGZyb21JbmRleCkgfHwgMDtcbiAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIChpc1N0cmluZyhjb2xsZWN0aW9uKVxuICAgICAgICA/IGNvbGxlY3Rpb24uaW5kZXhPZih0YXJnZXQsIGZyb21JbmRleClcbiAgICAgICAgOiBpbmRleE9mKGNvbGxlY3Rpb24sIHRhcmdldCwgZnJvbUluZGV4KVxuICAgICAgKSA+IC0xO1xuICAgIH1cbiAgICByZXR1cm4gc29tZShjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuICsraW5kZXggPj0gZnJvbUluZGV4ICYmIHZhbHVlID09PSB0YXJnZXQ7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyByZXR1cm5lZCBmcm9tIHJ1bm5pbmcgZWFjaCBlbGVtZW50IG9mXG4gICAqIGBjb2xsZWN0aW9uYCB0aHJvdWdoIGEgYGNhbGxiYWNrYC4gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgb2YgZWFjaCBrZXkgaXNcbiAgICogdGhlIG51bWJlciBvZiB0aW1lcyB0aGUga2V5IHdhcyByZXR1cm5lZCBieSBgY2FsbGJhY2tgLiBUaGUgYGNhbGxiYWNrYCBpc1xuICAgKiBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICogVGhlIGBjYWxsYmFja2AgYXJndW1lbnQgbWF5IGFsc28gYmUgdGhlIG5hbWUgb2YgYSBwcm9wZXJ0eSB0byBjb3VudCBieSAoZS5nLiAnbGVuZ3RoJykuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fFN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBjYWxsYmFja3xwcm9wZXJ0eSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb25cbiAgICogIG9yIHByb3BlcnR5IG5hbWUgdG8gY291bnQgYnkuXG4gICAqIEBwYXJhbSB7TWl4ZWR9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5jb3VudEJ5KFs0LjMsIDYuMSwgNi40XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBNYXRoLmZsb29yKG51bSk7IH0pO1xuICAgKiAvLyA9PiB7ICc0JzogMSwgJzYnOiAyIH1cbiAgICpcbiAgICogXy5jb3VudEJ5KFs0LjMsIDYuMSwgNi40XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiB0aGlzLmZsb29yKG51bSk7IH0sIE1hdGgpO1xuICAgKiAvLyA9PiB7ICc0JzogMSwgJzYnOiAyIH1cbiAgICpcbiAgICogXy5jb3VudEJ5KFsnb25lJywgJ3R3bycsICd0aHJlZSddLCAnbGVuZ3RoJyk7XG4gICAqIC8vID0+IHsgJzMnOiAyLCAnNSc6IDEgfVxuICAgKi9cbiAgZnVuY3Rpb24gY291bnRCeShjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBjYWxsYmFjayA9IGNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnKTtcbiAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgIGtleSA9IGNhbGxiYWNrKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICAgICAgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpID8gcmVzdWx0W2tleV0rKyA6IHJlc3VsdFtrZXldID0gMSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGBjYWxsYmFja2AgcmV0dXJucyBhIHRydXRoeSB2YWx1ZSBmb3IgKiphbGwqKiBlbGVtZW50cyBvZiBhXG4gICAqIGBjb2xsZWN0aW9uYC4gVGhlIGBjYWxsYmFja2AgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICogYXJndW1lbnRzOyAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGFsaWFzIGFsbFxuICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8U3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7TWl4ZWR9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBjYWxsYmFjayBjaGVjayxcbiAgICogIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5ldmVyeShbdHJ1ZSwgMSwgbnVsbCwgJ3llcyddLCBCb29sZWFuKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICovXG4gIGZ1bmN0aW9uIGV2ZXJ5KGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgY2FsbGJhY2sgPSBjcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZyk7XG5cbiAgICBpZiAoaXNBcnJheShjb2xsZWN0aW9uKSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGlmICghKHJlc3VsdCA9ICEhY2FsbGJhY2soY29sbGVjdGlvbltpbmRleF0sIGluZGV4LCBjb2xsZWN0aW9uKSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gKHJlc3VsdCA9ICEhY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGFtaW5lcyBlYWNoIGVsZW1lbnQgaW4gYSBgY29sbGVjdGlvbmAsIHJldHVybmluZyBhbiBhcnJheSBvZiBhbGwgZWxlbWVudHNcbiAgICogdGhlIGBjYWxsYmFja2AgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgYGNhbGxiYWNrYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kXG4gICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAYWxpYXMgc2VsZWN0XG4gICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxTdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHtNaXhlZH0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZWxlbWVudHMgdGhhdCBwYXNzZWQgdGhlIGNhbGxiYWNrIGNoZWNrLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgZXZlbnMgPSBfLmZpbHRlcihbMSwgMiwgMywgNCwgNSwgNl0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gbnVtICUgMiA9PSAwOyB9KTtcbiAgICogLy8gPT4gWzIsIDQsIDZdXG4gICAqL1xuICBmdW5jdGlvbiBmaWx0ZXIoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgY2FsbGJhY2sgPSBjcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZyk7XG4gICAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEV4YW1pbmVzIGVhY2ggZWxlbWVudCBpbiBhIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIHRoZSBmaXJzdCBvbmUgdGhlIGBjYWxsYmFja2BcbiAgICogcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgZnVuY3Rpb24gcmV0dXJucyBhcyBzb29uIGFzIGl0IGZpbmRzIGFuIGFjY2VwdGFibGVcbiAgICogZWxlbWVudCwgYW5kIGRvZXMgbm90IGl0ZXJhdGUgb3ZlciB0aGUgZW50aXJlIGBjb2xsZWN0aW9uYC4gVGhlIGBjYWxsYmFja2AgaXNcbiAgICogYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGFsaWFzIGRldGVjdFxuICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8U3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0ge01peGVkfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAqIEByZXR1cm5zIHtNaXhlZH0gUmV0dXJucyB0aGUgZWxlbWVudCB0aGF0IHBhc3NlZCB0aGUgY2FsbGJhY2sgY2hlY2ssXG4gICAqICBlbHNlIGB1bmRlZmluZWRgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgZXZlbiA9IF8uZmluZChbMSwgMiwgMywgNCwgNSwgNl0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gbnVtICUgMiA9PSAwOyB9KTtcbiAgICogLy8gPT4gMlxuICAgKi9cbiAgZnVuY3Rpb24gZmluZChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIHZhciByZXN1bHQ7XG4gICAgY2FsbGJhY2sgPSBjcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZyk7XG4gICAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlcyBvdmVyIGEgYGNvbGxlY3Rpb25gLCBleGVjdXRpbmcgdGhlIGBjYWxsYmFja2AgZm9yIGVhY2ggZWxlbWVudCBpblxuICAgKiB0aGUgYGNvbGxlY3Rpb25gLiBUaGUgYGNhbGxiYWNrYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS4gQ2FsbGJhY2tzIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseVxuICAgKiBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBhbGlhcyBlYWNoXG4gICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxTdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7TWl4ZWR9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICogQHJldHVybnMge0FycmF5fE9iamVjdHxTdHJpbmd9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfKFsxLCAyLCAzXSkuZm9yRWFjaChhbGVydCkuam9pbignLCcpO1xuICAgKiAvLyA9PiBhbGVydHMgZWFjaCBudW1iZXIgYW5kIHJldHVybnMgJzEsMiwzJ1xuICAgKlxuICAgKiBfLmZvckVhY2goeyAnb25lJzogMSwgJ3R3byc6IDIsICd0aHJlZSc6IDMgfSwgYWxlcnQpO1xuICAgKiAvLyA9PiBhbGVydHMgZWFjaCBudW1iZXIgKG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgKi9cbiAgdmFyIGZvckVhY2ggPSBjcmVhdGVJdGVyYXRvcihmb3JFYWNoSXRlcmF0b3JPcHRpb25zKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyByZXR1cm5lZCBmcm9tIHJ1bm5pbmcgZWFjaCBlbGVtZW50IG9mXG4gICAqIGBjb2xsZWN0aW9uYCB0aHJvdWdoIGEgYGNhbGxiYWNrYC4gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgb2YgZWFjaCBrZXkgaXMgYW5cbiAgICogYXJyYXkgb2YgZWxlbWVudHMgcGFzc2VkIHRvIGBjYWxsYmFja2AgdGhhdCByZXR1cm5lZCB0aGUga2V5LiBUaGUgYGNhbGxiYWNrYFxuICAgKiBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICogVGhlIGBjYWxsYmFja2AgYXJndW1lbnQgbWF5IGFsc28gYmUgdGhlIG5hbWUgb2YgYSBwcm9wZXJ0eSB0byBncm91cCBieSAoZS5nLiAnbGVuZ3RoJykuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fFN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBjYWxsYmFja3xwcm9wZXJ0eSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb25cbiAgICogIG9yIHByb3BlcnR5IG5hbWUgdG8gZ3JvdXAgYnkuXG4gICAqIEBwYXJhbSB7TWl4ZWR9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5ncm91cEJ5KFs0LjIsIDYuMSwgNi40XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBNYXRoLmZsb29yKG51bSk7IH0pO1xuICAgKiAvLyA9PiB7ICc0JzogWzQuMl0sICc2JzogWzYuMSwgNi40XSB9XG4gICAqXG4gICAqIF8uZ3JvdXBCeShbNC4yLCA2LjEsIDYuNF0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gdGhpcy5mbG9vcihudW0pOyB9LCBNYXRoKTtcbiAgICogLy8gPT4geyAnNCc6IFs0LjJdLCAnNic6IFs2LjEsIDYuNF0gfVxuICAgKlxuICAgKiBfLmdyb3VwQnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcbiAgICogLy8gPT4geyAnMyc6IFsnb25lJywgJ3R3byddLCAnNSc6IFsndGhyZWUnXSB9XG4gICAqL1xuICBmdW5jdGlvbiBncm91cEJ5KGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGNhbGxiYWNrID0gY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcpO1xuICAgIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAga2V5ID0gY2FsbGJhY2sodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG4gICAgICAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkgPyByZXN1bHRba2V5XSA6IHJlc3VsdFtrZXldID0gW10pLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlcyB0aGUgbWV0aG9kIG5hbWVkIGJ5IGBtZXRob2ROYW1lYCBvbiBlYWNoIGVsZW1lbnQgaW4gdGhlIGBjb2xsZWN0aW9uYCxcbiAgICogcmV0dXJuaW5nIGFuIGFycmF5IG9mIHRoZSByZXN1bHRzIG9mIGVhY2ggaW52b2tlZCBtZXRob2QuIEFkZGl0aW9uYWwgYXJndW1lbnRzXG4gICAqIHdpbGwgYmUgcGFzc2VkIHRvIGVhY2ggaW52b2tlZCBtZXRob2QuIElmIGBtZXRob2ROYW1lYCBpcyBhIGZ1bmN0aW9uIGl0IHdpbGxcbiAgICogYmUgaW52b2tlZCBmb3IsIGFuZCBgdGhpc2AgYm91bmQgdG8sIGVhY2ggZWxlbWVudCBpbiB0aGUgYGNvbGxlY3Rpb25gLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxTdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ30gbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRvIGludm9rZSBvclxuICAgKiAgdGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHtNaXhlZH0gW2FyZzEsIGFyZzIsIC4uLl0gQXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZiBlYWNoIGludm9rZWQgbWV0aG9kLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmludm9rZShbWzUsIDEsIDddLCBbMywgMiwgMV1dLCAnc29ydCcpO1xuICAgKiAvLyA9PiBbWzEsIDUsIDddLCBbMSwgMiwgM11dXG4gICAqXG4gICAqIF8uaW52b2tlKFsxMjMsIDQ1Nl0sIFN0cmluZy5wcm90b3R5cGUuc3BsaXQsICcnKTtcbiAgICogLy8gPT4gW1snMScsICcyJywgJzMnXSwgWyc0JywgJzUnLCAnNiddXVxuICAgKi9cbiAgZnVuY3Rpb24gaW52b2tlKGNvbGxlY3Rpb24sIG1ldGhvZE5hbWUpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSxcbiAgICAgICAgaXNGdW5jID0gdHlwZW9mIG1ldGhvZE5hbWUgPT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXN1bHQucHVzaCgoaXNGdW5jID8gbWV0aG9kTmFtZSA6IHZhbHVlW21ldGhvZE5hbWVdKS5hcHBseSh2YWx1ZSwgYXJncykpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB2YWx1ZXMgYnkgcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gdGhlIGBjb2xsZWN0aW9uYFxuICAgKiB0aHJvdWdoIGEgYGNhbGxiYWNrYC4gVGhlIGBjYWxsYmFja2AgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGhcbiAgICogdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGFsaWFzIGNvbGxlY3RcbiAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fFN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0ge01peGVkfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZiBlYWNoIGBjYWxsYmFja2AgZXhlY3V0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLm1hcChbMSwgMiwgM10sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gbnVtICogMzsgfSk7XG4gICAqIC8vID0+IFszLCA2LCA5XVxuICAgKlxuICAgKiBfLm1hcCh7ICdvbmUnOiAxLCAndHdvJzogMiwgJ3RocmVlJzogMyB9LCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIG51bSAqIDM7IH0pO1xuICAgKiAvLyA9PiBbMywgNiwgOV0gKG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgKi9cbiAgZnVuY3Rpb24gbWFwKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDAsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgPyBsZW5ndGggOiAwKTtcblxuICAgIGNhbGxiYWNrID0gY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcpO1xuICAgIGlmIChpc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gY2FsbGJhY2soY29sbGVjdGlvbltpbmRleF0sIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IGNhbGxiYWNrKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBtYXhpbXVtIHZhbHVlIG9mIGFuIGBhcnJheWAuIElmIGBjYWxsYmFja2AgaXMgcGFzc2VkLFxuICAgKiBpdCB3aWxsIGJlIGV4ZWN1dGVkIGZvciBlYWNoIHZhbHVlIGluIHRoZSBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZVxuICAgKiBjcml0ZXJpb24gYnkgd2hpY2ggdGhlIHZhbHVlIGlzIHJhbmtlZC4gVGhlIGBjYWxsYmFja2AgaXMgYm91bmQgdG9cbiAgICogYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8U3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7TWl4ZWR9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICogQHJldHVybnMge01peGVkfSBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgc3Rvb2dlcyA9IFtcbiAgICogICB7ICduYW1lJzogJ21vZScsICdhZ2UnOiA0MCB9LFxuICAgKiAgIHsgJ25hbWUnOiAnbGFycnknLCAnYWdlJzogNTAgfSxcbiAgICogICB7ICduYW1lJzogJ2N1cmx5JywgJ2FnZSc6IDYwIH1cbiAgICogXTtcbiAgICpcbiAgICogXy5tYXgoc3Rvb2dlcywgZnVuY3Rpb24oc3Rvb2dlKSB7IHJldHVybiBzdG9vZ2UuYWdlOyB9KTtcbiAgICogLy8gPT4geyAnbmFtZSc6ICdjdXJseScsICdhZ2UnOiA2MCB9O1xuICAgKi9cbiAgZnVuY3Rpb24gbWF4KGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgdmFyIGNvbXB1dGVkID0gLUluZmluaXR5LFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwLFxuICAgICAgICByZXN1bHQgPSBjb21wdXRlZDtcblxuICAgIGlmIChjYWxsYmFjayB8fCAhaXNBcnJheShjb2xsZWN0aW9uKSkge1xuICAgICAgY2FsbGJhY2sgPSAhY2FsbGJhY2sgJiYgaXNTdHJpbmcoY29sbGVjdGlvbilcbiAgICAgICAgPyBjaGFyQXRDYWxsYmFja1xuICAgICAgICA6IGNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnKTtcblxuICAgICAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICBpZiAoY3VycmVudCA+IGNvbXB1dGVkKSB7XG4gICAgICAgICAgY29tcHV0ZWQgPSBjdXJyZW50O1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKGNvbGxlY3Rpb25baW5kZXhdID4gcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gY29sbGVjdGlvbltpbmRleF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIG1pbmltdW0gdmFsdWUgb2YgYW4gYGFycmF5YC4gSWYgYGNhbGxiYWNrYCBpcyBwYXNzZWQsXG4gICAqIGl0IHdpbGwgYmUgZXhlY3V0ZWQgZm9yIGVhY2ggdmFsdWUgaW4gdGhlIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlXG4gICAqIGNyaXRlcmlvbiBieSB3aGljaCB0aGUgdmFsdWUgaXMgcmFua2VkLiBUaGUgYGNhbGxiYWNrYCBpcyBib3VuZCB0byBgdGhpc0FyZ2BcbiAgICogYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxTdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHtNaXhlZH0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgKiBAcmV0dXJucyB7TWl4ZWR9IFJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8ubWluKFsxMCwgNSwgMTAwLCAyLCAxMDAwXSk7XG4gICAqIC8vID0+IDJcbiAgICovXG4gIGZ1bmN0aW9uIG1pbihjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIHZhciBjb21wdXRlZCA9IEluZmluaXR5LFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwLFxuICAgICAgICByZXN1bHQgPSBjb21wdXRlZDtcblxuICAgIGlmIChjYWxsYmFjayB8fCAhaXNBcnJheShjb2xsZWN0aW9uKSkge1xuICAgICAgY2FsbGJhY2sgPSAhY2FsbGJhY2sgJiYgaXNTdHJpbmcoY29sbGVjdGlvbilcbiAgICAgICAgPyBjaGFyQXRDYWxsYmFja1xuICAgICAgICA6IGNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnKTtcblxuICAgICAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICBpZiAoY3VycmVudCA8IGNvbXB1dGVkKSB7XG4gICAgICAgICAgY29tcHV0ZWQgPSBjdXJyZW50O1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKGNvbGxlY3Rpb25baW5kZXhdIDwgcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gY29sbGVjdGlvbltpbmRleF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIHZhbHVlIG9mIGEgc3BlY2lmaWVkIHByb3BlcnR5IGZyb20gYWxsIGVsZW1lbnRzIGluXG4gICAqIHRoZSBgY29sbGVjdGlvbmAuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fFN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBUaGUgcHJvcGVydHkgdG8gcGx1Y2suXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBzdG9vZ2VzID0gW1xuICAgKiAgIHsgJ25hbWUnOiAnbW9lJywgJ2FnZSc6IDQwIH0sXG4gICAqICAgeyAnbmFtZSc6ICdsYXJyeScsICdhZ2UnOiA1MCB9LFxuICAgKiAgIHsgJ25hbWUnOiAnY3VybHknLCAnYWdlJzogNjAgfVxuICAgKiBdO1xuICAgKlxuICAgKiBfLnBsdWNrKHN0b29nZXMsICduYW1lJyk7XG4gICAqIC8vID0+IFsnbW9lJywgJ2xhcnJ5JywgJ2N1cmx5J11cbiAgICovXG4gIGZ1bmN0aW9uIHBsdWNrKGNvbGxlY3Rpb24sIHByb3BlcnR5KSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlW3Byb3BlcnR5XSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBCb2lscyBkb3duIGEgYGNvbGxlY3Rpb25gIHRvIGEgc2luZ2xlIHZhbHVlLiBUaGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGVcbiAgICogcmVkdWN0aW9uIGlzIGBhY2N1bXVsYXRvcmAgYW5kIGVhY2ggc3VjY2Vzc2l2ZSBzdGVwIG9mIGl0IHNob3VsZCBiZSByZXR1cm5lZFxuICAgKiBieSB0aGUgYGNhbGxiYWNrYC4gVGhlIGBjYWxsYmFja2AgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggNFxuICAgKiBhcmd1bWVudHM7IGZvciBhcnJheXMgdGhleSBhcmUgKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAYWxpYXMgZm9sZGwsIGluamVjdFxuICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8U3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0ge01peGVkfSBbYWNjdW11bGF0b3JdIEluaXRpYWwgdmFsdWUgb2YgdGhlIGFjY3VtdWxhdG9yLlxuICAgKiBAcGFyYW0ge01peGVkfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAqIEByZXR1cm5zIHtNaXhlZH0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBzdW0gPSBfLnJlZHVjZShbMSwgMiwgM10sIGZ1bmN0aW9uKG1lbW8sIG51bSkgeyByZXR1cm4gbWVtbyArIG51bTsgfSk7XG4gICAqIC8vID0+IDZcbiAgICovXG4gIGZ1bmN0aW9uIHJlZHVjZShjb2xsZWN0aW9uLCBjYWxsYmFjaywgYWNjdW11bGF0b3IsIHRoaXNBcmcpIHtcbiAgICB2YXIgbm9hY2N1bSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzO1xuICAgIGNhbGxiYWNrID0gY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcpO1xuICAgIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IG5vYWNjdW1cbiAgICAgICAgPyAobm9hY2N1bSA9IGZhbHNlLCB2YWx1ZSlcbiAgICAgICAgOiBjYWxsYmFjayhhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKVxuICAgIH0pO1xuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcmlnaHQtYXNzb2NpYXRpdmUgdmVyc2lvbiBvZiBgXy5yZWR1Y2VgLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBhbGlhcyBmb2xkclxuICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8U3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0ge01peGVkfSBbYWNjdW11bGF0b3JdIEluaXRpYWwgdmFsdWUgb2YgdGhlIGFjY3VtdWxhdG9yLlxuICAgKiBAcGFyYW0ge01peGVkfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAqIEByZXR1cm5zIHtNaXhlZH0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBsaXN0ID0gW1swLCAxXSwgWzIsIDNdLCBbNCwgNV1dO1xuICAgKiB2YXIgZmxhdCA9IF8ucmVkdWNlUmlnaHQobGlzdCwgZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYS5jb25jYXQoYik7IH0sIFtdKTtcbiAgICogLy8gPT4gWzQsIDUsIDIsIDMsIDAsIDFdXG4gICAqL1xuICBmdW5jdGlvbiByZWR1Y2VSaWdodChjb2xsZWN0aW9uLCBjYWxsYmFjaywgYWNjdW11bGF0b3IsIHRoaXNBcmcpIHtcbiAgICB2YXIgaXRlcmF0ZWUgPSBjb2xsZWN0aW9uLFxuICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwLFxuICAgICAgICBub2FjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG5cbiAgICBpZiAodHlwZW9mIGxlbmd0aCAhPSAnbnVtYmVyJykge1xuICAgICAgdmFyIHByb3BzID0ga2V5cyhjb2xsZWN0aW9uKTtcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcbiAgICB9IGVsc2UgaWYgKG5vQ2hhckJ5SW5kZXggJiYgaXNTdHJpbmcoY29sbGVjdGlvbikpIHtcbiAgICAgIGl0ZXJhdGVlID0gY29sbGVjdGlvbi5zcGxpdCgnJyk7XG4gICAgfVxuICAgIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICBpbmRleCA9IHByb3BzID8gcHJvcHNbLS1sZW5ndGhdIDogLS1sZW5ndGg7XG4gICAgICBhY2N1bXVsYXRvciA9IG5vYWNjdW1cbiAgICAgICAgPyAobm9hY2N1bSA9IGZhbHNlLCBpdGVyYXRlZVtpbmRleF0pXG4gICAgICAgIDogY2FsbGJhY2suY2FsbCh0aGlzQXJnLCBhY2N1bXVsYXRvciwgaXRlcmF0ZWVbaW5kZXhdLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5maWx0ZXJgLCB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSB2YWx1ZXMgb2YgYVxuICAgKiBgY29sbGVjdGlvbmAgdGhhdCBgY2FsbGJhY2tgIGRvZXMgKipub3QqKiByZXR1cm4gdHJ1dGh5IGZvci5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8U3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7TWl4ZWR9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGVsZW1lbnRzIHRoYXQgZGlkICoqbm90KiogcGFzcyB0aGVcbiAgICogIGNhbGxiYWNrIGNoZWNrLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgb2RkcyA9IF8ucmVqZWN0KFsxLCAyLCAzLCA0LCA1LCA2XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gJSAyID09IDA7IH0pO1xuICAgKiAvLyA9PiBbMSwgMywgNV1cbiAgICovXG4gIGZ1bmN0aW9uIHJlamVjdChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIGNhbGxiYWNrID0gY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcpO1xuICAgIHJldHVybiBmaWx0ZXIoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gIWNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBzaHVmZmxlZCBgYXJyYXlgIHZhbHVlcywgdXNpbmcgYSB2ZXJzaW9uIG9mIHRoZVxuICAgKiBGaXNoZXItWWF0ZXMgc2h1ZmZsZS4gU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVyLVlhdGVzX3NodWZmbGUuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fFN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzaHVmZmxlLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgc2h1ZmZsZWQgY29sbGVjdGlvbi5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5zaHVmZmxlKFsxLCAyLCAzLCA0LCA1LCA2XSk7XG4gICAqIC8vID0+IFs0LCAxLCA2LCAzLCA1LCAyXVxuICAgKi9cbiAgZnVuY3Rpb24gc2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDApO1xuXG4gICAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIHJhbmQgPSBmbG9vcihuYXRpdmVSYW5kb20oKSAqICgrK2luZGV4ICsgMSkpO1xuICAgICAgcmVzdWx0W2luZGV4XSA9IHJlc3VsdFtyYW5kXTtcbiAgICAgIHJlc3VsdFtyYW5kXSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgc2l6ZSBvZiB0aGUgYGNvbGxlY3Rpb25gIGJ5IHJldHVybmluZyBgY29sbGVjdGlvbi5sZW5ndGhgIGZvciBhcnJheXNcbiAgICogYW5kIGFycmF5LWxpa2Ugb2JqZWN0cyBvciB0aGUgbnVtYmVyIG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgZm9yIG9iamVjdHMuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fFN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIGBjb2xsZWN0aW9uLmxlbmd0aGAgb3IgbnVtYmVyIG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uc2l6ZShbMSwgMl0pO1xuICAgKiAvLyA9PiAyXG4gICAqXG4gICAqIF8uc2l6ZSh7ICdvbmUnOiAxLCAndHdvJzogMiwgJ3RocmVlJzogMyB9KTtcbiAgICogLy8gPT4gM1xuICAgKlxuICAgKiBfLnNpemUoJ2N1cmx5Jyk7XG4gICAqIC8vID0+IDVcbiAgICovXG4gIGZ1bmN0aW9uIHNpemUoY29sbGVjdGlvbikge1xuICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuICAgIHJldHVybiB0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInID8gbGVuZ3RoIDoga2V5cyhjb2xsZWN0aW9uKS5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBgY2FsbGJhY2tgIHJldHVybnMgYSB0cnV0aHkgdmFsdWUgZm9yICoqYW55KiogZWxlbWVudCBvZiBhXG4gICAqIGBjb2xsZWN0aW9uYC4gVGhlIGZ1bmN0aW9uIHJldHVybnMgYXMgc29vbiBhcyBpdCBmaW5kcyBwYXNzaW5nIHZhbHVlLCBhbmRcbiAgICogZG9lcyBub3QgaXRlcmF0ZSBvdmVyIHRoZSBlbnRpcmUgYGNvbGxlY3Rpb25gLiBUaGUgYGNhbGxiYWNrYCBpcyBib3VuZCB0b1xuICAgKiBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAYWxpYXMgYW55XG4gICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxTdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHtNaXhlZH0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBjYWxsYmFjayBjaGVjayxcbiAgICogIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5zb21lKFtudWxsLCAwLCAneWVzJywgZmFsc2VdKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKi9cbiAgZnVuY3Rpb24gc29tZShjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIHZhciByZXN1bHQ7XG4gICAgY2FsbGJhY2sgPSBjcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZyk7XG5cbiAgICBpZiAoaXNBcnJheShjb2xsZWN0aW9uKSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChyZXN1bHQgPSBjYWxsYmFjayhjb2xsZWN0aW9uW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuICEocmVzdWx0ID0gY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuICEhcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXJyYXksIHN0YWJsZSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyIGJ5IHRoZSByZXN1bHRzIG9mXG4gICAqIHJ1bm5pbmcgZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJvdWdoIGEgYGNhbGxiYWNrYC4gVGhlIGBjYWxsYmFja2BcbiAgICogaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAqIFRoZSBgY2FsbGJhY2tgIGFyZ3VtZW50IG1heSBhbHNvIGJlIHRoZSBuYW1lIG9mIGEgcHJvcGVydHkgdG8gc29ydCBieSAoZS5nLiAnbGVuZ3RoJykuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fFN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBjYWxsYmFja3xwcm9wZXJ0eSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb25cbiAgICogIG9yIHByb3BlcnR5IG5hbWUgdG8gc29ydCBieS5cbiAgICogQHBhcmFtIHtNaXhlZH0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2Ygc29ydGVkIGVsZW1lbnRzLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLnNvcnRCeShbMSwgMiwgM10sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gTWF0aC5zaW4obnVtKTsgfSk7XG4gICAqIC8vID0+IFszLCAxLCAyXVxuICAgKlxuICAgKiBfLnNvcnRCeShbMSwgMiwgM10sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gdGhpcy5zaW4obnVtKTsgfSwgTWF0aCk7XG4gICAqIC8vID0+IFszLCAxLCAyXVxuICAgKlxuICAgKiBfLnNvcnRCeShbJ2xhcnJ5JywgJ2JyZW5kYW4nLCAnbW9lJ10sICdsZW5ndGgnKTtcbiAgICogLy8gPT4gWydtb2UnLCAnbGFycnknLCAnYnJlbmRhbiddXG4gICAqL1xuICBmdW5jdGlvbiBzb3J0QnkoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgY2FsbGJhY2sgPSBjcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZyk7XG4gICAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgJ2NyaXRlcmlhJzogY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSxcbiAgICAgICAgJ2luZGV4JzogaW5kZXgsXG4gICAgICAgICd2YWx1ZSc6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHZhciBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuICAgIHJlc3VsdC5zb3J0KGNvbXBhcmVBc2NlbmRpbmcpO1xuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgcmVzdWx0W2xlbmd0aF0gPSByZXN1bHRbbGVuZ3RoXS52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgYGNvbGxlY3Rpb25gLCB0byBhbiBhcnJheS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8U3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGNvbnZlcnRlZCBhcnJheS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogKGZ1bmN0aW9uKCkgeyByZXR1cm4gXy50b0FycmF5KGFyZ3VtZW50cykuc2xpY2UoMSk7IH0pKDEsIDIsIDMsIDQpO1xuICAgKiAvLyA9PiBbMiwgMywgNF1cbiAgICovXG4gIGZ1bmN0aW9uIHRvQXJyYXkoY29sbGVjdGlvbikge1xuICAgIGlmIChjb2xsZWN0aW9uICYmIHR5cGVvZiBjb2xsZWN0aW9uLmxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIChub0FycmF5U2xpY2VPblN0cmluZ3MgPyBpc1N0cmluZyhjb2xsZWN0aW9uKSA6IHR5cGVvZiBjb2xsZWN0aW9uID09ICdzdHJpbmcnKVxuICAgICAgICA/IGNvbGxlY3Rpb24uc3BsaXQoJycpXG4gICAgICAgIDogc2xpY2UuY2FsbChjb2xsZWN0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcyhjb2xsZWN0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGFtaW5lcyBlYWNoIGVsZW1lbnQgaW4gYSBgY29sbGVjdGlvbmAsIHJldHVybmluZyBhbiBhcnJheSBvZiBhbGwgZWxlbWVudHNcbiAgICogdGhhdCBjb250YWluIHRoZSBnaXZlbiBgcHJvcGVydGllc2AuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fFN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIGZpbHRlciBieS5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGVsZW1lbnRzIHRoYXQgY29udGFpbiB0aGUgZ2l2ZW4gYHByb3BlcnRpZXNgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgc3Rvb2dlcyA9IFtcbiAgICogICB7ICduYW1lJzogJ21vZScsICdhZ2UnOiA0MCB9LFxuICAgKiAgIHsgJ25hbWUnOiAnbGFycnknLCAnYWdlJzogNTAgfSxcbiAgICogICB7ICduYW1lJzogJ2N1cmx5JywgJ2FnZSc6IDYwIH1cbiAgICogXTtcbiAgICpcbiAgICogXy53aGVyZShzdG9vZ2VzLCB7ICdhZ2UnOiA0MCB9KTtcbiAgICogLy8gPT4gW3sgJ25hbWUnOiAnbW9lJywgJ2FnZSc6IDQwIH1dXG4gICAqL1xuICBmdW5jdGlvbiB3aGVyZShjb2xsZWN0aW9uLCBwcm9wZXJ0aWVzKSB7XG4gICAgdmFyIHByb3BzID0gW107XG4gICAgZm9ySW4ocHJvcGVydGllcywgZnVuY3Rpb24odmFsdWUsIHByb3ApIHtcbiAgICAgIHByb3BzLnB1c2gocHJvcCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZpbHRlcihjb2xsZWN0aW9uLCBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdFtwcm9wc1tsZW5ndGhdXSA9PT0gcHJvcGVydGllc1twcm9wc1tsZW5ndGhdXTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICEhcmVzdWx0O1xuICAgIH0pO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXJyYXkgd2l0aCBhbGwgZmFsc2V5IHZhbHVlcyBvZiBgYXJyYXlgIHJlbW92ZWQuIFRoZSB2YWx1ZXNcbiAgICogYGZhbHNlYCwgYG51bGxgLCBgMGAsIGBcIlwiYCwgYHVuZGVmaW5lZGAgYW5kIGBOYU5gIGFyZSBhbGwgZmFsc2V5LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhY3QuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5jb21wYWN0KFswLCAxLCBmYWxzZSwgMiwgJycsIDNdKTtcbiAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAqL1xuICBmdW5jdGlvbiBjb21wYWN0KGFycmF5KSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGBhcnJheWAgZWxlbWVudHMgbm90IHByZXNlbnQgaW4gdGhlIG90aGVyIGFycmF5c1xuICAgKiB1c2luZyBzdHJpY3QgZXF1YWxpdHkgZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHByb2Nlc3MuXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheTEsIGFycmF5MiwgLi4uXSBBcnJheXMgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBgYXJyYXlgIGVsZW1lbnRzIG5vdCBwcmVzZW50IGluIHRoZVxuICAgKiAgb3RoZXIgYXJyYXlzLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmRpZmZlcmVuY2UoWzEsIDIsIDMsIDQsIDVdLCBbNSwgMiwgMTBdKTtcbiAgICogLy8gPT4gWzEsIDMsIDRdXG4gICAqL1xuICBmdW5jdGlvbiBkaWZmZXJlbmNlKGFycmF5KSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgZmxhdHRlbmVkID0gY29uY2F0LmFwcGx5KGFycmF5UmVmLCBhcmd1bWVudHMpLFxuICAgICAgICBjb250YWlucyA9IGNhY2hlZENvbnRhaW5zKGZsYXR0ZW5lZCwgbGVuZ3RoKSxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgaWYgKCFjb250YWlucyh2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGBhcnJheWAuIFBhc3MgYG5gIHRvIHJldHVybiB0aGUgZmlyc3QgYG5gXG4gICAqIGVsZW1lbnRzIG9mIHRoZSBgYXJyYXlgLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBhbGlhcyBoZWFkLCB0YWtlXG4gICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW25dIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gcmV0dXJuLlxuICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gSW50ZXJuYWxseSB1c2VkIHRvIGFsbG93IHRoaXMgbWV0aG9kIHRvIHdvcmsgd2l0aFxuICAgKiAgb3RoZXJzIGxpa2UgYF8ubWFwYCB3aXRob3V0IHVzaW5nIHRoZWlyIGNhbGxiYWNrIGBpbmRleGAgYXJndW1lbnQgZm9yIGBuYC5cbiAgICogQHJldHVybnMge01peGVkfSBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50IG9yIGFuIGFycmF5IG9mIHRoZSBmaXJzdCBgbmBcbiAgICogIGVsZW1lbnRzIG9mIGBhcnJheWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uZmlyc3QoWzUsIDQsIDMsIDIsIDFdKTtcbiAgICogLy8gPT4gNVxuICAgKi9cbiAgZnVuY3Rpb24gZmlyc3QoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFycmF5KSB7XG4gICAgICByZXR1cm4gKG4gPT0gbnVsbCB8fCBndWFyZCkgPyBhcnJheVswXSA6IHNsaWNlLmNhbGwoYXJyYXksIDAsIG4pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGbGF0dGVucyBhIG5lc3RlZCBhcnJheSAodGhlIG5lc3RpbmcgY2FuIGJlIHRvIGFueSBkZXB0aCkuIElmIGBzaGFsbG93YCBpc1xuICAgKiB0cnV0aHksIGBhcnJheWAgd2lsbCBvbmx5IGJlIGZsYXR0ZW5lZCBhIHNpbmdsZSBsZXZlbC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYWN0LlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNoYWxsb3cgQSBmbGFnIHRvIGluZGljYXRlIG9ubHkgZmxhdHRlbmluZyBhIHNpbmdsZSBsZXZlbC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5mbGF0dGVuKFsxLCBbMl0sIFszLCBbWzRdXV1dKTtcbiAgICogLy8gPT4gWzEsIDIsIDMsIDRdO1xuICAgKlxuICAgKiBfLmZsYXR0ZW4oWzEsIFsyXSwgWzMsIFtbNF1dXV0sIHRydWUpO1xuICAgKiAvLyA9PiBbMSwgMiwgMywgW1s0XV1dO1xuICAgKi9cbiAgZnVuY3Rpb24gZmxhdHRlbihhcnJheSwgc2hhbGxvdykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcblxuICAgICAgLy8gcmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKVxuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHB1c2guYXBwbHkocmVzdWx0LCBzaGFsbG93ID8gdmFsdWUgOiBmbGF0dGVuKHZhbHVlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYHZhbHVlYCBpcyBmb3VuZCB1c2luZ1xuICAgKiBzdHJpY3QgZXF1YWxpdHkgZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLiBJZiB0aGUgYGFycmF5YCBpcyBhbHJlYWR5XG4gICAqIHNvcnRlZCwgcGFzc2luZyBgdHJ1ZWAgZm9yIGBmcm9tSW5kZXhgIHdpbGwgcnVuIGEgZmFzdGVyIGJpbmFyeSBzZWFyY2guXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtCb29sZWFufE51bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20gb3IgYHRydWVgIHRvXG4gICAqICBwZXJmb3JtIGEgYmluYXJ5IHNlYXJjaCBvbiBhIHNvcnRlZCBgYXJyYXlgLlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSBvciBgLTFgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmluZGV4T2YoWzEsIDIsIDMsIDEsIDIsIDNdLCAyKTtcbiAgICogLy8gPT4gMVxuICAgKlxuICAgKiBfLmluZGV4T2YoWzEsIDIsIDMsIDEsIDIsIDNdLCAyLCAzKTtcbiAgICogLy8gPT4gNFxuICAgKlxuICAgKiBfLmluZGV4T2YoWzEsIDEsIDIsIDIsIDMsIDNdLCAyLCB0cnVlKTtcbiAgICogLy8gPT4gMlxuICAgKi9cbiAgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICBpZiAodHlwZW9mIGZyb21JbmRleCA9PSAnbnVtYmVyJykge1xuICAgICAgaW5kZXggPSAoZnJvbUluZGV4IDwgMCA/IG5hdGl2ZU1heCgwLCBsZW5ndGggKyBmcm9tSW5kZXgpIDogZnJvbUluZGV4IHx8IDApIC0gMTtcbiAgICB9IGVsc2UgaWYgKGZyb21JbmRleCkge1xuICAgICAgaW5kZXggPSBzb3J0ZWRJbmRleChhcnJheSwgdmFsdWUpO1xuICAgICAgcmV0dXJuIGFycmF5W2luZGV4XSA9PT0gdmFsdWUgPyBpbmRleCA6IC0xO1xuICAgIH1cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbGwgYnV0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC4gUGFzcyBgbmAgdG8gZXhjbHVkZSB0aGUgbGFzdCBgbmBcbiAgICogZWxlbWVudHMgZnJvbSB0aGUgcmVzdWx0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBleGNsdWRlLlxuICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gSW50ZXJuYWxseSB1c2VkIHRvIGFsbG93IHRoaXMgbWV0aG9kIHRvIHdvcmsgd2l0aFxuICAgKiAgb3RoZXJzIGxpa2UgYF8ubWFwYCB3aXRob3V0IHVzaW5nIHRoZWlyIGNhbGxiYWNrIGBpbmRleGAgYXJndW1lbnQgZm9yIGBuYC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFsbCBidXQgdGhlIGxhc3QgZWxlbWVudCBvciBgbmAgZWxlbWVudHMgb2YgYGFycmF5YC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pbml0aWFsKFszLCAyLCAxXSk7XG4gICAqIC8vID0+IFszLCAyXVxuICAgKi9cbiAgZnVuY3Rpb24gaW5pdGlhbChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICByZXR1cm4gYXJyYXlcbiAgICAgID8gc2xpY2UuY2FsbChhcnJheSwgMCwgLSgobiA9PSBudWxsIHx8IGd1YXJkKSA/IDEgOiBuKSlcbiAgICAgIDogW107XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIGludGVyc2VjdGlvbiBvZiBhbGwgdGhlIHBhc3NlZC1pbiBhcnJheXMgdXNpbmcgc3RyaWN0IGVxdWFsaXR5XG4gICAqIGZvciBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheTEsIGFycmF5MiwgLi4uXSBBcnJheXMgdG8gcHJvY2Vzcy5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIHVuaXF1ZSBlbGVtZW50cywgaW4gb3JkZXIsIHRoYXQgYXJlXG4gICAqICBwcmVzZW50IGluICoqYWxsKiogb2YgdGhlIGFycmF5cy5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pbnRlcnNlY3Rpb24oWzEsIDIsIDNdLCBbMTAxLCAyLCAxLCAxMF0sIFsyLCAxXSk7XG4gICAqIC8vID0+IFsxLCAyXVxuICAgKi9cbiAgZnVuY3Rpb24gaW50ZXJzZWN0aW9uKGFycmF5KSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aCxcbiAgICAgICAgY2FjaGUgPSB7fSxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICBmb3JFYWNoKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKGluZGV4T2YocmVzdWx0LCB2YWx1ZSkgPCAwKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcmdzTGVuZ3RoO1xuICAgICAgICB3aGlsZSAoLS1sZW5ndGgpIHtcbiAgICAgICAgICBpZiAoIShjYWNoZVtsZW5ndGhdIHx8IChjYWNoZVtsZW5ndGhdID0gY2FjaGVkQ29udGFpbnMoYXJnc1tsZW5ndGhdKSkpKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIGBhcnJheWAuIFBhc3MgYG5gIHRvIHJldHVybiB0aGUgbGFzdCBgbmBcbiAgICogZWxlbWVudHMgb2YgdGhlIGBhcnJheWAuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbbl0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byByZXR1cm4uXG4gICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBJbnRlcm5hbGx5IHVzZWQgdG8gYWxsb3cgdGhpcyBtZXRob2QgdG8gd29yayB3aXRoXG4gICAqICBvdGhlcnMgbGlrZSBgXy5tYXBgIHdpdGhvdXQgdXNpbmcgdGhlaXIgY2FsbGJhY2sgYGluZGV4YCBhcmd1bWVudCBmb3IgYG5gLlxuICAgKiBAcmV0dXJucyB7TWl4ZWR9IFJldHVybnMgdGhlIGxhc3QgZWxlbWVudCBvciBhbiBhcnJheSBvZiB0aGUgbGFzdCBgbmBcbiAgICogIGVsZW1lbnRzIG9mIGBhcnJheWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8ubGFzdChbMywgMiwgMV0pO1xuICAgKiAvLyA9PiAxXG4gICAqL1xuICBmdW5jdGlvbiBsYXN0KGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiAobiA9PSBudWxsIHx8IGd1YXJkKSA/IGFycmF5W2xlbmd0aCAtIDFdIDogc2xpY2UuY2FsbChhcnJheSwgLW4gfHwgbGVuZ3RoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGxhc3Qgb2NjdXJyZW5jZSBvZiBgdmFsdWVgIGlzIGZvdW5kIHVzaW5nIHN0cmljdFxuICAgKiBlcXVhbGl0eSBmb3IgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuIElmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBpdCBpcyB1c2VkXG4gICAqIGFzIHRoZSBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZnJvbUluZGV4PWFycmF5Lmxlbmd0aC0xXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlIG9yIGAtMWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8ubGFzdEluZGV4T2YoWzEsIDIsIDMsIDEsIDIsIDNdLCAyKTtcbiAgICogLy8gPT4gNFxuICAgKlxuICAgKiBfLmxhc3RJbmRleE9mKFsxLCAyLCAzLCAxLCAyLCAzXSwgMiwgMyk7XG4gICAqIC8vID0+IDFcbiAgICovXG4gIGZ1bmN0aW9uIGxhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgdmFyIGluZGV4ID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgIGlmICh0eXBlb2YgZnJvbUluZGV4ID09ICdudW1iZXInKSB7XG4gICAgICBpbmRleCA9IChmcm9tSW5kZXggPCAwID8gbmF0aXZlTWF4KDAsIGluZGV4ICsgZnJvbUluZGV4KSA6IG5hdGl2ZU1pbihmcm9tSW5kZXgsIGluZGV4IC0gMSkpICsgMTtcbiAgICB9XG4gICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIGZyb20gYXJyYXlzIG9mIGBrZXlzYCBhbmQgYHZhbHVlc2AuIFBhc3MgZWl0aGVyXG4gICAqIGEgc2luZ2xlIHR3byBkaW1lbnNpb25hbCBhcnJheSwgaS5lLiBgW1trZXkxLCB2YWx1ZTFdLCBba2V5MiwgdmFsdWUyXV1gLCBvclxuICAgKiB0d28gYXJyYXlzLCBvbmUgb2YgYGtleXNgIGFuZCBvbmUgb2YgY29ycmVzcG9uZGluZyBgdmFsdWVzYC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAqIEBwYXJhbSB7QXJyYXl9IGtleXMgVGhlIGFycmF5IG9mIGtleXMuXG4gICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXM9W11dIFRoZSBhcnJheSBvZiB2YWx1ZXMuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBnaXZlbiBrZXlzIGFuZFxuICAgKiAgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8ub2JqZWN0KFsnbW9lJywgJ2xhcnJ5JywgJ2N1cmx5J10sIFszMCwgNDAsIDUwXSk7XG4gICAqIC8vID0+IHsgJ21vZSc6IDMwLCAnbGFycnknOiA0MCwgJ2N1cmx5JzogNTAgfVxuICAgKi9cbiAgZnVuY3Rpb24gb2JqZWN0KGtleXMsIHZhbHVlcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBrZXlzID8ga2V5cy5sZW5ndGggOiAwLFxuICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpbmRleF07XG4gICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWVzW2luZGV4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtrZXlbMF1dID0ga2V5WzFdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgbnVtYmVycyAocG9zaXRpdmUgYW5kL29yIG5lZ2F0aXZlKSBwcm9ncmVzc2luZyBmcm9tXG4gICAqIGBzdGFydGAgdXAgdG8gYnV0IG5vdCBpbmNsdWRpbmcgYHN0b3BgLiBUaGlzIG1ldGhvZCBpcyBhIHBvcnQgb2YgUHl0aG9uJ3NcbiAgICogYHJhbmdlKClgIGZ1bmN0aW9uLiBTZWUgaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L2Z1bmN0aW9ucy5odG1sI3JhbmdlLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3N0ZXA9MV0gVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZXNjcmVtZW50IGJ5LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgcmFuZ2UgYXJyYXkuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8ucmFuZ2UoMTApO1xuICAgKiAvLyA9PiBbMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOV1cbiAgICpcbiAgICogXy5yYW5nZSgxLCAxMSk7XG4gICAqIC8vID0+IFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMF1cbiAgICpcbiAgICogXy5yYW5nZSgwLCAzMCwgNSk7XG4gICAqIC8vID0+IFswLCA1LCAxMCwgMTUsIDIwLCAyNV1cbiAgICpcbiAgICogXy5yYW5nZSgwLCAtMTAsIC0xKTtcbiAgICogLy8gPT4gWzAsIC0xLCAtMiwgLTMsIC00LCAtNSwgLTYsIC03LCAtOCwgLTldXG4gICAqXG4gICAqIF8ucmFuZ2UoMCk7XG4gICAqIC8vID0+IFtdXG4gICAqL1xuICBmdW5jdGlvbiByYW5nZShzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgc3RhcnQgPSArc3RhcnQgfHwgMDtcbiAgICBzdGVwID0gK3N0ZXAgfHwgMTtcblxuICAgIGlmIChlbmQgPT0gbnVsbCkge1xuICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIC8vIHVzZSBgQXJyYXkobGVuZ3RoKWAgc28gVjggd2lsbCBhdm9pZCB0aGUgc2xvd2VyIFwiZGljdGlvbmFyeVwiIG1vZGVcbiAgICAvLyBodHRwOi8vd3d3LnlvdXR1YmUuY29tL3dhdGNoP3Y9WEFxSXBHVThaWmsjdD0xNm0yN3NcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KDAsIGNlaWwoKGVuZCAtIHN0YXJ0KSAvIHN0ZXApKSxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gc3RhcnQ7XG4gICAgICBzdGFydCArPSBzdGVwO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5pbml0aWFsYCwgdGhpcyBtZXRob2QgZ2V0cyBhbGwgYnV0IHRoZSBmaXJzdCB2YWx1ZSBvZlxuICAgKiBgYXJyYXlgLiBQYXNzIGBuYCB0byBleGNsdWRlIHRoZSBmaXJzdCBgbmAgdmFsdWVzIGZyb20gdGhlIHJlc3VsdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAYWxpYXMgZHJvcCwgdGFpbFxuICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gZXhjbHVkZS5cbiAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEludGVybmFsbHkgdXNlZCB0byBhbGxvdyB0aGlzIG1ldGhvZCB0byB3b3JrIHdpdGhcbiAgICogIG90aGVycyBsaWtlIGBfLm1hcGAgd2l0aG91dCB1c2luZyB0aGVpciBjYWxsYmFjayBgaW5kZXhgIGFyZ3VtZW50IGZvciBgbmAuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbGwgYnV0IHRoZSBmaXJzdCB2YWx1ZSBvciBgbmAgdmFsdWVzIG9mIGBhcnJheWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8ucmVzdChbMywgMiwgMV0pO1xuICAgKiAvLyA9PiBbMiwgMV1cbiAgICovXG4gIGZ1bmN0aW9uIHJlc3QoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIGFycmF5XG4gICAgICA/IHNsaWNlLmNhbGwoYXJyYXksIChuID09IG51bGwgfHwgZ3VhcmQpID8gMSA6IG4pXG4gICAgICA6IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZXMgYSBiaW5hcnkgc2VhcmNoIHRvIGRldGVybWluZSB0aGUgc21hbGxlc3QgaW5kZXggYXQgd2hpY2ggdGhlIGB2YWx1ZWBcbiAgICogc2hvdWxkIGJlIGluc2VydGVkIGludG8gYGFycmF5YCBpbiBvcmRlciB0byBtYWludGFpbiB0aGUgc29ydCBvcmRlciBvZiB0aGVcbiAgICogc29ydGVkIGBhcnJheWAuIElmIGBjYWxsYmFja2AgaXMgcGFzc2VkLCBpdCB3aWxsIGJlIGV4ZWN1dGVkIGZvciBgdmFsdWVgIGFuZFxuICAgKiBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBjb21wdXRlIHRoZWlyIHNvcnQgcmFua2luZy4gVGhlIGBjYWxsYmFja2AgaXNcbiAgICogYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLiBUaGUgYGNhbGxiYWNrYFxuICAgKiBhcmd1bWVudCBtYXkgYWxzbyBiZSB0aGUgbmFtZSBvZiBhIHByb3BlcnR5IHRvIG9yZGVyIGJ5LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5fHByb3BlcnR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAqICBwZXIgaXRlcmF0aW9uIG9yIHByb3BlcnR5IG5hbWUgdG8gb3JkZXIgYnkuXG4gICAqIEBwYXJhbSB7TWl4ZWR9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIHZhbHVlIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgKiAgaW50byBgYXJyYXlgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLnNvcnRlZEluZGV4KFsyMCwgMzAsIDUwXSwgNDApO1xuICAgKiAvLyA9PiAyXG4gICAqXG4gICAqIF8uc29ydGVkSW5kZXgoW3sgJ3gnOiAyMCB9LCB7ICd4JzogMzAgfSwgeyAneCc6IDUwIH1dLCB7ICd4JzogNDAgfSwgJ3gnKTtcbiAgICogLy8gPT4gMlxuICAgKlxuICAgKiB2YXIgZGljdCA9IHtcbiAgICogICAnd29yZFRvTnVtYmVyJzogeyAndHdlbnR5JzogMjAsICd0aGlydHknOiAzMCwgJ2ZvdXJ0eSc6IDQwLCAnZmlmdHknOiA1MCB9XG4gICAqIH07XG4gICAqXG4gICAqIF8uc29ydGVkSW5kZXgoWyd0d2VudHknLCAndGhpcnR5JywgJ2ZpZnR5J10sICdmb3VydHknLCBmdW5jdGlvbih3b3JkKSB7XG4gICAqICAgcmV0dXJuIGRpY3Qud29yZFRvTnVtYmVyW3dvcmRdO1xuICAgKiB9KTtcbiAgICogLy8gPT4gMlxuICAgKlxuICAgKiBfLnNvcnRlZEluZGV4KFsndHdlbnR5JywgJ3RoaXJ0eScsICdmaWZ0eSddLCAnZm91cnR5JywgZnVuY3Rpb24od29yZCkge1xuICAgKiAgIHJldHVybiB0aGlzLndvcmRUb051bWJlclt3b3JkXTtcbiAgICogfSwgZGljdCk7XG4gICAqIC8vID0+IDJcbiAgICovXG4gIGZ1bmN0aW9uIHNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICB2YXIgbG93ID0gMCxcbiAgICAgICAgaGlnaCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogbG93O1xuXG4gICAgLy8gZXhwbGljaXRseSByZWZlcmVuY2UgYGlkZW50aXR5YCBmb3IgYmV0dGVyIGVuZ2luZSBpbmxpbmluZ1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZykgOiBpZGVudGl0eTtcbiAgICB2YWx1ZSA9IGNhbGxiYWNrKHZhbHVlKTtcbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgdmFyIG1pZCA9IChsb3cgKyBoaWdoKSA+Pj4gMTtcbiAgICAgIGNhbGxiYWNrKGFycmF5W21pZF0pIDwgdmFsdWVcbiAgICAgICAgPyBsb3cgPSBtaWQgKyAxXG4gICAgICAgIDogaGlnaCA9IG1pZDtcbiAgICB9XG4gICAgcmV0dXJuIGxvdztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgdW5pb24gb2YgdGhlIHBhc3NlZC1pbiBhcnJheXMgdXNpbmcgc3RyaWN0IGVxdWFsaXR5IGZvclxuICAgKiBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheTEsIGFycmF5MiwgLi4uXSBBcnJheXMgdG8gcHJvY2Vzcy5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMsIGluIG9yZGVyLCB0aGF0IGFyZVxuICAgKiAgcHJlc2VudCBpbiBvbmUgb3IgbW9yZSBvZiB0aGUgYXJyYXlzLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLnVuaW9uKFsxLCAyLCAzXSwgWzEwMSwgMiwgMSwgMTBdLCBbMiwgMV0pO1xuICAgKiAvLyA9PiBbMSwgMiwgMywgMTAxLCAxMF1cbiAgICovXG4gIGZ1bmN0aW9uIHVuaW9uKCkge1xuICAgIHJldHVybiB1bmlxKGNvbmNhdC5hcHBseShhcnJheVJlZiwgYXJndW1lbnRzKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGR1cGxpY2F0ZS12YWx1ZS1mcmVlIHZlcnNpb24gb2YgdGhlIGBhcnJheWAgdXNpbmcgc3RyaWN0IGVxdWFsaXR5XG4gICAqIGZvciBjb21wYXJpc29ucywgaS5lLiBgPT09YC4gSWYgdGhlIGBhcnJheWAgaXMgYWxyZWFkeSBzb3J0ZWQsIHBhc3NpbmcgYHRydWVgXG4gICAqIGZvciBgaXNTb3J0ZWRgIHdpbGwgcnVuIGEgZmFzdGVyIGFsZ29yaXRobS4gSWYgYGNhbGxiYWNrYCBpcyBwYXNzZWQsIGVhY2hcbiAgICogZWxlbWVudCBvZiBgYXJyYXlgIGlzIHBhc3NlZCB0aHJvdWdoIGEgY2FsbGJhY2tgIGJlZm9yZSB1bmlxdWVuZXNzIGlzIGNvbXB1dGVkLlxuICAgKiBUaGUgYGNhbGxiYWNrYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAYWxpYXMgdW5pcXVlXG4gICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHByb2Nlc3MuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzU29ydGVkPWZhbHNlXSBBIGZsYWcgdG8gaW5kaWNhdGUgdGhhdCB0aGUgYGFycmF5YCBpcyBhbHJlYWR5IHNvcnRlZC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7TWl4ZWR9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgZHVwbGljYXRlLXZhbHVlLWZyZWUgYXJyYXkuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8udW5pcShbMSwgMiwgMSwgMywgMV0pO1xuICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICpcbiAgICogXy51bmlxKFsxLCAxLCAyLCAyLCAzXSwgdHJ1ZSk7XG4gICAqIC8vID0+IFsxLCAyLCAzXVxuICAgKlxuICAgKiBfLnVuaXEoWzEsIDIsIDEuNSwgMywgMi41XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBNYXRoLmZsb29yKG51bSk7IH0pO1xuICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICpcbiAgICogXy51bmlxKFsxLCAyLCAxLjUsIDMsIDIuNV0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gdGhpcy5mbG9vcihudW0pOyB9LCBNYXRoKTtcbiAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAqL1xuICBmdW5jdGlvbiB1bmlxKGFycmF5LCBpc1NvcnRlZCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgc2VlbiA9IHJlc3VsdDtcblxuICAgIC8vIGp1Z2dsZSBhcmd1bWVudHNcbiAgICBpZiAodHlwZW9mIGlzU29ydGVkID09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNBcmcgPSBjYWxsYmFjaztcbiAgICAgIGNhbGxiYWNrID0gaXNTb3J0ZWQ7XG4gICAgICBpc1NvcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBpbml0IHZhbHVlIGNhY2hlIGZvciBsYXJnZSBhcnJheXNcbiAgICB2YXIgaXNMYXJnZSA9ICFpc1NvcnRlZCAmJiBsZW5ndGggPiA3NDtcbiAgICBpZiAoaXNMYXJnZSkge1xuICAgICAgdmFyIGNhY2hlID0ge307XG4gICAgfVxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgc2VlbiA9IFtdO1xuICAgICAgY2FsbGJhY2sgPSBjcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZyk7XG4gICAgfVxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgY29tcHV0ZWQgPSBjYWxsYmFjayA/IGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgYXJyYXkpIDogdmFsdWU7XG5cbiAgICAgIGlmIChpc0xhcmdlKSB7XG4gICAgICAgIC8vIG1hbnVhbGx5IGNvZXJjZSBgY29tcHV0ZWRgIHRvIGEgc3RyaW5nIGJlY2F1c2UgYGhhc093blByb3BlcnR5YCwgaW5cbiAgICAgICAgLy8gc29tZSBvbGRlciB2ZXJzaW9ucyBvZiBGaXJlZm94LCBjb2VyY2VzIG9iamVjdHMgaW5jb3JyZWN0bHlcbiAgICAgICAgc2VlbiA9IGhhc093blByb3BlcnR5LmNhbGwoY2FjaGUsIGNvbXB1dGVkICsgJycpID8gY2FjaGVbY29tcHV0ZWRdIDogKGNhY2hlW2NvbXB1dGVkXSA9IFtdKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1NvcnRlZFxuICAgICAgICAgICAgPyAhaW5kZXggfHwgc2VlbltzZWVuLmxlbmd0aCAtIDFdICE9PSBjb21wdXRlZFxuICAgICAgICAgICAgOiBpbmRleE9mKHNlZW4sIGNvbXB1dGVkKSA8IDBcbiAgICAgICAgICApIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrIHx8IGlzTGFyZ2UpIHtcbiAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGFycmF5IHdpdGggYWxsIG9jY3VycmVuY2VzIG9mIHRoZSBwYXNzZWQgdmFsdWVzIHJlbW92ZWQgdXNpbmdcbiAgICogc3RyaWN0IGVxdWFsaXR5IGZvciBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmaWx0ZXIuXG4gICAqIEBwYXJhbSB7TWl4ZWR9IFt2YWx1ZTEsIHZhbHVlMiwgLi4uXSBWYWx1ZXMgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8ud2l0aG91dChbMSwgMiwgMSwgMCwgMywgMSwgNF0sIDAsIDEpO1xuICAgKiAvLyA9PiBbMiwgMywgNF1cbiAgICovXG4gIGZ1bmN0aW9uIHdpdGhvdXQoYXJyYXkpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICBjb250YWlucyA9IGNhY2hlZENvbnRhaW5zKGFyZ3VtZW50cywgMSwgMjApLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICBpZiAoIWNvbnRhaW5zKHZhbHVlKSkge1xuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogR3JvdXBzIHRoZSBlbGVtZW50cyBvZiBlYWNoIGFycmF5IGF0IHRoZWlyIGNvcnJlc3BvbmRpbmcgaW5kZXhlcy4gVXNlZnVsIGZvclxuICAgKiBzZXBhcmF0ZSBkYXRhIHNvdXJjZXMgdGhhdCBhcmUgY29vcmRpbmF0ZWQgdGhyb3VnaCBtYXRjaGluZyBhcnJheSBpbmRleGVzLlxuICAgKiBGb3IgYSBtYXRyaXggb2YgbmVzdGVkIGFycmF5cywgYF8uemlwLmFwcGx5KC4uLilgIGNhbiB0cmFuc3Bvc2UgdGhlIG1hdHJpeFxuICAgKiBpbiBhIHNpbWlsYXIgZmFzaGlvbi5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheTEsIGFycmF5MiwgLi4uXSBBcnJheXMgdG8gcHJvY2Vzcy5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uemlwKFsnbW9lJywgJ2xhcnJ5JywgJ2N1cmx5J10sIFszMCwgNDAsIDUwXSwgW3RydWUsIGZhbHNlLCBmYWxzZV0pO1xuICAgKiAvLyA9PiBbWydtb2UnLCAzMCwgdHJ1ZV0sIFsnbGFycnknLCA0MCwgZmFsc2VdLCBbJ2N1cmx5JywgNTAsIGZhbHNlXV1cbiAgICovXG4gIGZ1bmN0aW9uIHppcChhcnJheSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA/IG1heChwbHVjayhhcmd1bWVudHMsICdsZW5ndGgnKSkgOiAwLFxuICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBwbHVjayhhcmd1bWVudHMsIGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpcyByZXN0cmljdGVkIHRvIGV4ZWN1dGluZyBgZnVuY2Agb25seSBhZnRlciBpdCBpc1xuICAgKiBjYWxsZWQgYG5gIHRpbWVzLiBUaGUgYGZ1bmNgIGlzIGV4ZWN1dGVkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZVxuICAgKiBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0aGUgZnVuY3Rpb24gbXVzdCBiZSBjYWxsZWQgYmVmb3JlXG4gICAqIGl0IGlzIGV4ZWN1dGVkLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIHJlbmRlck5vdGVzID0gXy5hZnRlcihub3Rlcy5sZW5ndGgsIHJlbmRlcik7XG4gICAqIF8uZm9yRWFjaChub3RlcywgZnVuY3Rpb24obm90ZSkge1xuICAgKiAgIG5vdGUuYXN5bmNTYXZlKHsgJ3N1Y2Nlc3MnOiByZW5kZXJOb3RlcyB9KTtcbiAgICogfSk7XG4gICAqIC8vIGByZW5kZXJOb3Rlc2AgaXMgcnVuIG9uY2UsIGFmdGVyIGFsbCBub3RlcyBoYXZlIHNhdmVkXG4gICAqL1xuICBmdW5jdGlvbiBhZnRlcihuLCBmdW5jKSB7XG4gICAgaWYgKG4gPCAxKSB7XG4gICAgICByZXR1cm4gZnVuYygpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS1uIDwgMSkge1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2BcbiAgICogYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHByZXBlbmRzIGFueSBhZGRpdGlvbmFsIGBiaW5kYCBhcmd1bWVudHMgdG8gdGhvc2VcbiAgICogcGFzc2VkIHRvIHRoZSBib3VuZCBmdW5jdGlvbi5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gICAqIEBwYXJhbSB7TWl4ZWR9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgKiBAcGFyYW0ge01peGVkfSBbYXJnMSwgYXJnMiwgLi4uXSBBcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgZnVuYyA9IGZ1bmN0aW9uKGdyZWV0aW5nKSB7XG4gICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgdGhpcy5uYW1lO1xuICAgKiB9O1xuICAgKlxuICAgKiBmdW5jID0gXy5iaW5kKGZ1bmMsIHsgJ25hbWUnOiAnbW9lJyB9LCAnaGknKTtcbiAgICogZnVuYygpO1xuICAgKiAvLyA9PiAnaGkgbW9lJ1xuICAgKi9cbiAgZnVuY3Rpb24gYmluZChmdW5jLCB0aGlzQXJnKSB7XG4gICAgLy8gdXNlIGBGdW5jdGlvbiNiaW5kYCBpZiBpdCBleGlzdHMgYW5kIGlzIGZhc3RcbiAgICAvLyAoaW4gVjggYEZ1bmN0aW9uI2JpbmRgIGlzIHNsb3dlciBleGNlcHQgd2hlbiBwYXJ0aWFsbHkgYXBwbGllZClcbiAgICByZXR1cm4gaXNCaW5kRmFzdCB8fCAobmF0aXZlQmluZCAmJiBhcmd1bWVudHMubGVuZ3RoID4gMilcbiAgICAgID8gbmF0aXZlQmluZC5jYWxsLmFwcGx5KG5hdGl2ZUJpbmQsIGFyZ3VtZW50cylcbiAgICAgIDogY3JlYXRlQm91bmQoZnVuYywgdGhpc0FyZywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kcyBtZXRob2RzIG9uIGBvYmplY3RgIHRvIGBvYmplY3RgLCBvdmVyd3JpdGluZyB0aGUgZXhpc3RpbmcgbWV0aG9kLlxuICAgKiBJZiBubyBtZXRob2QgbmFtZXMgYXJlIHByb3ZpZGVkLCBhbGwgdGhlIGZ1bmN0aW9uIHByb3BlcnRpZXMgb2YgYG9iamVjdGBcbiAgICogd2lsbCBiZSBib3VuZC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiaW5kIGFuZCBhc3NpZ24gdGhlIGJvdW5kIG1ldGhvZHMgdG8uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbbWV0aG9kTmFtZTEsIG1ldGhvZE5hbWUyLCAuLi5dIE1ldGhvZCBuYW1lcyBvbiB0aGUgb2JqZWN0IHRvIGJpbmQuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBidXR0b25WaWV3ID0ge1xuICAgKiAgJ2xhYmVsJzogJ2xvZGFzaCcsXG4gICAqICAnb25DbGljayc6IGZ1bmN0aW9uKCkgeyBhbGVydCgnY2xpY2tlZDogJyArIHRoaXMubGFiZWwpOyB9XG4gICAqIH07XG4gICAqXG4gICAqIF8uYmluZEFsbChidXR0b25WaWV3KTtcbiAgICogalF1ZXJ5KCcjbG9kYXNoX2J1dHRvbicpLm9uKCdjbGljaycsIGJ1dHRvblZpZXcub25DbGljayk7XG4gICAqIC8vID0+IFdoZW4gdGhlIGJ1dHRvbiBpcyBjbGlja2VkLCBgdGhpcy5sYWJlbGAgd2lsbCBoYXZlIHRoZSBjb3JyZWN0IHZhbHVlXG4gICAqL1xuICBmdW5jdGlvbiBiaW5kQWxsKG9iamVjdCkge1xuICAgIHZhciBmdW5jcyA9IGFyZ3VtZW50cyxcbiAgICAgICAgaW5kZXggPSBmdW5jcy5sZW5ndGggPiAxID8gMCA6IChmdW5jcyA9IGZ1bmN0aW9ucyhvYmplY3QpLCAtMSksXG4gICAgICAgIGxlbmd0aCA9IGZ1bmNzLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIga2V5ID0gZnVuY3NbaW5kZXhdO1xuICAgICAgb2JqZWN0W2tleV0gPSBiaW5kKG9iamVjdFtrZXldLCBvYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiB0aGUgcGFzc2VkIGZ1bmN0aW9ucyxcbiAgICogd2hlcmUgZWFjaCBmdW5jdGlvbiBjb25zdW1lcyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiB0aGF0IGZvbGxvd3MuXG4gICAqIEluIG1hdGggdGVybXMsIGNvbXBvc2luZyB0aGUgZnVuY3Rpb25zIGBmKClgLCBgZygpYCwgYW5kIGBoKClgIHByb2R1Y2VzIGBmKGcoaCgpKSlgLlxuICAgKiBFYWNoIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjb21wb3NlZCBmdW5jdGlvbi5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtmdW5jMSwgZnVuYzIsIC4uLl0gRnVuY3Rpb25zIHRvIGNvbXBvc2UuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvc2VkIGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgZ3JlZXQgPSBmdW5jdGlvbihuYW1lKSB7IHJldHVybiAnaGk6ICcgKyBuYW1lOyB9O1xuICAgKiB2YXIgZXhjbGFpbSA9IGZ1bmN0aW9uKHN0YXRlbWVudCkgeyByZXR1cm4gc3RhdGVtZW50ICsgJyEnOyB9O1xuICAgKiB2YXIgd2VsY29tZSA9IF8uY29tcG9zZShleGNsYWltLCBncmVldCk7XG4gICAqIHdlbGNvbWUoJ21vZScpO1xuICAgKiAvLyA9PiAnaGk6IG1vZSEnXG4gICAqL1xuICBmdW5jdGlvbiBjb21wb3NlKCkge1xuICAgIHZhciBmdW5jcyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBsZW5ndGggPSBmdW5jcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBhcmdzID0gW2Z1bmNzW2xlbmd0aF0uYXBwbHkodGhpcywgYXJncyldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGRlbGF5IHRoZSBleGVjdXRpb24gb2YgYGZ1bmNgIHVudGlsIGFmdGVyXG4gICAqIGB3YWl0YCBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgaXQgd2FzIGludm9rZWQuIFBhc3NcbiAgICogYHRydWVgIGZvciBgaW1tZWRpYXRlYCB0byBjYXVzZSBkZWJvdW5jZSB0byBpbnZva2UgYGZ1bmNgIG9uIHRoZSBsZWFkaW5nLFxuICAgKiBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZywgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFN1YnNlcXVlbnQgY2FsbHMgdG9cbiAgICogdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBjYWxsLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGltbWVkaWF0ZSBBIGZsYWcgdG8gaW5kaWNhdGUgZXhlY3V0aW9uIGlzIG9uIHRoZSBsZWFkaW5nXG4gICAqICBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBsYXp5TGF5b3V0ID0gXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDMwMCk7XG4gICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBsYXp5TGF5b3V0KTtcbiAgICovXG4gIGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAgIHZhciBhcmdzLFxuICAgICAgICByZXN1bHQsXG4gICAgICAgIHRoaXNBcmcsXG4gICAgICAgIHRpbWVvdXRJZDtcblxuICAgIGZ1bmN0aW9uIGRlbGF5ZWQoKSB7XG4gICAgICB0aW1lb3V0SWQgPSBudWxsO1xuICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGlzSW1tZWRpYXRlID0gaW1tZWRpYXRlICYmICF0aW1lb3V0SWQ7XG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdGhpc0FyZyA9IHRoaXM7XG5cbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChkZWxheWVkLCB3YWl0KTtcblxuICAgICAgaWYgKGlzSW1tZWRpYXRlKSB7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZXMgdGhlIGBmdW5jYCBmdW5jdGlvbiBhZnRlciBgd2FpdGAgbWlsbGlzZWNvbmRzLiBBZGRpdGlvbmFsIGFyZ3VtZW50c1xuICAgKiB3aWxsIGJlIHBhc3NlZCB0byBgZnVuY2Agd2hlbiBpdCBpcyBpbnZva2VkLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGV4ZWN1dGlvbi5cbiAgICogQHBhcmFtIHtNaXhlZH0gW2FyZzEsIGFyZzIsIC4uLl0gQXJndW1lbnRzIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aC5cbiAgICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyB0aGUgYHNldFRpbWVvdXRgIHRpbWVvdXQgaWQuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBsb2cgPSBfLmJpbmQoY29uc29sZS5sb2csIGNvbnNvbGUpO1xuICAgKiBfLmRlbGF5KGxvZywgMTAwMCwgJ2xvZ2dlZCBsYXRlcicpO1xuICAgKiAvLyA9PiAnbG9nZ2VkIGxhdGVyJyAoQXBwZWFycyBhZnRlciBvbmUgc2Vjb25kLilcbiAgICovXG4gIGZ1bmN0aW9uIGRlbGF5KGZ1bmMsIHdhaXQpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHsgZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3MpOyB9LCB3YWl0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZlcnMgZXhlY3V0aW5nIHRoZSBgZnVuY2AgZnVuY3Rpb24gdW50aWwgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXMgY2xlYXJlZC5cbiAgICogQWRkaXRpb25hbCBhcmd1bWVudHMgd2lsbCBiZSBwYXNzZWQgdG8gYGZ1bmNgIHdoZW4gaXQgaXMgaW52b2tlZC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlZmVyLlxuICAgKiBAcGFyYW0ge01peGVkfSBbYXJnMSwgYXJnMiwgLi4uXSBBcmd1bWVudHMgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoLlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIHRoZSBgc2V0VGltZW91dGAgdGltZW91dCBpZC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5kZWZlcihmdW5jdGlvbigpIHsgYWxlcnQoJ2RlZmVycmVkJyk7IH0pO1xuICAgKiAvLyByZXR1cm5zIGZyb20gdGhlIGZ1bmN0aW9uIGJlZm9yZSBgYWxlcnRgIGlzIGNhbGxlZFxuICAgKi9cbiAgZnVuY3Rpb24gZGVmZXIoZnVuYykge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7IH0sIDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCwgaW52b2tlcyBgb2JqZWN0W21ldGhvZE5hbWVdYCBhbmRcbiAgICogcHJlcGVuZHMgYW55IGFkZGl0aW9uYWwgYGxhdGVCaW5kYCBhcmd1bWVudHMgdG8gdGhvc2UgcGFzc2VkIHRvIHRoZSBib3VuZFxuICAgKiBmdW5jdGlvbi4gVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIGBfLmJpbmRgIGJ5IGFsbG93aW5nIGJvdW5kIGZ1bmN0aW9ucyB0b1xuICAgKiByZWZlcmVuY2UgbWV0aG9kcyB0aGF0IHdpbGwgYmUgcmVkZWZpbmVkIG9yIGRvbid0IHlldCBleGlzdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0aGUgbWV0aG9kIGJlbG9uZ3MgdG8uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2ROYW1lIFRoZSBtZXRob2QgbmFtZS5cbiAgICogQHBhcmFtIHtNaXhlZH0gW2FyZzEsIGFyZzIsIC4uLl0gQXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIG9iamVjdCA9IHtcbiAgICogICAnbmFtZSc6ICdtb2UnLFxuICAgKiAgICdncmVldCc6IGZ1bmN0aW9uKGdyZWV0aW5nKSB7XG4gICAqICAgICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLm5hbWU7XG4gICAqICAgfVxuICAgKiB9O1xuICAgKlxuICAgKiB2YXIgZnVuYyA9IF8ubGF0ZUJpbmQob2JqZWN0LCAnZ3JlZXQnLCAnaGknKTtcbiAgICogZnVuYygpO1xuICAgKiAvLyA9PiAnaGkgbW9lJ1xuICAgKlxuICAgKiBvYmplY3QuZ3JlZXQgPSBmdW5jdGlvbihncmVldGluZykge1xuICAgKiAgIHJldHVybiBncmVldGluZyArICcsICcgKyB0aGlzLm5hbWUgKyAnISc7XG4gICAqIH07XG4gICAqXG4gICAqIGZ1bmMoKTtcbiAgICogLy8gPT4gJ2hpLCBtb2UhJ1xuICAgKi9cbiAgZnVuY3Rpb24gbGF0ZUJpbmQob2JqZWN0LCBtZXRob2ROYW1lKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJvdW5kKG1ldGhvZE5hbWUsIG9iamVjdCwgc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICAgKiBwYXNzZWQsIGl0IHdpbGwgYmUgdXNlZCB0byBkZXRlcm1pbmUgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0XG4gICAqIGJhc2VkIG9uIHRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0XG4gICAqIGFyZ3VtZW50IHBhc3NlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gICAqIGlzIGV4ZWN1dGVkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBBIGZ1bmN0aW9uIHVzZWQgdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXppbmcgZnVuY3Rpb24uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBmaWJvbmFjY2kgPSBfLm1lbW9pemUoZnVuY3Rpb24obikge1xuICAgKiAgIHJldHVybiBuIDwgMiA/IG4gOiBmaWJvbmFjY2kobiAtIDEpICsgZmlib25hY2NpKG4gLSAyKTtcbiAgICogfSk7XG4gICAqL1xuICBmdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gICAgdmFyIGNhY2hlID0ge307XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGNhY2hlLCBrZXkpXG4gICAgICAgID8gY2FjaGVba2V5XVxuICAgICAgICA6IChjYWNoZVtrZXldID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGlzIHJlc3RyaWN0ZWQgdG8gZXhlY3V0ZSBgZnVuY2Agb25jZS4gUmVwZWF0IGNhbGxzIHRvXG4gICAqIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGNhbGwuIFRoZSBgZnVuY2AgaXMgZXhlY3V0ZWRcbiAgICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIGluaXRpYWxpemUgPSBfLm9uY2UoY3JlYXRlQXBwbGljYXRpb24pO1xuICAgKiBpbml0aWFsaXplKCk7XG4gICAqIGluaXRpYWxpemUoKTtcbiAgICogLy8gQXBwbGljYXRpb24gaXMgb25seSBjcmVhdGVkIG9uY2UuXG4gICAqL1xuICBmdW5jdGlvbiBvbmNlKGZ1bmMpIHtcbiAgICB2YXIgcmVzdWx0LFxuICAgICAgICByYW4gPSBmYWxzZTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChyYW4pIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJhbiA9IHRydWU7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgIC8vIGNsZWFyIHRoZSBgZnVuY2AgdmFyaWFibGUgc28gdGhlIGZ1bmN0aW9uIG1heSBiZSBnYXJiYWdlIGNvbGxlY3RlZFxuICAgICAgZnVuYyA9IG51bGw7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCBpbnZva2VzIGBmdW5jYCB3aXRoIGFueSBhZGRpdGlvbmFsXG4gICAqIGBwYXJ0aWFsYCBhcmd1bWVudHMgcHJlcGVuZGVkIHRvIHRob3NlIHBhc3NlZCB0byB0aGUgbmV3IGZ1bmN0aW9uLiBUaGlzXG4gICAqIG1ldGhvZCBpcyBzaW1pbGFyIHRvIGBiaW5kYCwgZXhjZXB0IGl0IGRvZXMgKipub3QqKiBhbHRlciB0aGUgYHRoaXNgIGJpbmRpbmcuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkgYXJndW1lbnRzIHRvLlxuICAgKiBAcGFyYW0ge01peGVkfSBbYXJnMSwgYXJnMiwgLi4uXSBBcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgZ3JlZXQgPSBmdW5jdGlvbihncmVldGluZywgbmFtZSkgeyByZXR1cm4gZ3JlZXRpbmcgKyAnOiAnICsgbmFtZTsgfTtcbiAgICogdmFyIGhpID0gXy5wYXJ0aWFsKGdyZWV0LCAnaGknKTtcbiAgICogaGkoJ21vZScpO1xuICAgKiAvLyA9PiAnaGk6IG1vZSdcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnRpYWwoZnVuYykge1xuICAgIHJldHVybiBjcmVhdGVCb3VuZChmdW5jLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGV4ZWN1dGVkLCB3aWxsIG9ubHkgY2FsbCB0aGUgYGZ1bmNgXG4gICAqIGZ1bmN0aW9uIGF0IG1vc3Qgb25jZSBwZXIgZXZlcnkgYHdhaXRgIG1pbGxpc2Vjb25kcy4gSWYgdGhlIHRocm90dGxlZFxuICAgKiBmdW5jdGlvbiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQsIGBmdW5jYCB3aWxsXG4gICAqIGFsc28gYmUgY2FsbGVkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZVxuICAgKiB0aHJvdHRsZWQgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgY2FsbC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHRocm90dGxlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aHJvdHRsZSBleGVjdXRpb25zIHRvLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB0aHJvdHRsZWQgZnVuY3Rpb24uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciB0aHJvdHRsZWQgPSBfLnRocm90dGxlKHVwZGF0ZVBvc2l0aW9uLCAxMDApO1xuICAgKiBqUXVlcnkod2luZG93KS5vbignc2Nyb2xsJywgdGhyb3R0bGVkKTtcbiAgICovXG4gIGZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQpIHtcbiAgICB2YXIgYXJncyxcbiAgICAgICAgcmVzdWx0LFxuICAgICAgICB0aGlzQXJnLFxuICAgICAgICB0aW1lb3V0SWQsXG4gICAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gICAgZnVuY3Rpb24gdHJhaWxpbmdDYWxsKCkge1xuICAgICAgbGFzdENhbGxlZCA9IG5ldyBEYXRlO1xuICAgICAgdGltZW91dElkID0gbnVsbDtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBub3cgPSBuZXcgRGF0ZSxcbiAgICAgICAgICByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIGxhc3RDYWxsZWQpO1xuXG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdGhpc0FyZyA9IHRoaXM7XG5cbiAgICAgIGlmIChyZW1haW5pbmcgPD0gMCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgbGFzdENhbGxlZCA9IG5vdztcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCF0aW1lb3V0SWQpIHtcbiAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCh0cmFpbGluZ0NhbGwsIHJlbWFpbmluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcGFzc2VzIGB2YWx1ZWAgdG8gdGhlIGB3cmFwcGVyYCBmdW5jdGlvbiBhcyBpdHNcbiAgICogZmlyc3QgYXJndW1lbnQuIEFkZGl0aW9uYWwgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24gYXJlIGFwcGVuZGVkXG4gICAqIHRvIHRob3NlIHBhc3NlZCB0byB0aGUgYHdyYXBwZXJgIGZ1bmN0aW9uLiBUaGUgYHdyYXBwZXJgIGlzIGV4ZWN1dGVkIHdpdGhcbiAgICogdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHdyYXBwZXIgVGhlIHdyYXBwZXIgZnVuY3Rpb24uXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgaGVsbG8gPSBmdW5jdGlvbihuYW1lKSB7IHJldHVybiAnaGVsbG8gJyArIG5hbWU7IH07XG4gICAqIGhlbGxvID0gXy53cmFwKGhlbGxvLCBmdW5jdGlvbihmdW5jKSB7XG4gICAqICAgcmV0dXJuICdiZWZvcmUsICcgKyBmdW5jKCdtb2UnKSArICcsIGFmdGVyJztcbiAgICogfSk7XG4gICAqIGhlbGxvKCk7XG4gICAqIC8vID0+ICdiZWZvcmUsIGhlbGxvIG1vZSwgYWZ0ZXInXG4gICAqL1xuICBmdW5jdGlvbiB3cmFwKHZhbHVlLCB3cmFwcGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3MgPSBbdmFsdWVdO1xuICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIHdyYXBwZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfTtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgY2hhcmFjdGVycyBgJmAsIGA8YCwgYD5gLCBgXCJgLCBhbmQgYCdgIGluIGBzdHJpbmdgIHRvIHRoZWlyXG4gICAqIGNvcnJlc3BvbmRpbmcgSFRNTCBlbnRpdGllcy5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmVzY2FwZSgnTW9lLCBMYXJyeSAmIEN1cmx5Jyk7XG4gICAqIC8vID0+IFwiTW9lLCBMYXJyeSAmYW1wOyBDdXJseVwiXG4gICAqL1xuICBmdW5jdGlvbiBlc2NhcGUoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZyA9PSBudWxsID8gJycgOiAoc3RyaW5nICsgJycpLnJlcGxhY2UocmVVbmVzY2FwZWRIdG1sLCBlc2NhcGVIdG1sQ2hhcik7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBwYXNzZWQgdG8gaXQuXG4gICAqXG4gICAqIE5vdGU6IEl0IGlzIHVzZWQgdGhyb3VnaG91dCBMby1EYXNoIGFzIGEgZGVmYXVsdCBjYWxsYmFjay5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIEFueSB2YWx1ZS5cbiAgICogQHJldHVybnMge01peGVkfSBSZXR1cm5zIGB2YWx1ZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBtb2UgPSB7ICduYW1lJzogJ21vZScgfTtcbiAgICogbW9lID09PSBfLmlkZW50aXR5KG1vZSk7XG4gICAqIC8vID0+IHRydWVcbiAgICovXG4gIGZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgZnVuY3Rpb25zIHByb3BlcnRpZXMgb2YgYG9iamVjdGAgdG8gdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uIGFuZCBjaGFpbmFibGVcbiAgICogd3JhcHBlci5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCBvZiBmdW5jdGlvbiBwcm9wZXJ0aWVzIHRvIGFkZCB0byBgbG9kYXNoYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5taXhpbih7XG4gICAqICAgJ2NhcGl0YWxpemUnOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICogICAgIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSkudG9Mb3dlckNhc2UoKTtcbiAgICogICB9XG4gICAqIH0pO1xuICAgKlxuICAgKiBfLmNhcGl0YWxpemUoJ2xhcnJ5Jyk7XG4gICAqIC8vID0+ICdMYXJyeSdcbiAgICpcbiAgICogXygnY3VybHknKS5jYXBpdGFsaXplKCk7XG4gICAqIC8vID0+ICdDdXJseSdcbiAgICovXG4gIGZ1bmN0aW9uIG1peGluKG9iamVjdCkge1xuICAgIGZvckVhY2goZnVuY3Rpb25zKG9iamVjdCksIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gbG9kYXNoW21ldGhvZE5hbWVdID0gb2JqZWN0W21ldGhvZE5hbWVdO1xuXG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gW3RoaXMuX193cmFwcGVkX19dO1xuICAgICAgICBwdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkobG9kYXNoLCBhcmdzKTtcbiAgICAgICAgaWYgKHRoaXMuX19jaGFpbl9fKSB7XG4gICAgICAgICAgcmVzdWx0ID0gbmV3IGxvZGFzaChyZXN1bHQpO1xuICAgICAgICAgIHJlc3VsdC5fX2NoYWluX18gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldmVydHMgdGhlICdfJyB2YXJpYWJsZSB0byBpdHMgcHJldmlvdXMgdmFsdWUgYW5kIHJldHVybnMgYSByZWZlcmVuY2UgdG9cbiAgICogdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIGxvZGFzaCA9IF8ubm9Db25mbGljdCgpO1xuICAgKi9cbiAgZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcbiAgICB3aW5kb3cuXyA9IG9sZERhc2g7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUHJvZHVjZXMgYSByYW5kb20gbnVtYmVyIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgIChpbmNsdXNpdmUpLiBJZiBvbmx5IG9uZVxuICAgKiBhcmd1bWVudCBpcyBwYXNzZWQsIGEgbnVtYmVyIGJldHdlZW4gYDBgIGFuZCB0aGUgZ2l2ZW4gbnVtYmVyIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgKiBAcGFyYW0ge051bWJlcn0gW21pbj0wXSBUaGUgbWluaW11bSBwb3NzaWJsZSB2YWx1ZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFttYXg9MV0gVGhlIG1heGltdW0gcG9zc2libGUgdmFsdWUuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgYSByYW5kb20gbnVtYmVyLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLnJhbmRvbSgwLCA1KTtcbiAgICogLy8gPT4gYSBudW1iZXIgYmV0d2VlbiAxIGFuZCA1XG4gICAqXG4gICAqIF8ucmFuZG9tKDUpO1xuICAgKiAvLyA9PiBhbHNvIGEgbnVtYmVyIGJldHdlZW4gMSBhbmQgNVxuICAgKi9cbiAgZnVuY3Rpb24gcmFuZG9tKG1pbiwgbWF4KSB7XG4gICAgaWYgKG1pbiA9PSBudWxsICYmIG1heCA9PSBudWxsKSB7XG4gICAgICBtYXggPSAxO1xuICAgIH1cbiAgICBtaW4gPSArbWluIHx8IDA7XG4gICAgaWYgKG1heCA9PSBudWxsKSB7XG4gICAgICBtYXggPSBtaW47XG4gICAgICBtaW4gPSAwO1xuICAgIH1cbiAgICByZXR1cm4gbWluICsgZmxvb3IobmF0aXZlUmFuZG9tKCkgKiAoKCttYXggfHwgMCkgLSBtaW4gKyAxKSk7XG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZXMgdGhlIHZhbHVlIG9mIGBwcm9wZXJ0eWAgb24gYG9iamVjdGAuIElmIGBwcm9wZXJ0eWAgaXMgYSBmdW5jdGlvblxuICAgKiBpdCB3aWxsIGJlIGludm9rZWQgYW5kIGl0cyByZXN1bHQgcmV0dXJuZWQsIGVsc2UgdGhlIHByb3BlcnR5IHZhbHVlIGlzXG4gICAqIHJldHVybmVkLiBJZiBgb2JqZWN0YCBpcyBmYWxzZXksIHRoZW4gYG51bGxgIGlzIHJldHVybmVkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBUaGUgcHJvcGVydHkgdG8gZ2V0IHRoZSB2YWx1ZSBvZi5cbiAgICogQHJldHVybnMge01peGVkfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIG9iamVjdCA9IHtcbiAgICogICAnY2hlZXNlJzogJ2NydW1wZXRzJyxcbiAgICogICAnc3R1ZmYnOiBmdW5jdGlvbigpIHtcbiAgICogICAgIHJldHVybiAnbm9uc2Vuc2UnO1xuICAgKiAgIH1cbiAgICogfTtcbiAgICpcbiAgICogXy5yZXN1bHQob2JqZWN0LCAnY2hlZXNlJyk7XG4gICAqIC8vID0+ICdjcnVtcGV0cydcbiAgICpcbiAgICogXy5yZXN1bHQob2JqZWN0LCAnc3R1ZmYnKTtcbiAgICogLy8gPT4gJ25vbnNlbnNlJ1xuICAgKi9cbiAgZnVuY3Rpb24gcmVzdWx0KG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICAvLyBiYXNlZCBvbiBCYWNrYm9uZSdzIHByaXZhdGUgYGdldFZhbHVlYCBmdW5jdGlvblxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kb2N1bWVudGNsb3VkL2JhY2tib25lL2Jsb2IvMC45LjIvYmFja2JvbmUuanMjTDE0MTktMTQyNFxuICAgIHZhciB2YWx1ZSA9IG9iamVjdCA/IG9iamVjdFtwcm9wZXJ0eV0gOiBudWxsO1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKHZhbHVlKSA/IG9iamVjdFtwcm9wZXJ0eV0oKSA6IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgbWljcm8tdGVtcGxhdGluZyBtZXRob2QgdGhhdCBoYW5kbGVzIGFyYml0cmFyeSBkZWxpbWl0ZXJzLCBwcmVzZXJ2ZXNcbiAgICogd2hpdGVzcGFjZSwgYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXG4gICAqXG4gICAqIE5vdGU6IEluIHRoZSBkZXZlbG9wbWVudCBidWlsZCBgXy50ZW1wbGF0ZWAgdXRpbGl6ZXMgc291cmNlVVJMcyBmb3IgZWFzaWVyXG4gICAqIGRlYnVnZ2luZy4gU2VlIGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2RldmVsb3BlcnRvb2xzL3NvdXJjZW1hcHMvI3RvYy1zb3VyY2V1cmxcbiAgICpcbiAgICogTm90ZTogTG8tRGFzaCBtYXkgYmUgdXNlZCBpbiBDaHJvbWUgZXh0ZW5zaW9ucyBieSBlaXRoZXIgY3JlYXRpbmcgYSBgbG9kYXNoIGNzcGBcbiAgICogYnVpbGQgYW5kIGF2b2lkaW5nIGBfLnRlbXBsYXRlYCB1c2UsIG9yIGxvYWRpbmcgTG8tRGFzaCBpbiBhIHNhbmRib3hlZCBwYWdlLlxuICAgKiBTZWUgaHR0cDovL2RldmVsb3Blci5jaHJvbWUuY29tL3RydW5rL2V4dGVuc2lvbnMvc2FuZGJveGluZ0V2YWwuaHRtbFxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGhlIHRlbXBsYXRlIHRleHQuXG4gICAqIEBwYXJhbSB7T2JlY3R9IGRhdGEgVGhlIGRhdGEgb2JqZWN0IHVzZWQgdG8gcG9wdWxhdGUgdGhlIHRleHQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogIGVzY2FwZSAtIFRoZSBcImVzY2FwZVwiIGRlbGltaXRlciByZWdleHAuXG4gICAqICBldmFsdWF0ZSAtIFRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyIHJlZ2V4cC5cbiAgICogIGludGVycG9sYXRlIC0gVGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIgcmVnZXhwLlxuICAgKiAgc291cmNlVVJMIC0gVGhlIHNvdXJjZVVSTCBvZiB0aGUgdGVtcGxhdGUncyBjb21waWxlZCBzb3VyY2UuXG4gICAqICB2YXJpYWJsZSAtIFRoZSBkYXRhIG9iamVjdCB2YXJpYWJsZSBuYW1lLlxuICAgKlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb258U3RyaW5nfSBSZXR1cm5zIGEgY29tcGlsZWQgZnVuY3Rpb24gd2hlbiBubyBgZGF0YWAgb2JqZWN0XG4gICAqICBpcyBnaXZlbiwgZWxzZSBpdCByZXR1cm5zIHRoZSBpbnRlcnBvbGF0ZWQgdGV4dC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogLy8gdXNpbmcgYSBjb21waWxlZCB0ZW1wbGF0ZVxuICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gbmFtZSAlPicpO1xuICAgKiBjb21waWxlZCh7ICduYW1lJzogJ21vZScgfSk7XG4gICAqIC8vID0+ICdoZWxsbyBtb2UnXG4gICAqXG4gICAqIHZhciBsaXN0ID0gJzwlIF8uZm9yRWFjaChwZW9wbGUsIGZ1bmN0aW9uKG5hbWUpIHsgJT48bGk+PCU9IG5hbWUgJT48L2xpPjwlIH0pOyAlPic7XG4gICAqIF8udGVtcGxhdGUobGlzdCwgeyAncGVvcGxlJzogWydtb2UnLCAnbGFycnknLCAnY3VybHknXSB9KTtcbiAgICogLy8gPT4gJzxsaT5tb2U8L2xpPjxsaT5sYXJyeTwvbGk+PGxpPmN1cmx5PC9saT4nXG4gICAqXG4gICAqIC8vIHVzaW5nIHRoZSBcImVzY2FwZVwiIGRlbGltaXRlciB0byBlc2NhcGUgSFRNTCBpbiBkYXRhIHByb3BlcnR5IHZhbHVlc1xuICAgKiBfLnRlbXBsYXRlKCc8Yj48JS0gdmFsdWUgJT48L2I+JywgeyAndmFsdWUnOiAnPHNjcmlwdD4nIH0pO1xuICAgKiAvLyA9PiAnPGI+Jmx0O3NjcmlwdCZndDs8L2I+J1xuICAgKlxuICAgKiAvLyB1c2luZyB0aGUgRVM2IGRlbGltaXRlciBhcyBhbiBhbHRlcm5hdGl2ZSB0byB0aGUgZGVmYXVsdCBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyXG4gICAqIF8udGVtcGxhdGUoJ2hlbGxvICR7IG5hbWUgfScsIHsgJ25hbWUnOiAnY3VybHknIH0pO1xuICAgKiAvLyA9PiAnaGVsbG8gY3VybHknXG4gICAqXG4gICAqIC8vIHVzaW5nIHRoZSBpbnRlcm5hbCBgcHJpbnRgIGZ1bmN0aW9uIGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzXG4gICAqIF8udGVtcGxhdGUoJzwlIHByaW50KFwiaGVsbG8gXCIgKyBlcGl0aGV0KTsgJT4hJywgeyAnZXBpdGhldCc6ICdzdG9vZ2UnIH0pO1xuICAgKiAvLyA9PiAnaGVsbG8gc3Rvb2dlISdcbiAgICpcbiAgICogLy8gdXNpbmcgY3VzdG9tIHRlbXBsYXRlIGRlbGltaXRlcnNcbiAgICogXy50ZW1wbGF0ZVNldHRpbmdzID0ge1xuICAgKiAgICdpbnRlcnBvbGF0ZSc6IC97eyhbXFxzXFxTXSs/KX19L2dcbiAgICogfTtcbiAgICpcbiAgICogXy50ZW1wbGF0ZSgnaGVsbG8ge3sgbmFtZSB9fSEnLCB7ICduYW1lJzogJ211c3RhY2hlJyB9KTtcbiAgICogLy8gPT4gJ2hlbGxvIG11c3RhY2hlISdcbiAgICpcbiAgICogLy8gdXNpbmcgdGhlIGBzb3VyY2VVUkxgIG9wdGlvbiB0byBzcGVjaWZ5IGEgY3VzdG9tIHNvdXJjZVVSTCBmb3IgdGhlIHRlbXBsYXRlXG4gICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSBuYW1lICU+JywgbnVsbCwgeyAnc291cmNlVVJMJzogJy9iYXNpYy9ncmVldGluZy5qc3QnIH0pO1xuICAgKiBjb21waWxlZChkYXRhKTtcbiAgICogLy8gPT4gZmluZCB0aGUgc291cmNlIG9mIFwiZ3JlZXRpbmcuanN0XCIgdW5kZXIgdGhlIFNvdXJjZXMgdGFiIG9yIFJlc291cmNlcyBwYW5lbCBvZiB0aGUgd2ViIGluc3BlY3RvclxuICAgKlxuICAgKiAvLyB1c2luZyB0aGUgYHZhcmlhYmxlYCBvcHRpb24gdG8gZW5zdXJlIGEgd2l0aC1zdGF0ZW1lbnQgaXNuJ3QgdXNlZCBpbiB0aGUgY29tcGlsZWQgdGVtcGxhdGVcbiAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IGRhdGEubmFtZSAlPiEnLCBudWxsLCB7ICd2YXJpYWJsZSc6ICdkYXRhJyB9KTtcbiAgICogY29tcGlsZWQuc291cmNlO1xuICAgKiAvLyA9PiBmdW5jdGlvbihkYXRhKSB7XG4gICAqICAgdmFyIF9fdCwgX19wID0gJycsIF9fZSA9IF8uZXNjYXBlO1xuICAgKiAgIF9fcCArPSAnaGVsbG8gJyArICgoX190ID0gKCBkYXRhLm5hbWUgKSkgPT0gbnVsbCA/ICcnIDogX190KSArICchJztcbiAgICogICByZXR1cm4gX19wO1xuICAgKiB9XG4gICAqXG4gICAqIC8vIHVzaW5nIHRoZSBgc291cmNlYCBwcm9wZXJ0eSB0byBpbmxpbmUgY29tcGlsZWQgdGVtcGxhdGVzIGZvciBtZWFuaW5nZnVsXG4gICAqIC8vIGxpbmUgbnVtYmVycyBpbiBlcnJvciBtZXNzYWdlcyBhbmQgYSBzdGFjayB0cmFjZVxuICAgKiBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihjd2QsICdqc3QuanMnKSwgJ1xcXG4gICAqICAgdmFyIEpTVCA9IHtcXFxuICAgKiAgICAgXCJtYWluXCI6ICcgKyBfLnRlbXBsYXRlKG1haW5UZXh0KS5zb3VyY2UgKyAnXFxcbiAgICogICB9O1xcXG4gICAqICcpO1xuICAgKi9cbiAgZnVuY3Rpb24gdGVtcGxhdGUodGV4dCwgZGF0YSwgb3B0aW9ucykge1xuICAgIC8vIGJhc2VkIG9uIEpvaG4gUmVzaWcncyBgdG1wbGAgaW1wbGVtZW50YXRpb25cbiAgICAvLyBodHRwOi8vZWpvaG4ub3JnL2Jsb2cvamF2YXNjcmlwdC1taWNyby10ZW1wbGF0aW5nL1xuICAgIC8vIGFuZCBMYXVyYSBEb2t0b3JvdmEncyBkb1QuanNcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vb2xhZG8vZG9UXG4gICAgdGV4dCB8fCAodGV4dCA9ICcnKTtcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuXG4gICAgdmFyIGlzRXZhbHVhdGluZyxcbiAgICAgICAgcmVzdWx0LFxuICAgICAgICBzZXR0aW5ncyA9IGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzLFxuICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgIGludGVycG9sYXRlID0gb3B0aW9ucy5pbnRlcnBvbGF0ZSB8fCBzZXR0aW5ncy5pbnRlcnBvbGF0ZSB8fCByZU5vTWF0Y2gsXG4gICAgICAgIHNvdXJjZSA9IFwiX19wICs9ICdcIixcbiAgICAgICAgdmFyaWFibGUgPSBvcHRpb25zLnZhcmlhYmxlIHx8IHNldHRpbmdzLnZhcmlhYmxlLFxuICAgICAgICBoYXNWYXJpYWJsZSA9IHZhcmlhYmxlO1xuXG4gICAgLy8gY29tcGlsZSByZWdleHAgdG8gbWF0Y2ggZWFjaCBkZWxpbWl0ZXJcbiAgICB2YXIgcmVEZWxpbWl0ZXJzID0gUmVnRXhwKFxuICAgICAgKG9wdGlvbnMuZXNjYXBlIHx8IHNldHRpbmdzLmVzY2FwZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgICBpbnRlcnBvbGF0ZS5zb3VyY2UgKyAnfCcgK1xuICAgICAgKGludGVycG9sYXRlID09PSByZUludGVycG9sYXRlID8gcmVFc1RlbXBsYXRlIDogcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgICAgKG9wdGlvbnMuZXZhbHVhdGUgfHwgc2V0dGluZ3MuZXZhbHVhdGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCQnXG4gICAgLCAnZycpO1xuXG4gICAgdGV4dC5yZXBsYWNlKHJlRGVsaW1pdGVycywgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZVZhbHVlLCBpbnRlcnBvbGF0ZVZhbHVlLCBlc1RlbXBsYXRlVmFsdWUsIGV2YWx1YXRlVmFsdWUsIG9mZnNldCkge1xuICAgICAgaW50ZXJwb2xhdGVWYWx1ZSB8fCAoaW50ZXJwb2xhdGVWYWx1ZSA9IGVzVGVtcGxhdGVWYWx1ZSk7XG5cbiAgICAgIC8vIGVzY2FwZSBjaGFyYWN0ZXJzIHRoYXQgY2Fubm90IGJlIGluY2x1ZGVkIGluIHN0cmluZyBsaXRlcmFsc1xuICAgICAgc291cmNlICs9IHRleHQuc2xpY2UoaW5kZXgsIG9mZnNldCkucmVwbGFjZShyZVVuZXNjYXBlZFN0cmluZywgZXNjYXBlU3RyaW5nQ2hhcik7XG5cbiAgICAgIC8vIHJlcGxhY2UgZGVsaW1pdGVycyB3aXRoIHNuaXBwZXRzXG4gICAgICBzb3VyY2UgKz1cbiAgICAgICAgZXNjYXBlVmFsdWUgPyBcIicgK1xcbl9fZShcIiArIGVzY2FwZVZhbHVlICsgXCIpICtcXG4nXCIgOlxuICAgICAgICBldmFsdWF0ZVZhbHVlID8gXCInO1xcblwiICsgZXZhbHVhdGVWYWx1ZSArIFwiO1xcbl9fcCArPSAnXCIgOlxuICAgICAgICBpbnRlcnBvbGF0ZVZhbHVlID8gXCInICtcXG4oKF9fdCA9IChcIiArIGludGVycG9sYXRlVmFsdWUgKyBcIikpID09IG51bGwgPyAnJyA6IF9fdCkgK1xcbidcIiA6ICcnO1xuXG4gICAgICBpc0V2YWx1YXRpbmcgfHwgKGlzRXZhbHVhdGluZyA9IGV2YWx1YXRlVmFsdWUgfHwgcmVDb21wbGV4RGVsaW1pdGVyLnRlc3QoZXNjYXBlVmFsdWUgfHwgaW50ZXJwb2xhdGVWYWx1ZSkpO1xuICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG4gICAgfSk7XG5cbiAgICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gICAgLy8gaWYgYHZhcmlhYmxlYCBpcyBub3Qgc3BlY2lmaWVkIGFuZCB0aGUgdGVtcGxhdGUgY29udGFpbnMgXCJldmFsdWF0ZVwiXG4gICAgLy8gZGVsaW1pdGVycywgd3JhcCBhIHdpdGgtc3RhdGVtZW50IGFyb3VuZCB0aGUgZ2VuZXJhdGVkIGNvZGUgdG8gYWRkIHRoZVxuICAgIC8vIGRhdGEgb2JqZWN0IHRvIHRoZSB0b3Agb2YgdGhlIHNjb3BlIGNoYWluXG4gICAgaWYgKCFoYXNWYXJpYWJsZSkge1xuICAgICAgdmFyaWFibGUgPSAnb2JqJztcbiAgICAgIGlmIChpc0V2YWx1YXRpbmcpIHtcbiAgICAgICAgc291cmNlID0gJ3dpdGggKCcgKyB2YXJpYWJsZSArICcpIHtcXG4nICsgc291cmNlICsgJ1xcbn1cXG4nO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIGF2b2lkIGEgd2l0aC1zdGF0ZW1lbnQgYnkgcHJlcGVuZGluZyBkYXRhIG9iamVjdCByZWZlcmVuY2VzIHRvIHByb3BlcnR5IG5hbWVzXG4gICAgICAgIHZhciByZURvdWJsZVZhcmlhYmxlID0gUmVnRXhwKCcoXFxcXChcXFxccyopJyArIHZhcmlhYmxlICsgJ1xcXFwuJyArIHZhcmlhYmxlICsgJ1xcXFxiJywgJ2cnKTtcbiAgICAgICAgc291cmNlID0gc291cmNlXG4gICAgICAgICAgLnJlcGxhY2UocmVJbnNlcnRWYXJpYWJsZSwgJyQmJyArIHZhcmlhYmxlICsgJy4nKVxuICAgICAgICAgIC5yZXBsYWNlKHJlRG91YmxlVmFyaWFibGUsICckMV9fZCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNsZWFudXAgY29kZSBieSBzdHJpcHBpbmcgZW1wdHkgc3RyaW5nc1xuICAgIHNvdXJjZSA9IChpc0V2YWx1YXRpbmcgPyBzb3VyY2UucmVwbGFjZShyZUVtcHR5U3RyaW5nTGVhZGluZywgJycpIDogc291cmNlKVxuICAgICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ01pZGRsZSwgJyQxJylcbiAgICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdUcmFpbGluZywgJyQxOycpO1xuXG4gICAgLy8gZnJhbWUgY29kZSBhcyB0aGUgZnVuY3Rpb24gYm9keVxuICAgIHNvdXJjZSA9ICdmdW5jdGlvbignICsgdmFyaWFibGUgKyAnKSB7XFxuJyArXG4gICAgICAoaGFzVmFyaWFibGUgPyAnJyA6IHZhcmlhYmxlICsgJyB8fCAoJyArIHZhcmlhYmxlICsgJyA9IHt9KTtcXG4nKSArXG4gICAgICAndmFyIF9fdCwgX19wID0gXFwnXFwnLCBfX2UgPSBfLmVzY2FwZScgK1xuICAgICAgKGlzRXZhbHVhdGluZ1xuICAgICAgICA/ICcsIF9faiA9IEFycmF5LnByb3RvdHlwZS5qb2luO1xcbicgK1xuICAgICAgICAgICdmdW5jdGlvbiBwcmludCgpIHsgX19wICs9IF9fai5jYWxsKGFyZ3VtZW50cywgXFwnXFwnKSB9XFxuJ1xuICAgICAgICA6IChoYXNWYXJpYWJsZSA/ICcnIDogJywgX19kID0gJyArIHZhcmlhYmxlICsgJy4nICsgdmFyaWFibGUgKyAnIHx8ICcgKyB2YXJpYWJsZSkgKyAnO1xcbidcbiAgICAgICkgK1xuICAgICAgc291cmNlICtcbiAgICAgICdyZXR1cm4gX19wXFxufSc7XG5cbiAgICAvLyB1c2UgYSBzb3VyY2VVUkwgZm9yIGVhc2llciBkZWJ1Z2dpbmdcbiAgICAvLyBodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9kZXZlbG9wZXJ0b29scy9zb3VyY2VtYXBzLyN0b2Mtc291cmNldXJsXG4gICAgdmFyIHNvdXJjZVVSTCA9IHVzZVNvdXJjZVVSTFxuICAgICAgPyAnXFxuLy9AIHNvdXJjZVVSTD0nICsgKG9wdGlvbnMuc291cmNlVVJMIHx8ICcvbG9kYXNoL3RlbXBsYXRlL3NvdXJjZVsnICsgKHRlbXBsYXRlQ291bnRlcisrKSArICddJylcbiAgICAgIDogJyc7XG5cbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gRnVuY3Rpb24oJ18nLCAncmV0dXJuICcgKyBzb3VyY2UgKyBzb3VyY2VVUkwpKGxvZGFzaCk7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBlLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIHJldHVybiByZXN1bHQoZGF0YSk7XG4gICAgfVxuICAgIC8vIHByb3ZpZGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uJ3Mgc291cmNlIHZpYSBpdHMgYHRvU3RyaW5nYCBtZXRob2QsIGluXG4gICAgLy8gc3VwcG9ydGVkIGVudmlyb25tZW50cywgb3IgdGhlIGBzb3VyY2VgIHByb3BlcnR5IGFzIGEgY29udmVuaWVuY2UgZm9yXG4gICAgLy8gaW5saW5pbmcgY29tcGlsZWQgdGVtcGxhdGVzIGR1cmluZyB0aGUgYnVpbGQgcHJvY2Vzc1xuICAgIHJlc3VsdC5zb3VyY2UgPSBzb3VyY2U7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyB0aGUgYGNhbGxiYWNrYCBmdW5jdGlvbiBgbmAgdGltZXMsIHJldHVybmluZyBhbiBhcnJheSBvZiB0aGUgcmVzdWx0c1xuICAgKiBvZiBlYWNoIGBjYWxsYmFja2AgZXhlY3V0aW9uLiBUaGUgYGNhbGxiYWNrYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWRcbiAgICogd2l0aCBvbmUgYXJndW1lbnQ7IChpbmRleCkuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgKiBAcGFyYW0ge051bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGV4ZWN1dGUgdGhlIGNhbGxiYWNrLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7TWl4ZWR9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIHRoZSByZXN1bHRzIG9mIGVhY2ggYGNhbGxiYWNrYCBleGVjdXRpb24uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBkaWNlUm9sbHMgPSBfLnRpbWVzKDMsIF8ucGFydGlhbChfLnJhbmRvbSwgMSwgNikpO1xuICAgKiAvLyA9PiBbMywgNiwgNF1cbiAgICpcbiAgICogXy50aW1lcygzLCBmdW5jdGlvbihuKSB7IG1hZ2UuY2FzdFNwZWxsKG4pOyB9KTtcbiAgICogLy8gPT4gY2FsbHMgYG1hZ2UuY2FzdFNwZWxsKG4pYCB0aHJlZSB0aW1lcywgcGFzc2luZyBgbmAgb2YgYDBgLCBgMWAsIGFuZCBgMmAgcmVzcGVjdGl2ZWx5XG4gICAqXG4gICAqIF8udGltZXMoMywgZnVuY3Rpb24obikgeyB0aGlzLmNhc3Qobik7IH0sIG1hZ2UpO1xuICAgKiAvLyA9PiBhbHNvIGNhbGxzIGBtYWdlLmNhc3RTcGVsbChuKWAgdGhyZWUgdGltZXNcbiAgICovXG4gIGZ1bmN0aW9uIHRpbWVzKG4sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgbiA9ICtuIHx8IDA7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gY2FsbGJhY2suY2FsbCh0aGlzQXJnLCBpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIG9wcG9zaXRlIG9mIGBfLmVzY2FwZWAsIHRoaXMgbWV0aG9kIGNvbnZlcnRzIHRoZSBIVE1MIGVudGl0aWVzXG4gICAqIGAmYW1wO2AsIGAmbHQ7YCwgYCZndDtgLCBgJnF1b3Q7YCwgYW5kIGAmI3gyNztgIGluIGBzdHJpbmdgIHRvIHRoZWlyXG4gICAqIGNvcnJlc3BvbmRpbmcgY2hhcmFjdGVycy5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byB1bmVzY2FwZS5cbiAgICogQHJldHVybnMge1N0cmluZ30gUmV0dXJucyB0aGUgdW5lc2NhcGVkIHN0cmluZy5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy51bmVzY2FwZSgnTW9lLCBMYXJyeSAmYW1wOyBDdXJseScpO1xuICAgKiAvLyA9PiBcIk1vZSwgTGFycnkgJiBDdXJseVwiXG4gICAqL1xuICBmdW5jdGlvbiB1bmVzY2FwZShzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nID09IG51bGwgPyAnJyA6IChzdHJpbmcgKyAnJykucmVwbGFjZShyZUVzY2FwZWRIdG1sLCB1bmVzY2FwZUh0bWxDaGFyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSB1bmlxdWUgaWQuIElmIGBwcmVmaXhgIGlzIHBhc3NlZCwgdGhlIGlkIHdpbGwgYmUgYXBwZW5kZWQgdG8gaXQuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW3ByZWZpeF0gVGhlIHZhbHVlIHRvIHByZWZpeCB0aGUgaWQgd2l0aC5cbiAgICogQHJldHVybnMge051bWJlcnxTdHJpbmd9IFJldHVybnMgYSBudW1lcmljIGlkIGlmIG5vIHByZWZpeCBpcyBwYXNzZWQsIGVsc2VcbiAgICogIGEgc3RyaW5nIGlkIG1heSBiZSByZXR1cm5lZC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy51bmlxdWVJZCgnY29udGFjdF8nKTtcbiAgICogLy8gPT4gJ2NvbnRhY3RfMTA0J1xuICAgKi9cbiAgZnVuY3Rpb24gdW5pcXVlSWQocHJlZml4KSB7XG4gICAgdmFyIGlkID0gaWRDb3VudGVyKys7XG4gICAgcmV0dXJuIHByZWZpeCA/IHByZWZpeCArIGlkIDogaWQ7XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogV3JhcHMgdGhlIHZhbHVlIGluIGEgYGxvZGFzaGAgd3JhcHBlciBvYmplY3QuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IENoYWluaW5nXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIHN0b29nZXMgPSBbXG4gICAqICAgeyAnbmFtZSc6ICdtb2UnLCAnYWdlJzogNDAgfSxcbiAgICogICB7ICduYW1lJzogJ2xhcnJ5JywgJ2FnZSc6IDUwIH0sXG4gICAqICAgeyAnbmFtZSc6ICdjdXJseScsICdhZ2UnOiA2MCB9XG4gICAqIF07XG4gICAqXG4gICAqIHZhciB5b3VuZ2VzdCA9IF8uY2hhaW4oc3Rvb2dlcylcbiAgICogICAgIC5zb3J0QnkoZnVuY3Rpb24oc3Rvb2dlKSB7IHJldHVybiBzdG9vZ2UuYWdlOyB9KVxuICAgKiAgICAgLm1hcChmdW5jdGlvbihzdG9vZ2UpIHsgcmV0dXJuIHN0b29nZS5uYW1lICsgJyBpcyAnICsgc3Rvb2dlLmFnZTsgfSlcbiAgICogICAgIC5maXJzdCgpXG4gICAqICAgICAudmFsdWUoKTtcbiAgICogLy8gPT4gJ21vZSBpcyA0MCdcbiAgICovXG4gIGZ1bmN0aW9uIGNoYWluKHZhbHVlKSB7XG4gICAgdmFsdWUgPSBuZXcgbG9kYXNoKHZhbHVlKTtcbiAgICB2YWx1ZS5fX2NoYWluX18gPSB0cnVlO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VzIGBpbnRlcmNlcHRvcmAgd2l0aCB0aGUgYHZhbHVlYCBhcyB0aGUgZmlyc3QgYXJndW1lbnQsIGFuZCB0aGVuXG4gICAqIHJldHVybnMgYHZhbHVlYC4gVGhlIHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gXCJ0YXAgaW50b1wiIGEgbWV0aG9kIGNoYWluLFxuICAgKiBpbiBvcmRlciB0byBwZXJmb3JtIG9wZXJhdGlvbnMgb24gaW50ZXJtZWRpYXRlIHJlc3VsdHMgd2l0aGluIHRoZSBjaGFpbi5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgQ2hhaW5pbmdcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgVGhlIHZhbHVlIHRvIHBhc3MgdG8gYGludGVyY2VwdG9yYC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW50ZXJjZXB0b3IgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICogQHJldHVybnMge01peGVkfSBSZXR1cm5zIGB2YWx1ZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uY2hhaW4oWzEsIDIsIDMsIDIwMF0pXG4gICAqICAuZmlsdGVyKGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gbnVtICUgMiA9PSAwOyB9KVxuICAgKiAgLnRhcChhbGVydClcbiAgICogIC5tYXAoZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gKiBudW0gfSlcbiAgICogIC52YWx1ZSgpO1xuICAgKiAvLyA9PiAvLyBbMiwgMjAwXSAoYWxlcnRlZClcbiAgICogLy8gPT4gWzQsIDQwMDAwXVxuICAgKi9cbiAgZnVuY3Rpb24gdGFwKHZhbHVlLCBpbnRlcmNlcHRvcikge1xuICAgIGludGVyY2VwdG9yKHZhbHVlKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogRW5hYmxlcyBtZXRob2QgY2hhaW5pbmcgb24gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICAgKlxuICAgKiBAbmFtZSBjaGFpblxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgQ2hhaW5pbmdcbiAgICogQHJldHVybnMge01peGVkfSBSZXR1cm5zIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXyhbMSwgMiwgM10pLnZhbHVlKCk7XG4gICAqIC8vID0+IFsxLCAyLCAzXVxuICAgKi9cbiAgZnVuY3Rpb24gd3JhcHBlckNoYWluKCkge1xuICAgIHRoaXMuX19jaGFpbl9fID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0cyB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgICpcbiAgICogQG5hbWUgdmFsdWVcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IENoYWluaW5nXG4gICAqIEByZXR1cm5zIHtNaXhlZH0gUmV0dXJucyB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXyhbMSwgMiwgM10pLnZhbHVlKCk7XG4gICAqIC8vID0+IFsxLCAyLCAzXVxuICAgKi9cbiAgZnVuY3Rpb24gd3JhcHBlclZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9fd3JhcHBlZF9fO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIFRoZSBzZW1hbnRpYyB2ZXJzaW9uIG51bWJlci5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAdHlwZSBTdHJpbmdcbiAgICovXG4gIGxvZGFzaC5WRVJTSU9OID0gJzAuOS4yJztcblxuICAvLyBhc3NpZ24gc3RhdGljIG1ldGhvZHNcbiAgbG9kYXNoLmFmdGVyID0gYWZ0ZXI7XG4gIGxvZGFzaC5iaW5kID0gYmluZDtcbiAgbG9kYXNoLmJpbmRBbGwgPSBiaW5kQWxsO1xuICBsb2Rhc2guY2hhaW4gPSBjaGFpbjtcbiAgbG9kYXNoLmNsb25lID0gY2xvbmU7XG4gIGxvZGFzaC5jb21wYWN0ID0gY29tcGFjdDtcbiAgbG9kYXNoLmNvbXBvc2UgPSBjb21wb3NlO1xuICBsb2Rhc2guY29udGFpbnMgPSBjb250YWlucztcbiAgbG9kYXNoLmNvdW50QnkgPSBjb3VudEJ5O1xuICBsb2Rhc2guZGVib3VuY2UgPSBkZWJvdW5jZTtcbiAgbG9kYXNoLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gIGxvZGFzaC5kZWZlciA9IGRlZmVyO1xuICBsb2Rhc2guZGVsYXkgPSBkZWxheTtcbiAgbG9kYXNoLmRpZmZlcmVuY2UgPSBkaWZmZXJlbmNlO1xuICBsb2Rhc2guZXNjYXBlID0gZXNjYXBlO1xuICBsb2Rhc2guZXZlcnkgPSBldmVyeTtcbiAgbG9kYXNoLmV4dGVuZCA9IGV4dGVuZDtcbiAgbG9kYXNoLmZpbHRlciA9IGZpbHRlcjtcbiAgbG9kYXNoLmZpbmQgPSBmaW5kO1xuICBsb2Rhc2guZmlyc3QgPSBmaXJzdDtcbiAgbG9kYXNoLmZsYXR0ZW4gPSBmbGF0dGVuO1xuICBsb2Rhc2guZm9yRWFjaCA9IGZvckVhY2g7XG4gIGxvZGFzaC5mb3JJbiA9IGZvckluO1xuICBsb2Rhc2guZm9yT3duID0gZm9yT3duO1xuICBsb2Rhc2guZnVuY3Rpb25zID0gZnVuY3Rpb25zO1xuICBsb2Rhc2guZ3JvdXBCeSA9IGdyb3VwQnk7XG4gIGxvZGFzaC5oYXMgPSBoYXM7XG4gIGxvZGFzaC5pZGVudGl0eSA9IGlkZW50aXR5O1xuICBsb2Rhc2guaW5kZXhPZiA9IGluZGV4T2Y7XG4gIGxvZGFzaC5pbml0aWFsID0gaW5pdGlhbDtcbiAgbG9kYXNoLmludGVyc2VjdGlvbiA9IGludGVyc2VjdGlvbjtcbiAgbG9kYXNoLmludmVydCA9IGludmVydDtcbiAgbG9kYXNoLmludm9rZSA9IGludm9rZTtcbiAgbG9kYXNoLmlzQXJndW1lbnRzID0gaXNBcmd1bWVudHM7XG4gIGxvZGFzaC5pc0FycmF5ID0gaXNBcnJheTtcbiAgbG9kYXNoLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcbiAgbG9kYXNoLmlzRGF0ZSA9IGlzRGF0ZTtcbiAgbG9kYXNoLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbiAgbG9kYXNoLmlzRW1wdHkgPSBpc0VtcHR5O1xuICBsb2Rhc2guaXNFcXVhbCA9IGlzRXF1YWw7XG4gIGxvZGFzaC5pc0Zpbml0ZSA9IGlzRmluaXRlO1xuICBsb2Rhc2guaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG4gIGxvZGFzaC5pc05hTiA9IGlzTmFOO1xuICBsb2Rhc2guaXNOdWxsID0gaXNOdWxsO1xuICBsb2Rhc2guaXNOdW1iZXIgPSBpc051bWJlcjtcbiAgbG9kYXNoLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG4gIGxvZGFzaC5pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdDtcbiAgbG9kYXNoLmlzUmVnRXhwID0gaXNSZWdFeHA7XG4gIGxvZGFzaC5pc1N0cmluZyA9IGlzU3RyaW5nO1xuICBsb2Rhc2guaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcbiAgbG9kYXNoLmtleXMgPSBrZXlzO1xuICBsb2Rhc2gubGFzdCA9IGxhc3Q7XG4gIGxvZGFzaC5sYXN0SW5kZXhPZiA9IGxhc3RJbmRleE9mO1xuICBsb2Rhc2gubGF0ZUJpbmQgPSBsYXRlQmluZDtcbiAgbG9kYXNoLm1hcCA9IG1hcDtcbiAgbG9kYXNoLm1heCA9IG1heDtcbiAgbG9kYXNoLm1lbW9pemUgPSBtZW1vaXplO1xuICBsb2Rhc2gubWVyZ2UgPSBtZXJnZTtcbiAgbG9kYXNoLm1pbiA9IG1pbjtcbiAgbG9kYXNoLm1peGluID0gbWl4aW47XG4gIGxvZGFzaC5ub0NvbmZsaWN0ID0gbm9Db25mbGljdDtcbiAgbG9kYXNoLm9iamVjdCA9IG9iamVjdDtcbiAgbG9kYXNoLm9taXQgPSBvbWl0O1xuICBsb2Rhc2gub25jZSA9IG9uY2U7XG4gIGxvZGFzaC5wYWlycyA9IHBhaXJzO1xuICBsb2Rhc2gucGFydGlhbCA9IHBhcnRpYWw7XG4gIGxvZGFzaC5waWNrID0gcGljaztcbiAgbG9kYXNoLnBsdWNrID0gcGx1Y2s7XG4gIGxvZGFzaC5yYW5kb20gPSByYW5kb207XG4gIGxvZGFzaC5yYW5nZSA9IHJhbmdlO1xuICBsb2Rhc2gucmVkdWNlID0gcmVkdWNlO1xuICBsb2Rhc2gucmVkdWNlUmlnaHQgPSByZWR1Y2VSaWdodDtcbiAgbG9kYXNoLnJlamVjdCA9IHJlamVjdDtcbiAgbG9kYXNoLnJlc3QgPSByZXN0O1xuICBsb2Rhc2gucmVzdWx0ID0gcmVzdWx0O1xuICBsb2Rhc2guc2h1ZmZsZSA9IHNodWZmbGU7XG4gIGxvZGFzaC5zaXplID0gc2l6ZTtcbiAgbG9kYXNoLnNvbWUgPSBzb21lO1xuICBsb2Rhc2guc29ydEJ5ID0gc29ydEJ5O1xuICBsb2Rhc2guc29ydGVkSW5kZXggPSBzb3J0ZWRJbmRleDtcbiAgbG9kYXNoLnRhcCA9IHRhcDtcbiAgbG9kYXNoLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gIGxvZGFzaC50aHJvdHRsZSA9IHRocm90dGxlO1xuICBsb2Rhc2gudGltZXMgPSB0aW1lcztcbiAgbG9kYXNoLnRvQXJyYXkgPSB0b0FycmF5O1xuICBsb2Rhc2gudW5lc2NhcGUgPSB1bmVzY2FwZTtcbiAgbG9kYXNoLnVuaW9uID0gdW5pb247XG4gIGxvZGFzaC51bmlxID0gdW5pcTtcbiAgbG9kYXNoLnVuaXF1ZUlkID0gdW5pcXVlSWQ7XG4gIGxvZGFzaC52YWx1ZXMgPSB2YWx1ZXM7XG4gIGxvZGFzaC53aGVyZSA9IHdoZXJlO1xuICBsb2Rhc2gud2l0aG91dCA9IHdpdGhvdXQ7XG4gIGxvZGFzaC53cmFwID0gd3JhcDtcbiAgbG9kYXNoLnppcCA9IHppcDtcblxuICAvLyBhc3NpZ24gYWxpYXNlc1xuICBsb2Rhc2guYWxsID0gZXZlcnk7XG4gIGxvZGFzaC5hbnkgPSBzb21lO1xuICBsb2Rhc2guY29sbGVjdCA9IG1hcDtcbiAgbG9kYXNoLmRldGVjdCA9IGZpbmQ7XG4gIGxvZGFzaC5kcm9wID0gcmVzdDtcbiAgbG9kYXNoLmVhY2ggPSBmb3JFYWNoO1xuICBsb2Rhc2guZm9sZGwgPSByZWR1Y2U7XG4gIGxvZGFzaC5mb2xkciA9IHJlZHVjZVJpZ2h0O1xuICBsb2Rhc2guaGVhZCA9IGZpcnN0O1xuICBsb2Rhc2guaW5jbHVkZSA9IGNvbnRhaW5zO1xuICBsb2Rhc2guaW5qZWN0ID0gcmVkdWNlO1xuICBsb2Rhc2gubWV0aG9kcyA9IGZ1bmN0aW9ucztcbiAgbG9kYXNoLnNlbGVjdCA9IGZpbHRlcjtcbiAgbG9kYXNoLnRhaWwgPSByZXN0O1xuICBsb2Rhc2gudGFrZSA9IGZpcnN0O1xuICBsb2Rhc2gudW5pcXVlID0gdW5pcTtcblxuICAvLyBhZGQgcHNldWRvIHByaXZhdGUgcHJvcGVydHkgdG8gYmUgdXNlZCBhbmQgcmVtb3ZlZCBkdXJpbmcgdGhlIGJ1aWxkIHByb2Nlc3NcbiAgbG9kYXNoLl9pdGVyYXRvclRlbXBsYXRlID0gaXRlcmF0b3JUZW1wbGF0ZTtcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvLyBhZGQgYWxsIHN0YXRpYyBmdW5jdGlvbnMgdG8gYGxvZGFzaC5wcm90b3R5cGVgXG4gIG1peGluKGxvZGFzaCk7XG5cbiAgLy8gYWRkIGBsb2Rhc2gucHJvdG90eXBlLmNoYWluYCBhZnRlciBjYWxsaW5nIGBtaXhpbigpYCB0byBhdm9pZCBvdmVyd3JpdGluZ1xuICAvLyBpdCB3aXRoIHRoZSB3cmFwcGVkIGBsb2Rhc2guY2hhaW5gXG4gIGxvZGFzaC5wcm90b3R5cGUuY2hhaW4gPSB3cmFwcGVyQ2hhaW47XG4gIGxvZGFzaC5wcm90b3R5cGUudmFsdWUgPSB3cmFwcGVyVmFsdWU7XG5cbiAgLy8gYWRkIGFsbCBtdXRhdG9yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgZm9yRWFjaChbJ3BvcCcsICdwdXNoJywgJ3JldmVyc2UnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgdmFyIGZ1bmMgPSBhcnJheVJlZlttZXRob2ROYW1lXTtcblxuICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX187XG4gICAgICBmdW5jLmFwcGx5KHZhbHVlLCBhcmd1bWVudHMpO1xuXG4gICAgICAvLyBhdm9pZCBhcnJheS1saWtlIG9iamVjdCBidWdzIHdpdGggYEFycmF5I3NoaWZ0YCBhbmQgYEFycmF5I3NwbGljZWAgaW5cbiAgICAgIC8vIEZpcmVmb3ggPCAxMCBhbmQgSUUgPCA5XG4gICAgICBpZiAoaGFzT2JqZWN0U3BsaWNlQnVnICYmIHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkZWxldGUgdmFsdWVbMF07XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fX2NoYWluX18pIHtcbiAgICAgICAgdmFsdWUgPSBuZXcgbG9kYXNoKHZhbHVlKTtcbiAgICAgICAgdmFsdWUuX19jaGFpbl9fID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBhZGQgYWxsIGFjY2Vzc29yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgZm9yRWFjaChbJ2NvbmNhdCcsICdqb2luJywgJ3NsaWNlJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICB2YXIgZnVuYyA9IGFycmF5UmVmW21ldGhvZE5hbWVdO1xuXG4gICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXyxcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHZhbHVlLCBhcmd1bWVudHMpO1xuXG4gICAgICBpZiAodGhpcy5fX2NoYWluX18pIHtcbiAgICAgICAgcmVzdWx0ID0gbmV3IGxvZGFzaChyZXN1bHQpO1xuICAgICAgICByZXN1bHQuX19jaGFpbl9fID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfSk7XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8gZXhwb3NlIExvLURhc2hcbiAgLy8gc29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zIGxpa2UgdGhlIGZvbGxvd2luZzpcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gRXhwb3NlIExvLURhc2ggdG8gdGhlIGdsb2JhbCBvYmplY3QgZXZlbiB3aGVuIGFuIEFNRCBsb2FkZXIgaXMgcHJlc2VudCBpblxuICAgIC8vIGNhc2UgTG8tRGFzaCB3YXMgaW5qZWN0ZWQgYnkgYSB0aGlyZC1wYXJ0eSBzY3JpcHQgYW5kIG5vdCBpbnRlbmRlZCB0byBiZVxuICAgIC8vIGxvYWRlZCBhcyBhIG1vZHVsZS4gVGhlIGdsb2JhbCBhc3NpZ25tZW50IGNhbiBiZSByZXZlcnRlZCBpbiB0aGUgTG8tRGFzaFxuICAgIC8vIG1vZHVsZSB2aWEgaXRzIGBub0NvbmZsaWN0KClgIG1ldGhvZC5cbiAgICB3aW5kb3cuXyA9IGxvZGFzaDtcblxuICAgIC8vIGRlZmluZSBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlIHNvLCB0aHJvdWdoIHBhdGggbWFwcGluZywgaXQgY2FuIGJlXG4gICAgLy8gcmVmZXJlbmNlZCBhcyB0aGUgXCJ1bmRlcnNjb3JlXCIgbW9kdWxlXG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGxvZGFzaDtcbiAgICB9KTtcbiAgfVxuICAvLyBjaGVjayBmb3IgYGV4cG9ydHNgIGFmdGVyIGBkZWZpbmVgIGluIGNhc2UgYSBidWlsZCBvcHRpbWl6ZXIgYWRkcyBhbiBgZXhwb3J0c2Agb2JqZWN0XG4gIGVsc2UgaWYgKGZyZWVFeHBvcnRzKSB7XG4gICAgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTIHYwLjguMCtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHtcbiAgICAgIChtb2R1bGUuZXhwb3J0cyA9IGxvZGFzaCkuXyA9IGxvZGFzaDtcbiAgICB9XG4gICAgLy8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cbiAgICBlbHNlIHtcbiAgICAgIGZyZWVFeHBvcnRzLl8gPSBsb2Rhc2g7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIC8vIGluIGEgYnJvd3NlciBvciBSaGlub1xuICAgIHdpbmRvdy5fID0gbG9kYXNoO1xuICB9XG59KHRoaXMpKTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgd2FybmluZyA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0LCBhcmdzKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gPiAyID8gbGVuIC0gMiA6IDApO1xuICAgIGZvciAodmFyIGtleSA9IDI7IGtleSA8IGxlbjsga2V5KyspIHtcbiAgICAgIGFyZ3Nba2V5IC0gMl0gPSBhcmd1bWVudHNba2V5XTtcbiAgICB9XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICtcbiAgICAgICAgJ21lc3NhZ2UgYXJndW1lbnQnXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQubGVuZ3RoIDwgMTAgfHwgKC9eW3NcXFddKiQvKS50ZXN0KGZvcm1hdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1RoZSB3YXJuaW5nIGZvcm1hdCBzaG91bGQgYmUgYWJsZSB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzICcgK1xuICAgICAgICAnd2FybmluZy4gUGxlYXNlLCB1c2UgYSBtb3JlIGRlc2NyaXB0aXZlIGZvcm1hdCB0aGFuOiAnICsgZm9ybWF0XG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArXG4gICAgICAgIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgICAgfSk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgIH0gY2F0Y2goeCkge31cbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmluZztcbiJdfQ=="}